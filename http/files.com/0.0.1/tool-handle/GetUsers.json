{
  "name": "GetUsers",
  "description": "List Users",
  "parameters": {
    "type": "object",
    "properties": {
      "cursor": {
        "type": "string",
        "description": "Used for pagination.  When a list request has more records available, cursors are provided in the response headers `X-Files-Cursor-Next` and `X-Files-Cursor-Prev`.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination."
      },
      "per_page": {
        "format": "int32",
        "type": "integer",
        "description": "Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended)."
      },
      "sort_by": {
        "type": "object",
        "description": "If set, sort records by the specified field in either `asc` or `desc` direction (e.g. `sort_by[authenticate_until]=desc`). Valid fields are `authenticate_until`, `active`, `email`, `last_desktop_login_at`, `last_login_at`, `username`, `company`, `name`, `site_admin`, `receive_admin_alerts`, `password_validity_days`, `ssl_required` or `not_site_admin`."
      },
      "filter": {
        "type": "object",
        "description": "If set, return records where the specified field is equal to the supplied value. Valid fields are `username`, `email`, `company`, `site_admin`, `password_validity_days`, `ssl_required`, `last_login_at`, `authenticate_until` or `not_site_admin`. Valid field combinations are `[ not_site_admin, username ]`."
      },
      "filter_gt": {
        "type": "object",
        "description": "If set, return records where the specified field is greater than the supplied value. Valid fields are `password_validity_days`, `last_login_at` or `authenticate_until`."
      },
      "filter_gteq": {
        "type": "object",
        "description": "If set, return records where the specified field is greater than or equal the supplied value. Valid fields are `password_validity_days`, `last_login_at` or `authenticate_until`."
      },
      "filter_prefix": {
        "type": "object",
        "description": "If set, return records where the specified field is prefixed by the supplied value. Valid fields are `username`, `email` or `company`."
      },
      "filter_lt": {
        "type": "object",
        "description": "If set, return records where the specified field is less than the supplied value. Valid fields are `password_validity_days`, `last_login_at` or `authenticate_until`."
      },
      "filter_lteq": {
        "type": "object",
        "description": "If set, return records where the specified field is less than or equal the supplied value. Valid fields are `password_validity_days`, `last_login_at` or `authenticate_until`."
      },
      "ids": {
        "type": "string",
        "description": "comma-separated list of User IDs"
      },
      "q[username]": {
        "type": "string",
        "description": "List users matching username."
      },
      "q[email]": {
        "type": "string",
        "description": "List users matching email."
      },
      "q[notes]": {
        "type": "string",
        "description": "List users matching notes field."
      },
      "q[admin]": {
        "type": "string",
        "description": "If `true`, list only admin users."
      },
      "q[allowed_ips]": {
        "type": "string",
        "description": "If set, list only users with overridden allowed IP setting."
      },
      "q[password_validity_days]": {
        "type": "string",
        "description": "If set, list only users with overridden password validity days setting."
      },
      "q[ssl_required]": {
        "type": "string",
        "description": "If set, list only users with overridden SSL required setting."
      },
      "search": {
        "type": "string",
        "description": "Searches for partial matches of name, username, or email."
      }
    }
  },
  "handler": "http",
  "request": {
    "method": "GET",
    "url": {
      "$uri": "//app.files.com/api/rest/v1/users{?cursor,per_page,sort_by,filter,filter_gt,filter_gteq,filter_prefix,filter_lt,filter_lteq,ids,q[username],q[email],q[notes],q[admin],q[allowed_ips],q[password_validity_days],q[ssl_required],search}"
    }
  },
  "responses": {
    "200": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "List"
        },
        "Create User",
        "**Key properties:**",
        {
          "$ul": [
            "**active_2fa**: Is 2fa active for the user?",
            "**admin_group_ids**: List of group IDs of which this user is an administrator",
            "**allowed_ips**: A list of allowed IPs if applicable.  Newline delimited",
            "**api_keys_count**: Number of api keys associated with this user",
            "**attachments_permission**: DEPRECATED: Can the user create Bundles (aka Share Links)? Use the bundle permission instead.",
            "**authenticate_until**: Scheduled Date/Time at which user will be deactivated",
            "**authentication_method**: How is this user authenticated?",
            "**avatar_url**: URL holding the user's avatar",
            "**billing_permission**: Allow this user to perform operations on the account, payments, and invoices?",
            "**bypass_inactive_disable**: Exempt this user from being disabled based on inactivity?",
            "**bypass_site_allowed_ips**: Allow this user to skip site-wide IP blacklists?",
            "**company**: User's company",
            "**created_at**: When this user was created",
            "**dav_permission**: Can the user connect with WebDAV?",
            "**days_remaining_until_password_expire**: Number of days remaining until password expires",
            "**disabled**: Is user disabled? Disabled users cannot log in, and do not count for billing purposes.  Users can be automatically disabled after an inactivity period via a Site setting.",
            "**email**: User email address",
            "**externally_managed**: Is this user managed by a SsoStrategy?",
            "**first_login_at**: User's first login time",
            "**ftp_permission**: Can the user access with FTP/FTPS?",
            "**group_ids**: Comma-separated list of group IDs of which this user is a member",
            "**header_text**: Text to display to the user in the header of the UI",
            "**id**: User ID",
            "**language**: Preferred language",
            "**last_active_at**: User's most recent activity time, which is the latest of most recent login, most recent API use, enablement, or creation",
            "**last_api_use_at**: User's most recent API use time",
            "**last_dav_login_at**: User's most recent login time via WebDAV",
            "**last_desktop_login_at**: User's most recent login time via Desktop app",
            "**last_ftp_login_at**: User's most recent login time via FTP",
            "**last_login_at**: User's most recent login time via any protocol",
            "**last_protocol_cipher**: The most recent protocol and cipher used",
            "**last_restapi_login_at**: User's most recent login time via Rest API",
            "**last_sftp_login_at**: User's most recent login time via SFTP",
            "**last_web_login_at**: User's most recent login time via web",
            "**lockout_expires**: Time in the future that the user will no longer be locked out if applicable",
            "**name**: User's full name",
            "**notes**: Any internal notes on the user",
            "**notification_daily_send_time**: Hour of the day at which daily notifications should be sent. Can be in range 0 to 23",
            "**office_integration_enabled**: Enable integration with Office for the web?",
            "**password_expire_at**: Password expiration datetime",
            "**password_expired**: Is user's password expired?",
            "**password_set_at**: Last time the user's password was set",
            "**password_validity_days**: Number of days to allow user to use the same password",
            "**public_keys_count**: Number of public keys associated with this user",
            "**receive_admin_alerts**: Should the user receive admin alerts such a certificate expiration notifications and overages?",
            "**require_2fa**: 2FA required setting",
            "**require_password_change**: Is a password change required upon next user login?",
            "**restapi_permission**: Can this user access the REST API?",
            "**self_managed**: Does this user manage it's own credentials or is it a shared/bot user?",
            "**sftp_permission**: Can the user access with SFTP?",
            "**site_admin**: Is the user an administrator for this site?",
            "**skip_welcome_screen**: Skip Welcome page in the UI?",
            "**ssl_required**: SSL required setting",
            "**sso_strategy_id**: SSO (Single Sign On) strategy ID for the user, if applicable.",
            "**subscribe_to_newsletter**: Is the user subscribed to the newsletter?",
            "**time_zone**: User time zone",
            "**type_of_2fa**: Type(s) of 2FA methods in use.  Will be either `sms`, `totp`, `u2f`, `yubi`, or multiple values sorted alphabetically and joined by an underscore.",
            "**user_root**: Root folder for FTP (and optionally SFTP if the appropriate site-wide setting is set.)  Note that this is not used for API, Desktop, or Web interface.",
            "**username**: User's username"
          ]
        },
        {
          "$each": "$.body.*",
          "$as": "item",
          "$block": [
            {
              "$h2": {
                "$": "$.item.name"
              }
            },
            {
              "$lang": "json",
              "$code": {
                "$encode": "json",
                "$indent": true,
                "$content": {
                  "$": "$.item"
                }
              }
            }
          ]
        }
      ]
    }
  }
}
