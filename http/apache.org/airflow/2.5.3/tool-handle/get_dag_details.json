{
  "name": "get_dag_details",
  "description": "The response contains many DAG attributes, so the response can be large. If possible, consider using GET /dags/{dag_id}.\n",
  "parameters": {
    "type": "object",
    "properties": {
      "dag_id": {
        "type": "string",
        "description": "The DAG ID."
      }
    },
    "required": [
      "dag_id"
    ]
  },
  "handler": "http",
  "request": {
    "method": "GET",
    "url": {
      "$uri": "/api/v1/dags/{dag_id}/details"
    }
  },
  "responses": {
    "200": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "DAG",
        "**Key properties:**",
        {
          "$ul": [
            "**dag_id**: The ID of the DAG.",
            "**default_view**",
            "**description**: User-provided DAG description, which can consist of several sentences or paragraphs that describe DAG contents.",
            "**file_token**: The key containing the encrypted path to the file. Encryption and decryption take place only on the server. This prevents the client from reading an non-DAG file. This also ensures API extensibility, because the format of encrypted data may change.",
            "**fileloc**: The absolute path to the file.",
            "**has_import_errors**: Whether the DAG has import errors",
            "**has_task_concurrency_limits**: Whether the DAG has task concurrency limits",
            "**is_active**: Whether the DAG is currently seen by the scheduler(s).",
            "**is_paused**: Whether the DAG is paused.",
            "**is_subdag**: Whether the DAG is SubDAG.",
            "**last_expired**: Time when the DAG last received a refresh signal",
            "**last_parsed_time**: The last time the DAG was parsed.",
            "**last_pickled**: The last time the DAG was pickled.",
            "**max_active_runs**: Maximum number of active DAG runs for the DAG",
            "**max_active_tasks**: Maximum number of active tasks that can be run on the DAG",
            "**next_dagrun**: The logical date of the next dag run.",
            "**next_dagrun_create_after**: Earliest time at which this ``next_dagrun`` can be created.",
            "**next_dagrun_data_interval_end**: The end of the interval of the next dag run.",
            "**next_dagrun_data_interval_start**: The start of the interval of the next dag run.",
            "**owners**",
            "**pickle_id**: Foreign key to the latest pickle_id",
            "**root_dag_id**: If the DAG is SubDAG then it is the top level DAG identifier. Otherwise, null.",
            "**schedule_interval**: Schedule interval. Defines how often DAG runs, this object gets added to your latest task instance's",
            "**scheduler_lock**: Whether (one of) the scheduler is scheduling this DAG at the moment",
            "**tags**: List of tags.",
            "**timetable_description**: Timetable/Schedule Interval description.",
            "**catchup**",
            "**concurrency**",
            [
              "**dag_run_timeout**: Time delta",
              {
                "$ul": [
                  "**__type**",
                  "**days**",
                  "**microseconds**",
                  "**seconds**"
                ]
              }
            ],
            "**doc_md**",
            "**end_date**: The DAG's end date.",
            "**is_paused_upon_creation**: Whether the DAG is paused upon creation.",
            "**last_parsed**: The last time the DAG was parsed.",
            "**orientation**",
            "**params**: User-specified DAG params.",
            "**render_template_as_native_obj**: Whether to render templates as native Python objects.",
            "**start_date**: The DAG's start date.",
            "**template_search_path**: The template search path.",
            "**timezone**"
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    },
    "401": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "[RFC7807](https://tools.ietf.org/html/rfc7807) compliant response.\n",
        "**Key properties:**",
        {
          "$ul": [
            "**detail**: A human-readable explanation specific to this occurrence of the problem.",
            "**instance**: A URI reference that identifies the specific occurrence of the problem. It may or may",
            "**status**: The HTTP status code generated by the API server for this occurrence of the problem.",
            "**title**: A short, human-readable summary of the problem type.",
            "**type**: A URI reference [RFC3986] that identifies the problem type. This specification"
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    },
    "403": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "[RFC7807](https://tools.ietf.org/html/rfc7807) compliant response.\n",
        "**Key properties:**",
        {
          "$ul": [
            "**detail**: A human-readable explanation specific to this occurrence of the problem.",
            "**instance**: A URI reference that identifies the specific occurrence of the problem. It may or may",
            "**status**: The HTTP status code generated by the API server for this occurrence of the problem.",
            "**title**: A short, human-readable summary of the problem type.",
            "**type**: A URI reference [RFC3986] that identifies the problem type. This specification"
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    },
    "404": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "[RFC7807](https://tools.ietf.org/html/rfc7807) compliant response.\n",
        "**Key properties:**",
        {
          "$ul": [
            "**detail**: A human-readable explanation specific to this occurrence of the problem.",
            "**instance**: A URI reference that identifies the specific occurrence of the problem. It may or may",
            "**status**: The HTTP status code generated by the API server for this occurrence of the problem.",
            "**title**: A short, human-readable summary of the problem type.",
            "**type**: A URI reference [RFC3986] that identifies the problem type. This specification"
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    }
  }
}
