{
  "name": "patch_dag",
  "description": "Update a DAG",
  "parameters": {
    "type": "object",
    "properties": {
      "update_mask": {
        "items": {
          "type": "string"
        },
        "type": "array",
        "description": "The fields to update on the resource. If absent or empty, all modifiable fields are updated.\nA comma-separated list of fully qualified names of fields.\n"
      },
      "dag_id": {
        "type": "string",
        "description": "The DAG ID."
      },
      "body": {
        "$ref": "#/$defs/DAG"
      }
    },
    "required": [
      "dag_id",
      "body"
    ],
    "$defs": {
      "DAG": {
        "description": "DAG",
        "properties": {
          "dag_id": {
            "description": "The ID of the DAG.",
            "readOnly": true,
            "type": "string"
          },
          "default_view": {
            "description": "Default view of the DAG inside the webserver\n\n*New in version 2.3.0*\n",
            "nullable": true,
            "readOnly": true,
            "type": "string"
          },
          "description": {
            "description": "User-provided DAG description, which can consist of several sentences or paragraphs that describe DAG contents.\n",
            "nullable": true,
            "readOnly": true,
            "type": "string"
          },
          "file_token": {
            "description": "The key containing the encrypted path to the file. Encryption and decryption take place only on the server. This prevents the client from reading an non-DAG file. This also ensures API extensibility, because the format of encrypted data may change.\n",
            "readOnly": true,
            "type": "string"
          },
          "fileloc": {
            "description": "The absolute path to the file.",
            "readOnly": true,
            "type": "string"
          },
          "has_import_errors": {
            "description": "Whether the DAG has import errors\n\n*New in version 2.3.0*\n",
            "nullable": true,
            "readOnly": true,
            "type": "boolean"
          },
          "has_task_concurrency_limits": {
            "description": "Whether the DAG has task concurrency limits\n\n*New in version 2.3.0*\n",
            "nullable": true,
            "readOnly": true,
            "type": "boolean"
          },
          "is_active": {
            "description": "Whether the DAG is currently seen by the scheduler(s).\n\n*New in version 2.1.1*\n\n*Changed in version 2.2.0*&#58; Field is read-only.\n",
            "nullable": true,
            "readOnly": true,
            "type": "boolean"
          },
          "is_paused": {
            "description": "Whether the DAG is paused.",
            "nullable": true,
            "type": "boolean"
          },
          "is_subdag": {
            "description": "Whether the DAG is SubDAG.",
            "readOnly": true,
            "type": "boolean"
          },
          "last_expired": {
            "description": "Time when the DAG last received a refresh signal\n(e.g. the DAG's \"refresh\" button was clicked in the web UI)\n\n*New in version 2.3.0*\n",
            "format": "date-time",
            "nullable": true,
            "readOnly": true,
            "type": "string"
          },
          "last_parsed_time": {
            "description": "The last time the DAG was parsed.\n\n*New in version 2.3.0*\n",
            "format": "date-time",
            "nullable": true,
            "readOnly": true,
            "type": "string"
          },
          "last_pickled": {
            "description": "The last time the DAG was pickled.\n\n*New in version 2.3.0*\n",
            "format": "date-time",
            "nullable": true,
            "readOnly": true,
            "type": "string"
          },
          "max_active_runs": {
            "description": "Maximum number of active DAG runs for the DAG\n\n*New in version 2.3.0*\n",
            "nullable": true,
            "readOnly": true,
            "type": "integer"
          },
          "max_active_tasks": {
            "description": "Maximum number of active tasks that can be run on the DAG\n\n*New in version 2.3.0*\n",
            "nullable": true,
            "readOnly": true,
            "type": "integer"
          },
          "next_dagrun": {
            "description": "The logical date of the next dag run.\n\n*New in version 2.3.0*\n",
            "format": "date-time",
            "nullable": true,
            "readOnly": true,
            "type": "string"
          },
          "next_dagrun_create_after": {
            "description": "Earliest time at which this ``next_dagrun`` can be created.\n\n*New in version 2.3.0*\n",
            "format": "date-time",
            "nullable": true,
            "readOnly": true,
            "type": "string"
          },
          "next_dagrun_data_interval_end": {
            "description": "The end of the interval of the next dag run.\n\n*New in version 2.3.0*\n",
            "format": "date-time",
            "nullable": true,
            "readOnly": true,
            "type": "string"
          },
          "next_dagrun_data_interval_start": {
            "description": "The start of the interval of the next dag run.\n\n*New in version 2.3.0*\n",
            "format": "date-time",
            "nullable": true,
            "readOnly": true,
            "type": "string"
          },
          "owners": {
            "items": {
              "type": "string"
            },
            "readOnly": true,
            "type": "array"
          },
          "pickle_id": {
            "description": "Foreign key to the latest pickle_id\n\n*New in version 2.3.0*\n",
            "nullable": true,
            "readOnly": true,
            "type": "string"
          },
          "root_dag_id": {
            "description": "If the DAG is SubDAG then it is the top level DAG identifier. Otherwise, null.",
            "nullable": true,
            "readOnly": true,
            "type": "string"
          },
          "schedule_interval": {
            "$ref": "#/$defs/ScheduleInterval"
          },
          "scheduler_lock": {
            "description": "Whether (one of) the scheduler is scheduling this DAG at the moment\n\n*New in version 2.3.0*\n",
            "nullable": true,
            "readOnly": true,
            "type": "boolean"
          },
          "tags": {
            "description": "List of tags.",
            "items": {
              "$ref": "#/$defs/Tag"
            },
            "nullable": true,
            "readOnly": true,
            "type": "array"
          },
          "timetable_description": {
            "description": "Timetable/Schedule Interval description.\n\n*New in version 2.3.0*\n",
            "nullable": true,
            "readOnly": true,
            "type": "string"
          }
        },
        "type": "object"
      },
      "ScheduleInterval": {
        "anyOf": [
          {
            "$ref": "#/$defs/TimeDelta"
          },
          {
            "$ref": "#/$defs/RelativeDelta"
          },
          {
            "$ref": "#/$defs/CronExpression"
          }
        ],
        "description": "Schedule interval. Defines how often DAG runs, this object gets added to your latest task instance's\nexecution_date to figure out the next schedule.\n",
        "discriminator": {
          "propertyName": "__type"
        },
        "nullable": true,
        "readOnly": true
      },
      "TimeDelta": {
        "description": "Time delta",
        "properties": {
          "__type": {
            "type": "string"
          },
          "days": {
            "type": "integer"
          },
          "microseconds": {
            "type": "integer"
          },
          "seconds": {
            "type": "integer"
          }
        },
        "required": [
          "__type",
          "days",
          "seconds",
          "microseconds"
        ],
        "type": "object"
      },
      "RelativeDelta": {
        "description": "Relative delta",
        "properties": {
          "__type": {
            "type": "string"
          },
          "day": {
            "type": "integer"
          },
          "days": {
            "type": "integer"
          },
          "hour": {
            "type": "integer"
          },
          "hours": {
            "type": "integer"
          },
          "leapdays": {
            "type": "integer"
          },
          "microsecond": {
            "type": "integer"
          },
          "microseconds": {
            "type": "integer"
          },
          "minute": {
            "type": "integer"
          },
          "minutes": {
            "type": "integer"
          },
          "month": {
            "type": "integer"
          },
          "months": {
            "type": "integer"
          },
          "second": {
            "type": "integer"
          },
          "seconds": {
            "type": "integer"
          },
          "year": {
            "type": "integer"
          },
          "years": {
            "type": "integer"
          }
        },
        "required": [
          "__type",
          "years",
          "months",
          "days",
          "leapdays",
          "hours",
          "minutes",
          "seconds",
          "microseconds",
          "year",
          "month",
          "day",
          "hour",
          "minute",
          "second",
          "microsecond"
        ],
        "type": "object"
      },
      "CronExpression": {
        "description": "Cron expression",
        "nullable": true,
        "properties": {
          "__type": {
            "type": "string"
          },
          "value": {
            "type": "string"
          }
        },
        "required": [
          "__type",
          "value"
        ],
        "type": "object"
      },
      "Tag": {
        "description": "Tag",
        "properties": {
          "name": {
            "type": "string"
          }
        },
        "type": "object"
      }
    }
  },
  "handler": "http",
  "request": {
    "method": "PATCH",
    "url": {
      "$uri": "/api/v1/dags/{dag_id}{?update_mask}"
    },
    "body": {
      "$": "body",
      "encode": "json"
    }
  },
  "responses": {
    "200": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "DAG",
        "**Key properties:**",
        {
          "$ul": [
            "**dag_id**: The ID of the DAG.",
            "**default_view**: Default view of the DAG inside the webserver",
            "**description**: User-provided DAG description, which can consist of several sentences or paragraphs that describe DAG contents.",
            "**file_token**: The key containing the encrypted path to the file. Encryption and decryption take place only on the server. This prevents the client from reading an non-DAG file. This also ensures API extensibility, because the format of encrypted data may change.",
            "**fileloc**: The absolute path to the file.",
            "**has_import_errors**: Whether the DAG has import errors",
            "**has_task_concurrency_limits**: Whether the DAG has task concurrency limits",
            "**is_active**: Whether the DAG is currently seen by the scheduler(s).",
            "**is_paused**: Whether the DAG is paused.",
            "**is_subdag**: Whether the DAG is SubDAG.",
            "**last_expired**: Time when the DAG last received a refresh signal",
            "**last_parsed_time**: The last time the DAG was parsed.",
            "**last_pickled**: The last time the DAG was pickled.",
            "**max_active_runs**: Maximum number of active DAG runs for the DAG",
            "**max_active_tasks**: Maximum number of active tasks that can be run on the DAG",
            "**next_dagrun**: The logical date of the next dag run.",
            "**next_dagrun_create_after**: Earliest time at which this ``next_dagrun`` can be created.",
            "**next_dagrun_data_interval_end**: The end of the interval of the next dag run.",
            "**next_dagrun_data_interval_start**: The start of the interval of the next dag run.",
            "**owners**",
            "**pickle_id**: Foreign key to the latest pickle_id",
            "**root_dag_id**: If the DAG is SubDAG then it is the top level DAG identifier. Otherwise, null.",
            "**schedule_interval**: Schedule interval. Defines how often DAG runs, this object gets added to your latest task instance's",
            "**scheduler_lock**: Whether (one of) the scheduler is scheduling this DAG at the moment",
            "**tags**: List of tags.",
            "**timetable_description**: Timetable/Schedule Interval description."
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    },
    "401": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "[RFC7807](https://tools.ietf.org/html/rfc7807) compliant response.\n",
        "**Key properties:**",
        {
          "$ul": [
            "**detail**: A human-readable explanation specific to this occurrence of the problem.",
            "**instance**: A URI reference that identifies the specific occurrence of the problem. It may or may",
            "**status**: The HTTP status code generated by the API server for this occurrence of the problem.",
            "**title**: A short, human-readable summary of the problem type.",
            "**type**: A URI reference [RFC3986] that identifies the problem type. This specification"
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    },
    "403": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "[RFC7807](https://tools.ietf.org/html/rfc7807) compliant response.\n",
        "**Key properties:**",
        {
          "$ul": [
            "**detail**: A human-readable explanation specific to this occurrence of the problem.",
            "**instance**: A URI reference that identifies the specific occurrence of the problem. It may or may",
            "**status**: The HTTP status code generated by the API server for this occurrence of the problem.",
            "**title**: A short, human-readable summary of the problem type.",
            "**type**: A URI reference [RFC3986] that identifies the problem type. This specification"
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    },
    "404": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "[RFC7807](https://tools.ietf.org/html/rfc7807) compliant response.\n",
        "**Key properties:**",
        {
          "$ul": [
            "**detail**: A human-readable explanation specific to this occurrence of the problem.",
            "**instance**: A URI reference that identifies the specific occurrence of the problem. It may or may",
            "**status**: The HTTP status code generated by the API server for this occurrence of the problem.",
            "**title**: A short, human-readable summary of the problem type.",
            "**type**: A URI reference [RFC3986] that identifies the problem type. This specification"
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    }
  }
}
