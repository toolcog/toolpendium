{
  "name": "UpdateFirewallPolicy",
  "description": "Updates the properties of the specified firewall policy.",
  "parameters": {
    "type": "object",
    "properties": {
      "X-Amz-Target": {
        "type": "string",
        "enum": [
          "NetworkFirewall_20201112.UpdateFirewallPolicy"
        ]
      },
      "X-Amz-Content-Sha256": {
        "type": "string"
      },
      "X-Amz-Date": {
        "type": "string"
      },
      "X-Amz-Algorithm": {
        "type": "string"
      },
      "X-Amz-Credential": {
        "type": "string"
      },
      "X-Amz-Security-Token": {
        "type": "string"
      },
      "X-Amz-Signature": {
        "type": "string"
      },
      "X-Amz-SignedHeaders": {
        "type": "string"
      },
      "body": {
        "$ref": "#/$defs/UpdateFirewallPolicyRequest"
      }
    },
    "required": [
      "X-Amz-Target",
      "body"
    ],
    "$defs": {
      "UpdateFirewallPolicyRequest": {
        "type": "object",
        "required": [
          "UpdateToken",
          "FirewallPolicy"
        ],
        "title": "UpdateFirewallPolicyRequest",
        "properties": {
          "UpdateToken": {
            "allOf": [
              {
                "$ref": "#/$defs/UpdateToken"
              },
              {
                "description": "<p>A token used for optimistic locking. Network Firewall returns a token to your requests that access the firewall policy. The token marks the state of the policy resource at the time of the request. </p> <p>To make changes to the policy, you provide the token in your request. Network Firewall uses the token to ensure that the policy hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall policy again to get a current copy of it with current token. Reapply your changes as needed, then try the operation again using the new token. </p>"
              }
            ]
          },
          "FirewallPolicyArn": {
            "allOf": [
              {
                "$ref": "#/$defs/ResourceArn"
              },
              {
                "description": "<p>The Amazon Resource Name (ARN) of the firewall policy.</p> <p>You must specify the ARN or the name, and you can specify both. </p>"
              }
            ]
          },
          "FirewallPolicyName": {
            "allOf": [
              {
                "$ref": "#/$defs/ResourceName"
              },
              {
                "description": "<p>The descriptive name of the firewall policy. You can't change the name of a firewall policy after you create it.</p> <p>You must specify the ARN or the name, and you can specify both. </p>"
              }
            ]
          },
          "FirewallPolicy": {
            "allOf": [
              {
                "$ref": "#/$defs/FirewallPolicy"
              },
              {
                "description": "The updated firewall policy to use for the firewall. "
              }
            ]
          },
          "Description": {
            "allOf": [
              {
                "$ref": "#/$defs/Description"
              },
              {
                "description": "A description of the firewall policy."
              }
            ]
          },
          "DryRun": {
            "allOf": [
              {
                "$ref": "#/$defs/Boolean"
              },
              {
                "description": "<p>Indicates whether you want Network Firewall to just check the validity of the request, rather than run the request. </p> <p>If set to <code>TRUE</code>, Network Firewall checks whether the request can run successfully, but doesn't actually make the requested changes. The call returns the value that the request would return if you ran it with dry run set to <code>FALSE</code>, but doesn't make additions or changes to your resources. This option allows you to make sure that you have the required permissions to run the request and that your request parameters are valid. </p> <p>If set to <code>FALSE</code>, Network Firewall makes the requested changes to your resources. </p>"
              }
            ]
          },
          "EncryptionConfiguration": {
            "allOf": [
              {
                "$ref": "#/$defs/EncryptionConfiguration"
              },
              {
                "description": "A complex type that contains settings for encryption of your firewall policy resources."
              }
            ]
          }
        }
      },
      "UpdateToken": {
        "type": "string",
        "pattern": "^([0-9a-f]{8})-([0-9a-f]{4}-){3}([0-9a-f]{12})$",
        "minLength": 1,
        "maxLength": 1024
      },
      "ResourceArn": {
        "type": "string",
        "pattern": "^arn:aws.*",
        "minLength": 1,
        "maxLength": 256
      },
      "ResourceName": {
        "type": "string",
        "pattern": "^[a-zA-Z0-9-]+$",
        "minLength": 1,
        "maxLength": 128
      },
      "FirewallPolicy": {
        "type": "object",
        "required": [
          "StatelessDefaultActions",
          "StatelessFragmentDefaultActions"
        ],
        "properties": {
          "StatelessRuleGroupReferences": {
            "allOf": [
              {
                "$ref": "#/$defs/StatelessRuleGroupReferences"
              },
              {
                "description": "References to the stateless rule groups that are used in the policy. These define the matching criteria in stateless rules. "
              }
            ]
          },
          "StatelessDefaultActions": {
            "allOf": [
              {
                "$ref": "#/$defs/StatelessActions"
              },
              {
                "description": "<p>The actions to take on a packet if it doesn't match any of the stateless rules in the policy. If you want non-matching packets to be forwarded for stateful inspection, specify <code>aws:forward_to_sfe</code>. </p> <p>You must specify one of the standard actions: <code>aws:pass</code>, <code>aws:drop</code>, or <code>aws:forward_to_sfe</code>. In addition, you can specify custom actions that are compatible with your standard section choice.</p> <p>For example, you could specify <code>[\"aws:pass\"]</code> or you could specify <code>[\"aws:pass\", “customActionName”]</code>. For information about compatibility, see the custom action descriptions under <a>CustomAction</a>.</p>"
              }
            ]
          },
          "StatelessFragmentDefaultActions": {
            "allOf": [
              {
                "$ref": "#/$defs/StatelessActions"
              },
              {
                "description": "<p>The actions to take on a fragmented UDP packet if it doesn't match any of the stateless rules in the policy. Network Firewall only manages UDP packet fragments and silently drops packet fragments for other protocols. If you want non-matching fragmented UDP packets to be forwarded for stateful inspection, specify <code>aws:forward_to_sfe</code>. </p> <p>You must specify one of the standard actions: <code>aws:pass</code>, <code>aws:drop</code>, or <code>aws:forward_to_sfe</code>. In addition, you can specify custom actions that are compatible with your standard section choice.</p> <p>For example, you could specify <code>[\"aws:pass\"]</code> or you could specify <code>[\"aws:pass\", “customActionName”]</code>. For information about compatibility, see the custom action descriptions under <a>CustomAction</a>.</p>"
              }
            ]
          },
          "StatelessCustomActions": {
            "allOf": [
              {
                "$ref": "#/$defs/CustomActions"
              },
              {
                "description": "The custom action definitions that are available for use in the firewall policy's <code>StatelessDefaultActions</code> setting. You name each custom action that you define, and then you can use it by name in your default actions specifications."
              }
            ]
          },
          "StatefulRuleGroupReferences": {
            "allOf": [
              {
                "$ref": "#/$defs/StatefulRuleGroupReferences"
              },
              {
                "description": "References to the stateful rule groups that are used in the policy. These define the inspection criteria in stateful rules. "
              }
            ]
          },
          "StatefulDefaultActions": {
            "allOf": [
              {
                "$ref": "#/$defs/StatefulActions"
              },
              {
                "description": "<p>The default actions to take on a packet that doesn't match any stateful rules. The stateful default action is optional, and is only valid when using the strict rule order.</p> <p>Valid values of the stateful default action:</p> <ul> <li> <p>aws:drop_strict</p> </li> <li> <p>aws:drop_established</p> </li> <li> <p>aws:alert_strict</p> </li> <li> <p>aws:alert_established</p> </li> </ul> <p>For more information, see <a href=\"https://docs.aws.amazon.com/network-firewall/latest/developerguide/suricata-rule-evaluation-order.html#suricata-strict-rule-evaluation-order.html\">Strict evaluation order</a> in the <i>Network Firewall Developer Guide</i>. </p>"
              }
            ]
          },
          "StatefulEngineOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/StatefulEngineOptions"
              },
              {
                "description": "Additional options governing how Network Firewall handles stateful rules. The stateful rule groups that you use in your policy must have stateful rule options settings that are compatible with these settings."
              }
            ]
          },
          "TLSInspectionConfigurationArn": {
            "allOf": [
              {
                "$ref": "#/$defs/ResourceArn"
              },
              {
                "description": "The Amazon Resource Name (ARN) of the TLS inspection configuration."
              }
            ]
          },
          "PolicyVariables": {
            "allOf": [
              {
                "$ref": "#/$defs/PolicyVariables"
              },
              {
                "description": "Contains variables that you can use to override default Suricata settings in your firewall policy."
              }
            ]
          }
        },
        "description": "<p>The firewall policy defines the behavior of a firewall using a collection of stateless and stateful rule groups and other settings. You can use one firewall policy for multiple firewalls. </p> <p>This, along with <a>FirewallPolicyResponse</a>, define the policy. You can retrieve all objects for a firewall policy by calling <a>DescribeFirewallPolicy</a>.</p>"
      },
      "StatelessRuleGroupReferences": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/StatelessRuleGroupReference"
        }
      },
      "StatelessRuleGroupReference": {
        "type": "object",
        "required": [
          "ResourceArn",
          "Priority"
        ],
        "properties": {
          "ResourceArn": {
            "allOf": [
              {
                "$ref": "#/$defs/ResourceArn"
              },
              {
                "description": "The Amazon Resource Name (ARN) of the stateless rule group."
              }
            ]
          },
          "Priority": {
            "allOf": [
              {
                "$ref": "#/$defs/Priority"
              },
              {
                "description": "An integer setting that indicates the order in which to run the stateless rule groups in a single <a>FirewallPolicy</a>. Network Firewall applies each stateless rule group to a packet starting with the group that has the lowest priority setting. You must ensure that the priority settings are unique within each policy."
              }
            ]
          }
        },
        "description": "Identifier for a single stateless rule group, used in a firewall policy to refer to the rule group. "
      },
      "Priority": {
        "type": "integer",
        "minimum": 1,
        "maximum": 65535
      },
      "StatelessActions": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/CollectionMember_String"
        }
      },
      "CollectionMember_String": {
        "type": "string"
      },
      "CustomActions": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/CustomAction"
        }
      },
      "CustomAction": {
        "type": "object",
        "required": [
          "ActionName",
          "ActionDefinition"
        ],
        "properties": {
          "ActionName": {
            "allOf": [
              {
                "$ref": "#/$defs/ActionName"
              },
              {
                "description": "The descriptive name of the custom action. You can't change the name of a custom action after you create it."
              }
            ]
          },
          "ActionDefinition": {
            "allOf": [
              {
                "$ref": "#/$defs/ActionDefinition"
              },
              {
                "description": "The custom action associated with the action name."
              }
            ]
          }
        },
        "description": "<p>An optional, non-standard action to use for stateless packet handling. You can define this in addition to the standard action that you must specify. </p> <p>You define and name the custom actions that you want to be able to use, and then you reference them by name in your actions settings. </p> <p>You can use custom actions in the following places: </p> <ul> <li> <p>In a rule group's <a>StatelessRulesAndCustomActions</a> specification. The custom actions are available for use by name inside the <code>StatelessRulesAndCustomActions</code> where you define them. You can use them for your stateless rule actions to specify what to do with a packet that matches the rule's match attributes. </p> </li> <li> <p>In a <a>FirewallPolicy</a> specification, in <code>StatelessCustomActions</code>. The custom actions are available for use inside the policy where you define them. You can use them for the policy's default stateless actions settings to specify what to do with packets that don't match any of the policy's stateless rules. </p> </li> </ul>"
      },
      "ActionName": {
        "type": "string",
        "pattern": "^[a-zA-Z0-9]+$",
        "minLength": 1,
        "maxLength": 128
      },
      "ActionDefinition": {
        "type": "object",
        "properties": {
          "PublishMetricAction": {
            "allOf": [
              {
                "$ref": "#/$defs/PublishMetricAction"
              },
              {
                "description": "<p>Stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. This setting defines a CloudWatch dimension value to be published.</p> <p>You can pair this custom action with any of the standard stateless rule actions. For example, you could pair this in a rule action with the standard action that forwards the packet for stateful inspection. Then, when a packet matches the rule, Network Firewall publishes metrics for the packet and forwards it. </p>"
              }
            ]
          }
        },
        "description": "A custom action to use in stateless rule actions settings. This is used in <a>CustomAction</a>."
      },
      "PublishMetricAction": {
        "type": "object",
        "required": [
          "Dimensions"
        ],
        "properties": {
          "Dimensions": {
            "allOf": [
              {
                "$ref": "#/$defs/Dimensions"
              },
              {
                "description": "<p/>"
              }
            ]
          }
        },
        "description": "Stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. This setting defines a CloudWatch dimension value to be published."
      },
      "Dimensions": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/Dimension"
        },
        "minItems": 1,
        "maxItems": 1
      },
      "Dimension": {
        "type": "object",
        "required": [
          "Value"
        ],
        "properties": {
          "Value": {
            "allOf": [
              {
                "$ref": "#/$defs/DimensionValue"
              },
              {
                "description": "The value to use in the custom metric dimension."
              }
            ]
          }
        },
        "description": "<p>The value to use in an Amazon CloudWatch custom metric dimension. This is used in the <code>PublishMetrics</code> <a>CustomAction</a>. A CloudWatch custom metric dimension is a name/value pair that's part of the identity of a metric. </p> <p>Network Firewall sets the dimension name to <code>CustomAction</code> and you provide the dimension value. </p> <p>For more information about CloudWatch custom metric dimensions, see <a href=\"https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/publishingMetrics.html#usingDimensions\">Publishing Custom Metrics</a> in the <a href=\"https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html\">Amazon CloudWatch User Guide</a>.</p>"
      },
      "DimensionValue": {
        "type": "string",
        "pattern": "^[a-zA-Z0-9-_ ]+$",
        "minLength": 1,
        "maxLength": 128
      },
      "StatefulRuleGroupReferences": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/StatefulRuleGroupReference"
        }
      },
      "StatefulRuleGroupReference": {
        "type": "object",
        "required": [
          "ResourceArn"
        ],
        "properties": {
          "ResourceArn": {
            "allOf": [
              {
                "$ref": "#/$defs/ResourceArn"
              },
              {
                "description": "The Amazon Resource Name (ARN) of the stateful rule group."
              }
            ]
          },
          "Priority": {
            "allOf": [
              {
                "$ref": "#/$defs/Priority"
              },
              {
                "description": "<p>An integer setting that indicates the order in which to run the stateful rule groups in a single <a>FirewallPolicy</a>. This setting only applies to firewall policies that specify the <code>STRICT_ORDER</code> rule order in the stateful engine options settings.</p> <p>Network Firewall evalutes each stateful rule group against a packet starting with the group that has the lowest priority setting. You must ensure that the priority settings are unique within each policy.</p> <p>You can change the priority settings of your rule groups at any time. To make it easier to insert rule groups later, number them so there's a wide range in between, for example use 100, 200, and so on. </p>"
              }
            ]
          },
          "Override": {
            "allOf": [
              {
                "$ref": "#/$defs/StatefulRuleGroupOverride"
              },
              {
                "description": "The action that allows the policy owner to override the behavior of the rule group within a policy."
              }
            ]
          }
        },
        "description": "Identifier for a single stateful rule group, used in a firewall policy to refer to a rule group. "
      },
      "StatefulRuleGroupOverride": {
        "type": "object",
        "properties": {
          "Action": {
            "allOf": [
              {
                "$ref": "#/$defs/OverrideAction"
              },
              {
                "description": "The action that changes the rule group from <code>DROP</code> to <code>ALERT</code>. This only applies to managed rule groups."
              }
            ]
          }
        },
        "description": "The setting that allows the policy owner to change the behavior of the rule group within a policy. "
      },
      "OverrideAction": {
        "type": "string",
        "enum": [
          "DROP_TO_ALERT"
        ]
      },
      "StatefulActions": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/CollectionMember_String"
        }
      },
      "StatefulEngineOptions": {
        "type": "object",
        "properties": {
          "RuleOrder": {
            "allOf": [
              {
                "$ref": "#/$defs/RuleOrder"
              },
              {
                "description": "Indicates how to manage the order of stateful rule evaluation for the policy. <code>DEFAULT_ACTION_ORDER</code> is the default behavior. Stateful rules are provided to the rule engine as Suricata compatible strings, and Suricata evaluates them based on certain settings. For more information, see <a href=\"https://docs.aws.amazon.com/network-firewall/latest/developerguide/suricata-rule-evaluation-order.html\">Evaluation order for stateful rules</a> in the <i>Network Firewall Developer Guide</i>. "
              }
            ]
          },
          "StreamExceptionPolicy": {
            "allOf": [
              {
                "$ref": "#/$defs/StreamExceptionPolicy"
              },
              {
                "description": "<p>Configures how Network Firewall processes traffic when a network connection breaks midstream. Network connections can break due to disruptions in external networks or within the firewall itself.</p> <ul> <li> <p> <code>DROP</code> - Network Firewall fails closed and drops all subsequent traffic going to the firewall. This is the default behavior.</p> </li> <li> <p> <code>CONTINUE</code> - Network Firewall continues to apply rules to the subsequent traffic without context from traffic before the break. This impacts the behavior of rules that depend on this context. For example, if you have a stateful rule to <code>drop http</code> traffic, Network Firewall won't match the traffic for this rule because the service won't have the context from session initialization defining the application layer protocol as HTTP. However, this behavior is rule dependent—a TCP-layer rule using a <code>flow:stateless</code> rule would still match, as would the <code>aws:drop_strict</code> default action.</p> </li> <li> <p> <code>REJECT</code> - Network Firewall fails closed and drops all subsequent traffic going to the firewall. Network Firewall also sends a TCP reject packet back to your client so that the client can immediately establish a new session. Network Firewall will have context about the new session and will apply rules to the subsequent traffic.</p> </li> </ul>"
              }
            ]
          }
        },
        "description": "Configuration settings for the handling of the stateful rule groups in a firewall policy. "
      },
      "RuleOrder": {
        "type": "string",
        "enum": [
          "DEFAULT_ACTION_ORDER",
          "STRICT_ORDER"
        ]
      },
      "StreamExceptionPolicy": {
        "type": "string",
        "enum": [
          "DROP",
          "CONTINUE",
          "REJECT"
        ]
      },
      "PolicyVariables": {
        "type": "object",
        "properties": {
          "RuleVariables": {
            "allOf": [
              {
                "$ref": "#/$defs/IPSets"
              },
              {
                "description": "The IPv4 or IPv6 addresses in CIDR notation to use for the Suricata <code>HOME_NET</code> variable. If your firewall uses an inspection VPC, you might want to override the <code>HOME_NET</code> variable with the CIDRs of your home networks. If you don't override <code>HOME_NET</code> with your own CIDRs, Network Firewall by default uses the CIDR of your inspection VPC."
              }
            ]
          }
        },
        "description": "Contains variables that you can use to override default Suricata settings in your firewall policy."
      },
      "IPSets": {
        "type": "object",
        "additionalProperties": {
          "$ref": "#/$defs/IPSet"
        }
      },
      "IPSet": {
        "type": "object",
        "required": [
          "Definition"
        ],
        "properties": {
          "Definition": {
            "allOf": [
              {
                "$ref": "#/$defs/VariableDefinitionList"
              },
              {
                "description": "The list of IP addresses and address ranges, in CIDR notation. "
              }
            ]
          }
        },
        "description": "A list of IP addresses and address ranges, in CIDR notation. This is part of a <a>RuleVariables</a>. "
      },
      "VariableDefinitionList": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/VariableDefinition"
        }
      },
      "VariableDefinition": {
        "type": "string",
        "pattern": "^.*$",
        "minLength": 1
      },
      "Description": {
        "type": "string",
        "pattern": "^.*$",
        "maxLength": 512
      },
      "Boolean": {
        "type": "boolean"
      },
      "EncryptionConfiguration": {
        "type": "object",
        "required": [
          "Type"
        ],
        "properties": {
          "KeyId": {
            "allOf": [
              {
                "$ref": "#/$defs/KeyId"
              },
              {
                "description": "The ID of the Amazon Web Services Key Management Service (KMS) customer managed key. You can use any of the key identifiers that KMS supports, unless you're using a key that's managed by another account. If you're using a key managed by another account, then specify the key ARN. For more information, see <a href=\"https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id\">Key ID</a> in the <i>Amazon Web Services KMS Developer Guide</i>."
              }
            ]
          },
          "Type": {
            "allOf": [
              {
                "$ref": "#/$defs/EncryptionType"
              },
              {
                "description": "The type of Amazon Web Services KMS key to use for encryption of your Network Firewall resources."
              }
            ]
          }
        },
        "description": "A complex type that contains optional Amazon Web Services Key Management Service (KMS) encryption settings for your Network Firewall resources. Your data is encrypted by default with an Amazon Web Services owned key that Amazon Web Services owns and manages for you. You can use either the Amazon Web Services owned key, or provide your own customer managed key. To learn more about KMS encryption of your Network Firewall resources, see <a href=\"https://docs.aws.amazon.com/kms/latest/developerguide/kms-encryption-at-rest.html\">Encryption at rest with Amazon Web Services Key Managment Service</a> in the <i>Network Firewall Developer Guide</i>."
      },
      "KeyId": {
        "type": "string",
        "pattern": ".*\\S.*",
        "minLength": 1,
        "maxLength": 2048
      },
      "EncryptionType": {
        "type": "string",
        "enum": [
          "CUSTOMER_KMS",
          "AWS_OWNED_KMS_KEY"
        ]
      }
    }
  },
  "handler": "http",
  "request": {
    "method": "POST",
    "url": {
      "$uri": "http://network-firewall.us-east-1.amazonaws.com/#X-Amz-Target=NetworkFirewall_20201112.UpdateFirewallPolicy"
    },
    "headers": {
      "X-Amz-Target": {
        "$": "X-Amz-Target"
      },
      "X-Amz-Content-Sha256": {
        "$": "X-Amz-Content-Sha256"
      },
      "X-Amz-Date": {
        "$": "X-Amz-Date"
      },
      "X-Amz-Algorithm": {
        "$": "X-Amz-Algorithm"
      },
      "X-Amz-Credential": {
        "$": "X-Amz-Credential"
      },
      "X-Amz-Security-Token": {
        "$": "X-Amz-Security-Token"
      },
      "X-Amz-Signature": {
        "$": "X-Amz-Signature"
      },
      "X-Amz-SignedHeaders": {
        "$": "X-Amz-SignedHeaders"
      }
    },
    "body": {
      "$": "body",
      "encode": "json"
    }
  },
  "responses": {
    "200": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "**Key properties:**",
        {
          "$ul": [
            "**UpdateToken**",
            "**FirewallPolicyResponse**"
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    },
    "480": {
      "$encode": "markdown",
      "$lang": "json",
      "$code": {
        "$encode": "json",
        "$indent": true,
        "$content": {
          "$": "$.body"
        }
      }
    },
    "481": {
      "$encode": "markdown",
      "$lang": "json",
      "$code": {
        "$encode": "json",
        "$indent": true,
        "$content": {
          "$": "$.body"
        }
      }
    },
    "482": {
      "$encode": "markdown",
      "$lang": "json",
      "$code": {
        "$encode": "json",
        "$indent": true,
        "$content": {
          "$": "$.body"
        }
      }
    },
    "483": {
      "$encode": "markdown",
      "$lang": "json",
      "$code": {
        "$encode": "json",
        "$indent": true,
        "$content": {
          "$": "$.body"
        }
      }
    },
    "484": {
      "$encode": "markdown",
      "$lang": "json",
      "$code": {
        "$encode": "json",
        "$indent": true,
        "$content": {
          "$": "$.body"
        }
      }
    }
  }
}
