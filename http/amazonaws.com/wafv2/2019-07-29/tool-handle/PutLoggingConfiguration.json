{
  "name": "PutLoggingConfiguration",
  "description": "<p>Enables the specified <a>LoggingConfiguration</a>, to start logging from a web ACL, according to the configuration provided. </p> <note> <p>This operation completely replaces any mutable specifications that you already have for a logging configuration with the ones that you provide to this call. </p> <p>To modify an existing logging configuration, do the following: </p> <ol> <li> <p>Retrieve it by calling <a>GetLoggingConfiguration</a> </p> </li> <li> <p>Update its settings as needed</p> </li> <li> <p>Provide the complete logging configuration specification to this call</p> </li> </ol> </note> <note> <p>You can define one logging destination per web ACL.</p> </note> <p>You can access information about the traffic that WAF inspects using the following steps:</p> <ol> <li> <p>Create your logging destination. You can use an Amazon CloudWatch Logs log group, an Amazon Simple Storage Service (Amazon S3) bucket, or an Amazon Kinesis Data Firehose. </p> <p>The name that you give the destination must start with <code>aws-waf-logs-</code>. Depending on the type of destination, you might need to configure additional settings or permissions. </p> <p>For configuration requirements and pricing information for each destination type, see <a href=\"https://docs.aws.amazon.com/waf/latest/developerguide/logging.html\">Logging web ACL traffic</a> in the <i>WAF Developer Guide</i>.</p> </li> <li> <p>Associate your logging destination to your web ACL using a <code>PutLoggingConfiguration</code> request.</p> </li> </ol> <p>When you successfully enable logging using a <code>PutLoggingConfiguration</code> request, WAF creates an additional role or policy that is required to write logs to the logging destination. For an Amazon CloudWatch Logs log group, WAF creates a resource policy on the log group. For an Amazon S3 bucket, WAF creates a bucket policy. For an Amazon Kinesis Data Firehose, WAF creates a service-linked role.</p> <p>For additional information about web ACL logging, see <a href=\"https://docs.aws.amazon.com/waf/latest/developerguide/logging.html\">Logging web ACL traffic information</a> in the <i>WAF Developer Guide</i>.</p>",
  "parameters": {
    "type": "object",
    "properties": {
      "X-Amz-Target": {
        "type": "string",
        "enum": [
          "AWSWAF_20190729.PutLoggingConfiguration"
        ]
      },
      "X-Amz-Content-Sha256": {
        "type": "string"
      },
      "X-Amz-Date": {
        "type": "string"
      },
      "X-Amz-Algorithm": {
        "type": "string"
      },
      "X-Amz-Credential": {
        "type": "string"
      },
      "X-Amz-Security-Token": {
        "type": "string"
      },
      "X-Amz-Signature": {
        "type": "string"
      },
      "X-Amz-SignedHeaders": {
        "type": "string"
      },
      "body": {
        "$ref": "#/$defs/PutLoggingConfigurationRequest"
      }
    },
    "required": [
      "X-Amz-Target",
      "body"
    ],
    "$defs": {
      "PutLoggingConfigurationRequest": {
        "type": "object",
        "required": [
          "LoggingConfiguration"
        ],
        "title": "PutLoggingConfigurationRequest",
        "properties": {
          "LoggingConfiguration": {
            "allOf": [
              {
                "$ref": "#/$defs/LoggingConfiguration"
              },
              {
                "description": "<p/>"
              }
            ]
          }
        }
      },
      "LoggingConfiguration": {
        "type": "object",
        "required": [
          "ResourceArn",
          "LogDestinationConfigs"
        ],
        "properties": {
          "ResourceArn": {
            "allOf": [
              {
                "$ref": "#/$defs/ResourceArn"
              },
              {
                "description": "The Amazon Resource Name (ARN) of the web ACL that you want to associate with <code>LogDestinationConfigs</code>."
              }
            ]
          },
          "LogDestinationConfigs": {
            "allOf": [
              {
                "$ref": "#/$defs/LogDestinationConfigs"
              },
              {
                "description": "<p>The logging destination configuration that you want to associate with the web ACL.</p> <note> <p>You can associate one logging destination to a web ACL.</p> </note>"
              }
            ]
          },
          "RedactedFields": {
            "allOf": [
              {
                "$ref": "#/$defs/RedactedFields"
              },
              {
                "description": "<p>The parts of the request that you want to keep out of the logs.</p> <p>For example, if you redact the <code>SingleHeader</code> field, the <code>HEADER</code> field in the logs will be <code>REDACTED</code> for all rules that use the <code>SingleHeader</code> <code>FieldToMatch</code> setting. </p> <p>Redaction applies only to the component that's specified in the rule's <code>FieldToMatch</code> setting, so the <code>SingleHeader</code> redaction doesn't apply to rules that use the <code>Headers</code> <code>FieldToMatch</code>.</p> <note> <p>You can specify only the following fields for redaction: <code>UriPath</code>, <code>QueryString</code>, <code>SingleHeader</code>, and <code>Method</code>.</p> </note>"
              }
            ]
          },
          "ManagedByFirewallManager": {
            "allOf": [
              {
                "$ref": "#/$defs/Boolean"
              },
              {
                "description": "Indicates whether the logging configuration was created by Firewall Manager, as part of an WAF policy configuration. If true, only Firewall Manager can modify or delete the configuration. "
              }
            ]
          },
          "LoggingFilter": {
            "allOf": [
              {
                "$ref": "#/$defs/LoggingFilter"
              },
              {
                "description": "Filtering that specifies which web requests are kept in the logs and which are dropped. You can filter on the rule action and on the web request labels that were applied by matching rules during web ACL evaluation. "
              }
            ]
          }
        },
        "description": "<p>Defines an association between logging destinations and a web ACL resource, for logging from WAF. As part of the association, you can specify parts of the standard logging fields to keep out of the logs and you can specify filters so that you log only a subset of the logging records. </p> <note> <p>You can define one logging destination per web ACL.</p> </note> <p>You can access information about the traffic that WAF inspects using the following steps:</p> <ol> <li> <p>Create your logging destination. You can use an Amazon CloudWatch Logs log group, an Amazon Simple Storage Service (Amazon S3) bucket, or an Amazon Kinesis Data Firehose. </p> <p>The name that you give the destination must start with <code>aws-waf-logs-</code>. Depending on the type of destination, you might need to configure additional settings or permissions. </p> <p>For configuration requirements and pricing information for each destination type, see <a href=\"https://docs.aws.amazon.com/waf/latest/developerguide/logging.html\">Logging web ACL traffic</a> in the <i>WAF Developer Guide</i>.</p> </li> <li> <p>Associate your logging destination to your web ACL using a <code>PutLoggingConfiguration</code> request.</p> </li> </ol> <p>When you successfully enable logging using a <code>PutLoggingConfiguration</code> request, WAF creates an additional role or policy that is required to write logs to the logging destination. For an Amazon CloudWatch Logs log group, WAF creates a resource policy on the log group. For an Amazon S3 bucket, WAF creates a bucket policy. For an Amazon Kinesis Data Firehose, WAF creates a service-linked role.</p> <p>For additional information about web ACL logging, see <a href=\"https://docs.aws.amazon.com/waf/latest/developerguide/logging.html\">Logging web ACL traffic information</a> in the <i>WAF Developer Guide</i>.</p>"
      },
      "ResourceArn": {
        "type": "string",
        "pattern": ".*\\S.*",
        "minLength": 20,
        "maxLength": 2048
      },
      "LogDestinationConfigs": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/ResourceArn"
        },
        "minItems": 1,
        "maxItems": 100
      },
      "RedactedFields": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/FieldToMatch"
        },
        "maxItems": 100
      },
      "FieldToMatch": {
        "type": "object",
        "properties": {
          "SingleHeader": {
            "allOf": [
              {
                "$ref": "#/$defs/SingleHeader"
              },
              {
                "description": "<p>Inspect a single header. Provide the name of the header to inspect, for example, <code>User-Agent</code> or <code>Referer</code>. This setting isn't case sensitive.</p> <p>Example JSON: <code>\"SingleHeader\": { \"Name\": \"haystack\" }</code> </p> <p>Alternately, you can filter and inspect all headers with the <code>Headers</code> <code>FieldToMatch</code> setting. </p>"
              }
            ]
          },
          "SingleQueryArgument": {
            "allOf": [
              {
                "$ref": "#/$defs/SingleQueryArgument"
              },
              {
                "description": "<p>Inspect a single query argument. Provide the name of the query argument to inspect, such as <i>UserName</i> or <i>SalesRegion</i>. The name can be up to 30 characters long and isn't case sensitive. </p> <p>Example JSON: <code>\"SingleQueryArgument\": { \"Name\": \"myArgument\" }</code> </p>"
              }
            ]
          },
          "AllQueryArguments": {
            "allOf": [
              {
                "$ref": "#/$defs/AllQueryArguments"
              },
              {
                "description": "Inspect all query arguments. "
              }
            ]
          },
          "UriPath": {
            "allOf": [
              {
                "$ref": "#/$defs/UriPath"
              },
              {
                "description": "Inspect the request URI path. This is the part of the web request that identifies a resource, for example, <code>/images/daily-ad.jpg</code>."
              }
            ]
          },
          "QueryString": {
            "allOf": [
              {
                "$ref": "#/$defs/QueryString"
              },
              {
                "description": "Inspect the query string. This is the part of a URL that appears after a <code>?</code> character, if any."
              }
            ]
          },
          "Body": {
            "allOf": [
              {
                "$ref": "#/$defs/Body"
              },
              {
                "description": "<p>Inspect the request body as plain text. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. </p> <p>A limited amount of the request body is forwarded to WAF for inspection by the underlying host service. For regional resources, the limit is 8 KB (8,192 kilobytes) and for CloudFront distributions, the limit is 16 KB (16,384 kilobytes). For CloudFront distributions, you can increase the limit in the web ACL's <code>AssociationConfig</code>, for additional processing fees. </p> <p>For information about how to handle oversized request bodies, see the <code>Body</code> object configuration. </p>"
              }
            ]
          },
          "Method": {
            "allOf": [
              {
                "$ref": "#/$defs/Method"
              },
              {
                "description": "Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform. "
              }
            ]
          },
          "JsonBody": {
            "allOf": [
              {
                "$ref": "#/$defs/JsonBody"
              },
              {
                "description": "<p>Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. </p> <p>A limited amount of the request body is forwarded to WAF for inspection by the underlying host service. For regional resources, the limit is 8 KB (8,192 kilobytes) and for CloudFront distributions, the limit is 16 KB (16,384 kilobytes). For CloudFront distributions, you can increase the limit in the web ACL's <code>AssociationConfig</code>, for additional processing fees. </p> <p>For information about how to handle oversized request bodies, see the <code>JsonBody</code> object configuration. </p>"
              }
            ]
          },
          "Headers": {
            "allOf": [
              {
                "$ref": "#/$defs/Headers"
              },
              {
                "description": "<p>Inspect the request headers. You must configure scope and pattern matching filters in the <code>Headers</code> object, to define the set of headers to and the parts of the headers that WAF inspects. </p> <p>Only the first 8 KB (8192 bytes) of a request's headers and only the first 200 headers are forwarded to WAF for inspection by the underlying host service. You must configure how to handle any oversize header content in the <code>Headers</code> object. WAF applies the pattern matching filters to the headers that it receives from the underlying host service. </p>"
              }
            ]
          },
          "Cookies": {
            "allOf": [
              {
                "$ref": "#/$defs/Cookies"
              },
              {
                "description": "<p>Inspect the request cookies. You must configure scope and pattern matching filters in the <code>Cookies</code> object, to define the set of cookies and the parts of the cookies that WAF inspects. </p> <p>Only the first 8 KB (8192 bytes) of a request's cookies and only the first 200 cookies are forwarded to WAF for inspection by the underlying host service. You must configure how to handle any oversize cookie content in the <code>Cookies</code> object. WAF applies the pattern matching filters to the cookies that it receives from the underlying host service. </p>"
              }
            ]
          },
          "HeaderOrder": {
            "allOf": [
              {
                "$ref": "#/$defs/HeaderOrder"
              },
              {
                "description": "Inspect a string containing the list of the request's header names, ordered as they appear in the web request that WAF receives for inspection. WAF generates the string and then uses that as the field to match component in its inspection. WAF separates the header names in the string using colons and no added spaces, for example <code>host:user-agent:accept:authorization:referer</code>."
              }
            ]
          }
        },
        "description": "<p>The part of the web request that you want WAF to inspect. Include the single <code>FieldToMatch</code> type that you want to inspect, with additional specifications as needed, according to the type. You specify a single request component in <code>FieldToMatch</code> for each rule statement that requires it. To inspect more than one component of the web request, create a separate rule statement for each component.</p> <p>Example JSON for a <code>QueryString</code> field to match: </p> <p> <code> \"FieldToMatch\": { \"QueryString\": {} }</code> </p> <p>Example JSON for a <code>Method</code> field to match specification:</p> <p> <code> \"FieldToMatch\": { \"Method\": { \"Name\": \"DELETE\" } }</code> </p>"
      },
      "SingleHeader": {
        "type": "object",
        "required": [
          "Name"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/FieldToMatchData"
              },
              {
                "description": "The name of the query header to inspect."
              }
            ]
          }
        },
        "description": "<p>Inspect one of the headers in the web request, identified by name, for example, <code>User-Agent</code> or <code>Referer</code>. The name isn't case sensitive.</p> <p>You can filter and inspect all headers with the <code>FieldToMatch</code> setting <code>Headers</code>.</p> <p>This is used to indicate the web request component to inspect, in the <a>FieldToMatch</a> specification. </p> <p>Example JSON: <code>\"SingleHeader\": { \"Name\": \"haystack\" }</code> </p>"
      },
      "FieldToMatchData": {
        "type": "string",
        "pattern": ".*\\S.*",
        "minLength": 1,
        "maxLength": 64
      },
      "SingleQueryArgument": {
        "type": "object",
        "required": [
          "Name"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/FieldToMatchData"
              },
              {
                "description": "The name of the query argument to inspect."
              }
            ]
          }
        },
        "description": "<p>Inspect one query argument in the web request, identified by name, for example <i>UserName</i> or <i>SalesRegion</i>. The name isn't case sensitive. </p> <p>This is used to indicate the web request component to inspect, in the <a>FieldToMatch</a> specification. </p> <p>Example JSON: <code>\"SingleQueryArgument\": { \"Name\": \"myArgument\" }</code> </p>"
      },
      "AllQueryArguments": {
        "type": "object",
        "properties": {},
        "description": "<p>Inspect all query arguments of the web request. </p> <p>This is used in the <a>FieldToMatch</a> specification for some web request component types. </p> <p>JSON specification: <code>\"AllQueryArguments\": {}</code> </p>"
      },
      "UriPath": {
        "type": "object",
        "properties": {},
        "description": "<p>Inspect the path component of the URI of the web request. This is the part of the web request that identifies a resource. For example, <code>/images/daily-ad.jpg</code>.</p> <p>This is used in the <a>FieldToMatch</a> specification for some web request component types. </p> <p>JSON specification: <code>\"UriPath\": {}</code> </p>"
      },
      "QueryString": {
        "type": "object",
        "properties": {},
        "description": "<p>Inspect the query string of the web request. This is the part of a URL that appears after a <code>?</code> character, if any.</p> <p>This is used in the <a>FieldToMatch</a> specification for some web request component types. </p> <p>JSON specification: <code>\"QueryString\": {}</code> </p>"
      },
      "Body": {
        "type": "object",
        "properties": {
          "OversizeHandling": {
            "allOf": [
              {
                "$ref": "#/$defs/OversizeHandling"
              },
              {
                "description": "<p>What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. If the body is larger than the limit, the underlying host service only forwards the contents that are below the limit to WAF for inspection. </p> <p>The default limit is 8 KB (8,192 kilobytes) for regional resources and 16 KB (16,384 kilobytes) for CloudFront distributions. For CloudFront distributions, you can increase the limit in the web ACL <code>AssociationConfig</code>, for additional processing fees. </p> <p>The options for oversize handling are the following:</p> <ul> <li> <p> <code>CONTINUE</code> - Inspect the available body contents normally, according to the rule inspection criteria. </p> </li> <li> <p> <code>MATCH</code> - Treat the web request as matching the rule statement. WAF applies the rule action to the request.</p> </li> <li> <p> <code>NO_MATCH</code> - Treat the web request as not matching the rule statement.</p> </li> </ul> <p>You can combine the <code>MATCH</code> or <code>NO_MATCH</code> settings for oversize handling with your rule and web ACL action settings, so that you block any request whose body is over the limit. </p> <p>Default: <code>CONTINUE</code> </p>"
              }
            ]
          }
        },
        "description": "<p>Inspect the body of the web request. The body immediately follows the request headers.</p> <p>This is used to indicate the web request component to inspect, in the <a>FieldToMatch</a> specification. </p>"
      },
      "OversizeHandling": {
        "type": "string",
        "enum": [
          "CONTINUE",
          "MATCH",
          "NO_MATCH"
        ]
      },
      "Method": {
        "type": "object",
        "properties": {},
        "description": "<p>Inspect the HTTP method of the web request. The method indicates the type of operation that the request is asking the origin to perform. </p> <p>This is used in the <a>FieldToMatch</a> specification for some web request component types. </p> <p>JSON specification: <code>\"Method\": {}</code> </p>"
      },
      "JsonBody": {
        "type": "object",
        "required": [
          "MatchPattern",
          "MatchScope"
        ],
        "properties": {
          "MatchPattern": {
            "allOf": [
              {
                "$ref": "#/$defs/JsonMatchPattern"
              },
              {
                "description": "The patterns to look for in the JSON body. WAF inspects the results of these pattern matches against the rule inspection criteria. "
              }
            ]
          },
          "MatchScope": {
            "allOf": [
              {
                "$ref": "#/$defs/JsonMatchScope"
              },
              {
                "description": "The parts of the JSON to match against using the <code>MatchPattern</code>. If you specify <code>All</code>, WAF matches against keys and values. "
              }
            ]
          },
          "InvalidFallbackBehavior": {
            "allOf": [
              {
                "$ref": "#/$defs/BodyParsingFallbackBehavior"
              },
              {
                "description": "<p>What WAF should do if it fails to completely parse the JSON body. The options are the following:</p> <ul> <li> <p> <code>EVALUATE_AS_STRING</code> - Inspect the body as plain text. WAF applies the text transformations and inspection criteria that you defined for the JSON inspection to the body text string.</p> </li> <li> <p> <code>MATCH</code> - Treat the web request as matching the rule statement. WAF applies the rule action to the request.</p> </li> <li> <p> <code>NO_MATCH</code> - Treat the web request as not matching the rule statement.</p> </li> </ul> <p>If you don't provide this setting, WAF parses and evaluates the content only up to the first parsing failure that it encounters. </p> <p>WAF does its best to parse the entire JSON body, but might be forced to stop for reasons such as invalid characters, duplicate keys, truncation, and any content whose root node isn't an object or an array. </p> <p>WAF parses the JSON in the following examples as two valid key, value pairs: </p> <ul> <li> <p>Missing comma: <code>{\"key1\":\"value1\"\"key2\":\"value2\"}</code> </p> </li> <li> <p>Missing colon: <code>{\"key1\":\"value1\",\"key2\"\"value2\"}</code> </p> </li> <li> <p>Extra colons: <code>{\"key1\"::\"value1\",\"key2\"\"value2\"}</code> </p> </li> </ul>"
              }
            ]
          },
          "OversizeHandling": {
            "allOf": [
              {
                "$ref": "#/$defs/OversizeHandling"
              },
              {
                "description": "<p>What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. If the body is larger than the limit, the underlying host service only forwards the contents that are below the limit to WAF for inspection. </p> <p>The default limit is 8 KB (8,192 kilobytes) for regional resources and 16 KB (16,384 kilobytes) for CloudFront distributions. For CloudFront distributions, you can increase the limit in the web ACL <code>AssociationConfig</code>, for additional processing fees. </p> <p>The options for oversize handling are the following:</p> <ul> <li> <p> <code>CONTINUE</code> - Inspect the available body contents normally, according to the rule inspection criteria. </p> </li> <li> <p> <code>MATCH</code> - Treat the web request as matching the rule statement. WAF applies the rule action to the request.</p> </li> <li> <p> <code>NO_MATCH</code> - Treat the web request as not matching the rule statement.</p> </li> </ul> <p>You can combine the <code>MATCH</code> or <code>NO_MATCH</code> settings for oversize handling with your rule and web ACL action settings, so that you block any request whose body is over the limit. </p> <p>Default: <code>CONTINUE</code> </p>"
              }
            ]
          }
        },
        "description": "<p>Inspect the body of the web request as JSON. The body immediately follows the request headers. </p> <p>This is used to indicate the web request component to inspect, in the <a>FieldToMatch</a> specification. </p> <p>Use the specifications in this object to indicate which parts of the JSON body to inspect using the rule's inspection criteria. WAF inspects only the parts of the JSON that result from the matches that you indicate. </p> <p>Example JSON: <code>\"JsonBody\": { \"MatchPattern\": { \"All\": {} }, \"MatchScope\": \"ALL\" }</code> </p>"
      },
      "JsonMatchPattern": {
        "type": "object",
        "properties": {
          "All": {
            "allOf": [
              {
                "$ref": "#/$defs/All"
              },
              {
                "description": "<p>Match all of the elements. See also <code>MatchScope</code> in <a>JsonBody</a>. </p> <p>You must specify either this setting or the <code>IncludedPaths</code> setting, but not both.</p>"
              }
            ]
          },
          "IncludedPaths": {
            "allOf": [
              {
                "$ref": "#/$defs/JsonPointerPaths"
              },
              {
                "description": "<p>Match only the specified include paths. See also <code>MatchScope</code> in <a>JsonBody</a>. </p> <p>Provide the include paths using JSON Pointer syntax. For example, <code>\"IncludedPaths\": [\"/dogs/0/name\", \"/dogs/1/name\"]</code>. For information about this syntax, see the Internet Engineering Task Force (IETF) documentation <a href=\"https://tools.ietf.org/html/rfc6901\">JavaScript Object Notation (JSON) Pointer</a>. </p> <p>You must specify either this setting or the <code>All</code> setting, but not both.</p> <note> <p>Don't use this option to include all paths. Instead, use the <code>All</code> setting. </p> </note>"
              }
            ]
          }
        },
        "description": "The patterns to look for in the JSON body. WAF inspects the results of these pattern matches against the rule inspection criteria. This is used with the <a>FieldToMatch</a> option <code>JsonBody</code>. "
      },
      "All": {
        "type": "object",
        "properties": {},
        "description": "<p>Inspect all of the elements that WAF has parsed and extracted from the web request component that you've identified in your <a>FieldToMatch</a> specifications. </p> <p>This is used in the <a>FieldToMatch</a> specification for some web request component types. </p> <p>JSON specification: <code>\"All\": {}</code> </p>"
      },
      "JsonPointerPaths": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/JsonPointerPath"
        },
        "minItems": 1
      },
      "JsonPointerPath": {
        "type": "string",
        "pattern": "([/])|([/](([^~])|(~[01]))+)",
        "minLength": 1,
        "maxLength": 512
      },
      "JsonMatchScope": {
        "type": "string",
        "enum": [
          "ALL",
          "KEY",
          "VALUE"
        ]
      },
      "BodyParsingFallbackBehavior": {
        "type": "string",
        "enum": [
          "MATCH",
          "NO_MATCH",
          "EVALUATE_AS_STRING"
        ]
      },
      "Headers": {
        "type": "object",
        "required": [
          "MatchPattern",
          "MatchScope",
          "OversizeHandling"
        ],
        "properties": {
          "MatchPattern": {
            "allOf": [
              {
                "$ref": "#/$defs/HeaderMatchPattern"
              },
              {
                "description": "<p>The filter to use to identify the subset of headers to inspect in a web request. </p> <p>You must specify exactly one setting: either <code>All</code>, <code>IncludedHeaders</code>, or <code>ExcludedHeaders</code>.</p> <p>Example JSON: <code>\"MatchPattern\": { \"ExcludedHeaders\": [ \"KeyToExclude1\", \"KeyToExclude2\" ] }</code> </p>"
              }
            ]
          },
          "MatchScope": {
            "allOf": [
              {
                "$ref": "#/$defs/MapMatchScope"
              },
              {
                "description": "The parts of the headers to match with the rule inspection criteria. If you specify <code>All</code>, WAF inspects both keys and values. "
              }
            ]
          },
          "OversizeHandling": {
            "allOf": [
              {
                "$ref": "#/$defs/OversizeHandling"
              },
              {
                "description": "<p>What WAF should do if the headers of the request are more numerous or larger than WAF can inspect. WAF does not support inspecting the entire contents of request headers when they exceed 8 KB (8192 bytes) or 200 total headers. The underlying host service forwards a maximum of 200 headers and at most 8 KB of header contents to WAF. </p> <p>The options for oversize handling are the following:</p> <ul> <li> <p> <code>CONTINUE</code> - Inspect the available headers normally, according to the rule inspection criteria. </p> </li> <li> <p> <code>MATCH</code> - Treat the web request as matching the rule statement. WAF applies the rule action to the request.</p> </li> <li> <p> <code>NO_MATCH</code> - Treat the web request as not matching the rule statement.</p> </li> </ul>"
              }
            ]
          }
        },
        "description": "<p>Inspect all headers in the web request. You can specify the parts of the headers to inspect and you can narrow the set of headers to inspect by including or excluding specific keys.</p> <p>This is used to indicate the web request component to inspect, in the <a>FieldToMatch</a> specification. </p> <p>If you want to inspect just the value of a single header, use the <code>SingleHeader</code> <code>FieldToMatch</code> setting instead.</p> <p>Example JSON: <code>\"Headers\": { \"MatchPattern\": { \"All\": {} }, \"MatchScope\": \"KEY\", \"OversizeHandling\": \"MATCH\" }</code> </p>"
      },
      "HeaderMatchPattern": {
        "type": "object",
        "properties": {
          "All": {
            "allOf": [
              {
                "$ref": "#/$defs/All"
              },
              {
                "description": "Inspect all headers. "
              }
            ]
          },
          "IncludedHeaders": {
            "allOf": [
              {
                "$ref": "#/$defs/HeaderNames"
              },
              {
                "description": "Inspect only the headers that have a key that matches one of the strings specified here. "
              }
            ]
          },
          "ExcludedHeaders": {
            "allOf": [
              {
                "$ref": "#/$defs/HeaderNames"
              },
              {
                "description": "Inspect only the headers whose keys don't match any of the strings specified here. "
              }
            ]
          }
        },
        "description": "<p>The filter to use to identify the subset of headers to inspect in a web request. </p> <p>You must specify exactly one setting: either <code>All</code>, <code>IncludedHeaders</code>, or <code>ExcludedHeaders</code>.</p> <p>Example JSON: <code>\"MatchPattern\": { \"ExcludedHeaders\": [ \"KeyToExclude1\", \"KeyToExclude2\" ] }</code> </p>"
      },
      "HeaderNames": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/FieldToMatchData"
        },
        "minItems": 1,
        "maxItems": 199
      },
      "MapMatchScope": {
        "type": "string",
        "enum": [
          "ALL",
          "KEY",
          "VALUE"
        ]
      },
      "Cookies": {
        "type": "object",
        "required": [
          "MatchPattern",
          "MatchScope",
          "OversizeHandling"
        ],
        "properties": {
          "MatchPattern": {
            "allOf": [
              {
                "$ref": "#/$defs/CookieMatchPattern"
              },
              {
                "description": "<p>The filter to use to identify the subset of cookies to inspect in a web request. </p> <p>You must specify exactly one setting: either <code>All</code>, <code>IncludedCookies</code>, or <code>ExcludedCookies</code>.</p> <p>Example JSON: <code>\"MatchPattern\": { \"IncludedCookies\": [ \"session-id-time\", \"session-id\" ] }</code> </p>"
              }
            ]
          },
          "MatchScope": {
            "allOf": [
              {
                "$ref": "#/$defs/MapMatchScope"
              },
              {
                "description": "The parts of the cookies to inspect with the rule inspection criteria. If you specify <code>All</code>, WAF inspects both keys and values. "
              }
            ]
          },
          "OversizeHandling": {
            "allOf": [
              {
                "$ref": "#/$defs/OversizeHandling"
              },
              {
                "description": "<p>What WAF should do if the cookies of the request are more numerous or larger than WAF can inspect. WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to WAF. </p> <p>The options for oversize handling are the following:</p> <ul> <li> <p> <code>CONTINUE</code> - Inspect the available cookies normally, according to the rule inspection criteria. </p> </li> <li> <p> <code>MATCH</code> - Treat the web request as matching the rule statement. WAF applies the rule action to the request.</p> </li> <li> <p> <code>NO_MATCH</code> - Treat the web request as not matching the rule statement.</p> </li> </ul>"
              }
            ]
          }
        },
        "description": "<p>Inspect the cookies in the web request. You can specify the parts of the cookies to inspect and you can narrow the set of cookies to inspect by including or excluding specific keys.</p> <p>This is used to indicate the web request component to inspect, in the <a>FieldToMatch</a> specification. </p> <p>Example JSON: <code>\"Cookies\": { \"MatchPattern\": { \"All\": {} }, \"MatchScope\": \"KEY\", \"OversizeHandling\": \"MATCH\" }</code> </p>"
      },
      "CookieMatchPattern": {
        "type": "object",
        "properties": {
          "All": {
            "allOf": [
              {
                "$ref": "#/$defs/All"
              },
              {
                "description": "Inspect all cookies. "
              }
            ]
          },
          "IncludedCookies": {
            "allOf": [
              {
                "$ref": "#/$defs/CookieNames"
              },
              {
                "description": "Inspect only the cookies that have a key that matches one of the strings specified here. "
              }
            ]
          },
          "ExcludedCookies": {
            "allOf": [
              {
                "$ref": "#/$defs/CookieNames"
              },
              {
                "description": "Inspect only the cookies whose keys don't match any of the strings specified here. "
              }
            ]
          }
        },
        "description": "<p>The filter to use to identify the subset of cookies to inspect in a web request. </p> <p>You must specify exactly one setting: either <code>All</code>, <code>IncludedCookies</code>, or <code>ExcludedCookies</code>.</p> <p>Example JSON: <code>\"MatchPattern\": { \"IncludedCookies\": [ \"session-id-time\", \"session-id\" ] }</code> </p>"
      },
      "CookieNames": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/SingleCookieName"
        },
        "minItems": 1,
        "maxItems": 199
      },
      "SingleCookieName": {
        "type": "string",
        "pattern": ".*\\S.*",
        "minLength": 1,
        "maxLength": 60
      },
      "HeaderOrder": {
        "type": "object",
        "required": [
          "OversizeHandling"
        ],
        "properties": {
          "OversizeHandling": {
            "allOf": [
              {
                "$ref": "#/$defs/OversizeHandling"
              },
              {
                "description": "<p>What WAF should do if the headers of the request are more numerous or larger than WAF can inspect. WAF does not support inspecting the entire contents of request headers when they exceed 8 KB (8192 bytes) or 200 total headers. The underlying host service forwards a maximum of 200 headers and at most 8 KB of header contents to WAF. </p> <p>The options for oversize handling are the following:</p> <ul> <li> <p> <code>CONTINUE</code> - Inspect the available headers normally, according to the rule inspection criteria. </p> </li> <li> <p> <code>MATCH</code> - Treat the web request as matching the rule statement. WAF applies the rule action to the request.</p> </li> <li> <p> <code>NO_MATCH</code> - Treat the web request as not matching the rule statement.</p> </li> </ul>"
              }
            ]
          }
        },
        "description": "Inspect a string containing the list of the request's header names, ordered as they appear in the web request that WAF receives for inspection. WAF generates the string and then uses that as the field to match component in its inspection. WAF separates the header names in the string using colons and no added spaces, for example <code>host:user-agent:accept:authorization:referer</code>."
      },
      "Boolean": {
        "type": "boolean"
      },
      "LoggingFilter": {
        "type": "object",
        "required": [
          "Filters",
          "DefaultBehavior"
        ],
        "properties": {
          "Filters": {
            "allOf": [
              {
                "$ref": "#/$defs/Filters"
              },
              {
                "description": "The filters that you want to apply to the logs. "
              }
            ]
          },
          "DefaultBehavior": {
            "allOf": [
              {
                "$ref": "#/$defs/FilterBehavior"
              },
              {
                "description": "Default handling for logs that don't match any of the specified filtering conditions. "
              }
            ]
          }
        },
        "description": "<p>Filtering that specifies which web requests are kept in the logs and which are dropped, defined for a web ACL's <a>LoggingConfiguration</a>. </p> <p>You can filter on the rule action and on the web request labels that were applied by matching rules during web ACL evaluation. </p>"
      },
      "Filters": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/Filter"
        },
        "minItems": 1
      },
      "Filter": {
        "type": "object",
        "required": [
          "Behavior",
          "Requirement",
          "Conditions"
        ],
        "properties": {
          "Behavior": {
            "allOf": [
              {
                "$ref": "#/$defs/FilterBehavior"
              },
              {
                "description": "How to handle logs that satisfy the filter's conditions and requirement. "
              }
            ]
          },
          "Requirement": {
            "allOf": [
              {
                "$ref": "#/$defs/FilterRequirement"
              },
              {
                "description": "Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition."
              }
            ]
          },
          "Conditions": {
            "allOf": [
              {
                "$ref": "#/$defs/Conditions"
              },
              {
                "description": "Match conditions for the filter."
              }
            ]
          }
        },
        "description": "A single logging filter, used in <a>LoggingFilter</a>. "
      },
      "FilterBehavior": {
        "type": "string",
        "enum": [
          "KEEP",
          "DROP"
        ]
      },
      "FilterRequirement": {
        "type": "string",
        "enum": [
          "MEETS_ALL",
          "MEETS_ANY"
        ]
      },
      "Conditions": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/Condition"
        },
        "minItems": 1
      },
      "Condition": {
        "type": "object",
        "properties": {
          "ActionCondition": {
            "allOf": [
              {
                "$ref": "#/$defs/ActionCondition"
              },
              {
                "description": "A single action condition. This is the action setting that a log record must contain in order to meet the condition."
              }
            ]
          },
          "LabelNameCondition": {
            "allOf": [
              {
                "$ref": "#/$defs/LabelNameCondition"
              },
              {
                "description": "A single label name condition. This is the fully qualified label name that a log record must contain in order to meet the condition. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label. "
              }
            ]
          }
        },
        "description": "A single match condition for a <a>Filter</a>."
      },
      "ActionCondition": {
        "type": "object",
        "required": [
          "Action"
        ],
        "properties": {
          "Action": {
            "allOf": [
              {
                "$ref": "#/$defs/ActionValue"
              },
              {
                "description": "<p>The action setting that a log record must contain in order to meet the condition. This is the action that WAF applied to the web request. </p> <p>For rule groups, this is either the configured rule action setting, or if you've applied a rule action override to the rule, it's the override action. The value <code>EXCLUDED_AS_COUNT</code> matches on excluded rules and also on rules that have a rule action override of Count. </p>"
              }
            ]
          }
        },
        "description": "A single action condition for a <a>Condition</a> in a logging filter."
      },
      "ActionValue": {
        "type": "string",
        "enum": [
          "ALLOW",
          "BLOCK",
          "COUNT",
          "CAPTCHA",
          "CHALLENGE",
          "EXCLUDED_AS_COUNT"
        ]
      },
      "LabelNameCondition": {
        "type": "object",
        "required": [
          "LabelName"
        ],
        "properties": {
          "LabelName": {
            "allOf": [
              {
                "$ref": "#/$defs/LabelName"
              },
              {
                "description": "The label name that a log record must contain in order to meet the condition. This must be a fully qualified label name. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label. "
              }
            ]
          }
        },
        "description": "A single label name condition for a <a>Condition</a> in a logging filter."
      },
      "LabelName": {
        "type": "string",
        "pattern": "^[0-9A-Za-z_\\-:]+$",
        "minLength": 1,
        "maxLength": 1024
      }
    }
  },
  "handler": "http",
  "request": {
    "method": "POST",
    "url": {
      "$uri": "http://wafv2.us-east-1.amazonaws.com/#X-Amz-Target=AWSWAF_20190729.PutLoggingConfiguration"
    },
    "headers": {
      "X-Amz-Target": {
        "$": "X-Amz-Target"
      },
      "X-Amz-Content-Sha256": {
        "$": "X-Amz-Content-Sha256"
      },
      "X-Amz-Date": {
        "$": "X-Amz-Date"
      },
      "X-Amz-Algorithm": {
        "$": "X-Amz-Algorithm"
      },
      "X-Amz-Credential": {
        "$": "X-Amz-Credential"
      },
      "X-Amz-Security-Token": {
        "$": "X-Amz-Security-Token"
      },
      "X-Amz-Signature": {
        "$": "X-Amz-Signature"
      },
      "X-Amz-SignedHeaders": {
        "$": "X-Amz-SignedHeaders"
      }
    },
    "body": {
      "$": "body",
      "encode": "json"
    }
  },
  "responses": {
    "200": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "**Key properties:**",
        {
          "$ul": [
            "**LoggingConfiguration**"
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    },
    "480": {
      "$encode": "markdown",
      "$lang": "json",
      "$code": {
        "$encode": "json",
        "$indent": true,
        "$content": {
          "$": "$.body"
        }
      }
    },
    "481": {
      "$encode": "markdown",
      "$lang": "json",
      "$code": {
        "$encode": "json",
        "$indent": true,
        "$content": {
          "$": "$.body"
        }
      }
    },
    "482": {
      "$encode": "markdown",
      "$lang": "json",
      "$code": {
        "$encode": "json",
        "$indent": true,
        "$content": {
          "$": "$.body"
        }
      }
    },
    "483": {
      "$encode": "markdown",
      "$lang": "json",
      "$code": {
        "$encode": "json",
        "$indent": true,
        "$content": {
          "$": "$.body"
        }
      }
    },
    "484": {
      "$encode": "markdown",
      "$lang": "json",
      "$code": {
        "$encode": "json",
        "$indent": true,
        "$content": {
          "$": "$.body"
        }
      }
    },
    "485": {
      "$encode": "markdown",
      "$lang": "json",
      "$code": {
        "$encode": "json",
        "$indent": true,
        "$content": {
          "$": "$.body"
        }
      }
    },
    "486": {
      "$encode": "markdown",
      "$lang": "json",
      "$code": {
        "$encode": "json",
        "$indent": true,
        "$content": {
          "$": "$.body"
        }
      }
    },
    "487": {
      "$encode": "markdown",
      "$lang": "json",
      "$code": {
        "$encode": "json",
        "$indent": true,
        "$content": {
          "$": "$.body"
        }
      }
    }
  }
}
