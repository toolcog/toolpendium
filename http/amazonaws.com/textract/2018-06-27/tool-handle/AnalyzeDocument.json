{
  "name": "AnalyzeDocument",
  "description": "<p>Analyzes an input document for relationships between detected items. </p> <p>The types of information returned are as follows: </p> <ul> <li> <p>Form data (key-value pairs). The related information is returned in two <a>Block</a> objects, each of type <code>KEY_VALUE_SET</code>: a KEY <code>Block</code> object and a VALUE <code>Block</code> object. For example, <i>Name: Ana Silva Carolina</i> contains a key and value. <i>Name:</i> is the key. <i>Ana Silva Carolina</i> is the value.</p> </li> <li> <p>Table and table cell data. A TABLE <code>Block</code> object contains information about a detected table. A CELL <code>Block</code> object is returned for each cell in a table.</p> </li> <li> <p>Lines and words of text. A LINE <code>Block</code> object contains one or more WORD <code>Block</code> objects. All lines and words that are detected in the document are returned (including text that doesn't have a relationship with the value of <code>FeatureTypes</code>). </p> </li> <li> <p>Signatures. A SIGNATURE <code>Block</code> object contains the location information of a signature in a document. If used in conjunction with forms or tables, a signature can be given a Key-Value pairing or be detected in the cell of a table.</p> </li> <li> <p>Query. A QUERY Block object contains the query text, alias and link to the associated Query results block object.</p> </li> <li> <p>Query Result. A QUERY_RESULT Block object contains the answer to the query and an ID that connects it to the query asked. This Block also contains a confidence score.</p> </li> </ul> <p>Selection elements such as check boxes and option buttons (radio buttons) can be detected in form data and in tables. A SELECTION_ELEMENT <code>Block</code> object contains information about a selection element, including the selection status.</p> <p>You can choose which type of analysis to perform by specifying the <code>FeatureTypes</code> list. </p> <p>The output is returned in a list of <code>Block</code> objects.</p> <p> <code>AnalyzeDocument</code> is a synchronous operation. To analyze documents asynchronously, use <a>StartDocumentAnalysis</a>.</p> <p>For more information, see <a href=\"https://docs.aws.amazon.com/textract/latest/dg/how-it-works-analyzing.html\">Document Text Analysis</a>.</p>",
  "parameters": {
    "type": "object",
    "properties": {
      "X-Amz-Target": {
        "type": "string",
        "enum": [
          "Textract.AnalyzeDocument"
        ]
      },
      "X-Amz-Content-Sha256": {
        "type": "string"
      },
      "X-Amz-Date": {
        "type": "string"
      },
      "X-Amz-Algorithm": {
        "type": "string"
      },
      "X-Amz-Credential": {
        "type": "string"
      },
      "X-Amz-Security-Token": {
        "type": "string"
      },
      "X-Amz-Signature": {
        "type": "string"
      },
      "X-Amz-SignedHeaders": {
        "type": "string"
      },
      "body": {
        "$ref": "#/$defs/AnalyzeDocumentRequest"
      }
    },
    "required": [
      "X-Amz-Target",
      "body"
    ],
    "$defs": {
      "AnalyzeDocumentRequest": {
        "type": "object",
        "required": [
          "Document",
          "FeatureTypes"
        ],
        "title": "AnalyzeDocumentRequest",
        "properties": {
          "Document": {
            "allOf": [
              {
                "$ref": "#/$defs/Document"
              },
              {
                "description": "<p>The input document as base64-encoded bytes or an Amazon S3 object. If you use the AWS CLI to call Amazon Textract operations, you can't pass image bytes. The document must be an image in JPEG, PNG, PDF, or TIFF format.</p> <p>If you're using an AWS SDK to call Amazon Textract, you might not need to base64-encode image bytes that are passed using the <code>Bytes</code> field. </p>"
              }
            ]
          },
          "FeatureTypes": {
            "allOf": [
              {
                "$ref": "#/$defs/FeatureTypes"
              },
              {
                "description": "A list of the types of analysis to perform. Add TABLES to the list to return information about the tables that are detected in the input document. Add FORMS to return detected form data. Add SIGNATURES to return the locations of detected signatures. To perform both forms and table analysis, add TABLES and FORMS to <code>FeatureTypes</code>. To detect signatures within form data and table data, add SIGNATURES to either TABLES or FORMS. All lines and words detected in the document are included in the response (including text that isn't related to the value of <code>FeatureTypes</code>). "
              }
            ]
          },
          "HumanLoopConfig": {
            "allOf": [
              {
                "$ref": "#/$defs/HumanLoopConfig"
              },
              {
                "description": "Sets the configuration for the human in the loop workflow for analyzing documents."
              }
            ]
          },
          "QueriesConfig": {
            "allOf": [
              {
                "$ref": "#/$defs/QueriesConfig"
              },
              {
                "description": "Contains Queries and the alias for those Queries, as determined by the input. "
              }
            ]
          }
        }
      },
      "Document": {
        "type": "object",
        "properties": {
          "Bytes": {
            "allOf": [
              {
                "$ref": "#/$defs/ImageBlob"
              },
              {
                "description": "<p>A blob of base64-encoded document bytes. The maximum size of a document that's provided in a blob of bytes is 5 MB. The document bytes must be in PNG or JPEG format.</p> <p>If you're using an AWS SDK to call Amazon Textract, you might not need to base64-encode image bytes passed using the <code>Bytes</code> field. </p>"
              }
            ]
          },
          "S3Object": {
            "allOf": [
              {
                "$ref": "#/$defs/S3Object"
              },
              {
                "description": "Identifies an S3 object as the document source. The maximum size of a document that's stored in an S3 bucket is 5 MB."
              }
            ]
          }
        },
        "description": "<p>The input document, either as bytes or as an S3 object.</p> <p>You pass image bytes to an Amazon Textract API operation by using the <code>Bytes</code> property. For example, you would use the <code>Bytes</code> property to pass a document loaded from a local file system. Image bytes passed by using the <code>Bytes</code> property must be base64 encoded. Your code might not need to encode document file bytes if you're using an AWS SDK to call Amazon Textract API operations. </p> <p>You pass images stored in an S3 bucket to an Amazon Textract API operation by using the <code>S3Object</code> property. Documents stored in an S3 bucket don't need to be base64 encoded.</p> <p>The AWS Region for the S3 bucket that contains the S3 object must match the AWS Region that you use for Amazon Textract operations.</p> <p>If you use the AWS CLI to call Amazon Textract operations, passing image bytes using the Bytes property isn't supported. You must first upload the document to an Amazon S3 bucket, and then call the operation using the S3Object property.</p> <p>For Amazon Textract to process an S3 object, the user must have permission to access the S3 object. </p>"
      },
      "ImageBlob": {
        "type": "string",
        "minLength": 1,
        "maxLength": 10485760
      },
      "S3Object": {
        "type": "object",
        "properties": {
          "Bucket": {
            "allOf": [
              {
                "$ref": "#/$defs/S3Bucket"
              },
              {
                "description": "The name of the S3 bucket. Note that the # character is not valid in the file name."
              }
            ]
          },
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/S3ObjectName"
              },
              {
                "description": "The file name of the input document. Synchronous operations can use image files that are in JPEG or PNG format. Asynchronous operations also support PDF and TIFF format files."
              }
            ]
          },
          "Version": {
            "allOf": [
              {
                "$ref": "#/$defs/S3ObjectVersion"
              },
              {
                "description": "If the bucket has versioning enabled, you can specify the object version. "
              }
            ]
          }
        },
        "description": "<p>The S3 bucket name and file name that identifies the document.</p> <p>The AWS Region for the S3 bucket that contains the document must match the Region that you use for Amazon Textract operations.</p> <p>For Amazon Textract to process a file in an S3 bucket, the user must have permission to access the S3 bucket and file. </p>"
      },
      "S3Bucket": {
        "type": "string",
        "pattern": "[0-9A-Za-z\\.\\-_]*",
        "minLength": 3,
        "maxLength": 255
      },
      "S3ObjectName": {
        "type": "string",
        "pattern": ".*\\S.*",
        "minLength": 1,
        "maxLength": 1024
      },
      "S3ObjectVersion": {
        "type": "string",
        "pattern": ".*\\S.*",
        "minLength": 1,
        "maxLength": 1024
      },
      "FeatureTypes": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/FeatureType"
        }
      },
      "FeatureType": {
        "type": "string",
        "enum": [
          "TABLES",
          "FORMS",
          "QUERIES",
          "SIGNATURES"
        ]
      },
      "HumanLoopConfig": {
        "type": "object",
        "required": [
          "HumanLoopName",
          "FlowDefinitionArn"
        ],
        "properties": {
          "HumanLoopName": {
            "allOf": [
              {
                "$ref": "#/$defs/HumanLoopName"
              },
              {
                "description": "The name of the human workflow used for this image. This should be kept unique within a region."
              }
            ]
          },
          "FlowDefinitionArn": {
            "allOf": [
              {
                "$ref": "#/$defs/FlowDefinitionArn"
              },
              {
                "description": "The Amazon Resource Name (ARN) of the flow definition."
              }
            ]
          },
          "DataAttributes": {
            "allOf": [
              {
                "$ref": "#/$defs/HumanLoopDataAttributes"
              },
              {
                "description": "Sets attributes of the input data."
              }
            ]
          }
        },
        "description": "Sets up the human review workflow the document will be sent to if one of the conditions is met. You can also set certain attributes of the image before review. "
      },
      "HumanLoopName": {
        "type": "string",
        "pattern": "^[a-z0-9](-*[a-z0-9])*",
        "minLength": 1,
        "maxLength": 63
      },
      "FlowDefinitionArn": {
        "type": "string",
        "maxLength": 256
      },
      "HumanLoopDataAttributes": {
        "type": "object",
        "properties": {
          "ContentClassifiers": {
            "allOf": [
              {
                "$ref": "#/$defs/ContentClassifiers"
              },
              {
                "description": "Sets whether the input image is free of personally identifiable information or adult content."
              }
            ]
          }
        },
        "description": "Allows you to set attributes of the image. Currently, you can declare an image as free of personally identifiable information and adult content. "
      },
      "ContentClassifiers": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/ContentClassifier"
        },
        "maxItems": 256
      },
      "ContentClassifier": {
        "type": "string",
        "enum": [
          "FreeOfPersonallyIdentifiableInformation",
          "FreeOfAdultContent"
        ]
      },
      "QueriesConfig": {
        "type": "object",
        "required": [
          "Queries"
        ],
        "properties": {
          "Queries": {
            "allOf": [
              {
                "$ref": "#/$defs/Queries"
              },
              {
                "description": "<p/>"
              }
            ]
          }
        },
        "description": "<p/>"
      },
      "Queries": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/Query"
        },
        "minItems": 1
      },
      "Query": {
        "type": "object",
        "required": [
          "Text"
        ],
        "properties": {
          "Text": {
            "allOf": [
              {
                "$ref": "#/$defs/QueryInput"
              },
              {
                "description": "Question that Amazon Textract will apply to the document. An example would be \"What is the customer's SSN?\""
              }
            ]
          },
          "Alias": {
            "allOf": [
              {
                "$ref": "#/$defs/QueryInput"
              },
              {
                "description": "Alias attached to the query, for ease of location."
              }
            ]
          },
          "Pages": {
            "allOf": [
              {
                "$ref": "#/$defs/QueryPages"
              },
              {
                "description": "<p>Pages is a parameter that the user inputs to specify which pages to apply a query to. The following is a list of rules for using this parameter.</p> <ul> <li> <p>If a page is not specified, it is set to <code>[\"1\"]</code> by default.</p> </li> <li> <p>The following characters are allowed in the parameter's string: <code>0 1 2 3 4 5 6 7 8 9 - *</code>. No whitespace is allowed.</p> </li> <li> <p>When using * to indicate all pages, it must be the only element in the list.</p> </li> <li> <p>You can use page intervals, such as <code>[“1-3”, “1-1”, “4-*”]</code>. Where <code>*</code> indicates last page of document.</p> </li> <li> <p>Specified pages must be greater than 0 and less than or equal to the number of pages in the document.</p> </li> </ul>"
              }
            ]
          }
        },
        "description": "Each query contains the question you want to ask in the Text and the alias you want to associate."
      },
      "QueryInput": {
        "type": "string",
        "pattern": "^[a-zA-Z0-9\\s!\"\\#\\$%'&\\(\\)\\*\\+\\,\\-\\./:;=\\?@\\[\\\\\\]\\^_`\\{\\|\\}~><]+$",
        "minLength": 1,
        "maxLength": 200
      },
      "QueryPages": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/QueryPage"
        },
        "minItems": 1
      },
      "QueryPage": {
        "type": "string",
        "pattern": "^[0-9\\*\\-]+$",
        "minLength": 1,
        "maxLength": 9
      }
    }
  },
  "handler": "http",
  "request": {
    "method": "POST",
    "url": {
      "$uri": "http://textract.us-east-1.amazonaws.com/#X-Amz-Target=Textract.AnalyzeDocument"
    },
    "headers": {
      "X-Amz-Target": {
        "$": "X-Amz-Target"
      },
      "X-Amz-Content-Sha256": {
        "$": "X-Amz-Content-Sha256"
      },
      "X-Amz-Date": {
        "$": "X-Amz-Date"
      },
      "X-Amz-Algorithm": {
        "$": "X-Amz-Algorithm"
      },
      "X-Amz-Credential": {
        "$": "X-Amz-Credential"
      },
      "X-Amz-Security-Token": {
        "$": "X-Amz-Security-Token"
      },
      "X-Amz-Signature": {
        "$": "X-Amz-Signature"
      },
      "X-Amz-SignedHeaders": {
        "$": "X-Amz-SignedHeaders"
      }
    },
    "body": {
      "$": "body",
      "encode": "json"
    }
  },
  "responses": {
    "200": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "**Key properties:**",
        {
          "$ul": [
            "**DocumentMetadata**",
            "**Blocks**",
            "**HumanLoopActivationOutput**",
            "**AnalyzeDocumentModelVersion**"
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    },
    "480": {
      "$encode": "markdown",
      "$lang": "json",
      "$code": {
        "$encode": "json",
        "$indent": true,
        "$content": {
          "$": "$.body"
        }
      }
    },
    "481": {
      "$encode": "markdown",
      "$lang": "json",
      "$code": {
        "$encode": "json",
        "$indent": true,
        "$content": {
          "$": "$.body"
        }
      }
    },
    "482": {
      "$encode": "markdown",
      "$lang": "json",
      "$code": {
        "$encode": "json",
        "$indent": true,
        "$content": {
          "$": "$.body"
        }
      }
    },
    "483": {
      "$encode": "markdown",
      "$lang": "json",
      "$code": {
        "$encode": "json",
        "$indent": true,
        "$content": {
          "$": "$.body"
        }
      }
    },
    "484": {
      "$encode": "markdown",
      "$lang": "json",
      "$code": {
        "$encode": "json",
        "$indent": true,
        "$content": {
          "$": "$.body"
        }
      }
    },
    "485": {
      "$encode": "markdown",
      "$lang": "json",
      "$code": {
        "$encode": "json",
        "$indent": true,
        "$content": {
          "$": "$.body"
        }
      }
    },
    "486": {
      "$encode": "markdown",
      "$lang": "json",
      "$code": {
        "$encode": "json",
        "$indent": true,
        "$content": {
          "$": "$.body"
        }
      }
    },
    "487": {
      "$encode": "markdown",
      "$lang": "json",
      "$code": {
        "$encode": "json",
        "$indent": true,
        "$content": {
          "$": "$.body"
        }
      }
    },
    "488": {
      "$encode": "markdown",
      "$lang": "json",
      "$code": {
        "$encode": "json",
        "$indent": true,
        "$content": {
          "$": "$.body"
        }
      }
    },
    "489": {
      "$encode": "markdown",
      "$lang": "json",
      "$code": {
        "$encode": "json",
        "$indent": true,
        "$content": {
          "$": "$.body"
        }
      }
    }
  }
}
