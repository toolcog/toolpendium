{
  "name": "CreateJob",
  "description": "Creates a new job definition.",
  "parameters": {
    "type": "object",
    "properties": {
      "X-Amz-Target": {
        "type": "string",
        "enum": [
          "AWSGlue.CreateJob"
        ]
      },
      "X-Amz-Content-Sha256": {
        "type": "string"
      },
      "X-Amz-Date": {
        "type": "string"
      },
      "X-Amz-Algorithm": {
        "type": "string"
      },
      "X-Amz-Credential": {
        "type": "string"
      },
      "X-Amz-Security-Token": {
        "type": "string"
      },
      "X-Amz-Signature": {
        "type": "string"
      },
      "X-Amz-SignedHeaders": {
        "type": "string"
      },
      "body": {
        "$ref": "#/$defs/CreateJobRequest"
      }
    },
    "required": [
      "X-Amz-Target",
      "body"
    ],
    "$defs": {
      "CreateJobRequest": {
        "type": "object",
        "required": [
          "Name",
          "Role",
          "Command"
        ],
        "title": "CreateJobRequest",
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NameString"
              },
              {
                "description": "The name you assign to this job definition. It must be unique in your account."
              }
            ]
          },
          "Description": {
            "allOf": [
              {
                "$ref": "#/$defs/DescriptionString"
              },
              {
                "description": "Description of the job being defined."
              }
            ]
          },
          "LogUri": {
            "allOf": [
              {
                "$ref": "#/$defs/UriString"
              },
              {
                "description": "This field is reserved for future use."
              }
            ]
          },
          "Role": {
            "allOf": [
              {
                "$ref": "#/$defs/RoleString"
              },
              {
                "description": "The name or Amazon Resource Name (ARN) of the IAM role associated with this job."
              }
            ]
          },
          "ExecutionProperty": {
            "allOf": [
              {
                "$ref": "#/$defs/ExecutionProperty"
              },
              {
                "description": "An <code>ExecutionProperty</code> specifying the maximum number of concurrent runs allowed for this job."
              }
            ]
          },
          "Command": {
            "allOf": [
              {
                "$ref": "#/$defs/JobCommand"
              },
              {
                "description": "The <code>JobCommand</code> that runs this job."
              }
            ]
          },
          "DefaultArguments": {
            "allOf": [
              {
                "$ref": "#/$defs/GenericMap"
              },
              {
                "description": "<p>The default arguments for every run of this job, specified as name-value pairs.</p> <p>You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes.</p> <p>Job arguments may be logged. Do not pass plaintext secrets as arguments. Retrieve secrets from a Glue Connection, Secrets Manager or other secret management mechanism if you intend to keep them within the Job. </p> <p>For information about how to specify and consume your own Job arguments, see the <a href=\"https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html\">Calling Glue APIs in Python</a> topic in the developer guide.</p> <p>For information about the arguments you can provide to this field when configuring Spark jobs, see the <a href=\"https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html\">Special Parameters Used by Glue</a> topic in the developer guide.</p> <p>For information about the arguments you can provide to this field when configuring Ray jobs, see <a href=\"https://docs.aws.amazon.com/glue/latest/dg/author-job-ray-job-parameters.html\">Using job parameters in Ray jobs</a> in the developer guide.</p>"
              }
            ]
          },
          "NonOverridableArguments": {
            "allOf": [
              {
                "$ref": "#/$defs/GenericMap"
              },
              {
                "description": "Arguments for this job that are not overridden when providing job arguments in a job run, specified as name-value pairs."
              }
            ]
          },
          "Connections": {
            "allOf": [
              {
                "$ref": "#/$defs/ConnectionsList"
              },
              {
                "description": "The connections used for this job."
              }
            ]
          },
          "MaxRetries": {
            "allOf": [
              {
                "$ref": "#/$defs/MaxRetries"
              },
              {
                "description": "The maximum number of times to retry this job if it fails."
              }
            ]
          },
          "AllocatedCapacity": {
            "allOf": [
              {
                "$ref": "#/$defs/IntegerValue"
              },
              {
                "deprecated": true,
                "description": "<p>This parameter is deprecated. Use <code>MaxCapacity</code> instead.</p> <p>The number of Glue data processing units (DPUs) to allocate to this Job. You can allocate a minimum of 2 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the <a href=\"https://aws.amazon.com/glue/pricing/\">Glue pricing page</a>.</p>This property is deprecated, use MaxCapacity instead."
              }
            ]
          },
          "Timeout": {
            "allOf": [
              {
                "$ref": "#/$defs/Timeout"
              },
              {
                "description": "The job timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters <code>TIMEOUT</code> status. The default is 2,880 minutes (48 hours)."
              }
            ]
          },
          "MaxCapacity": {
            "allOf": [
              {
                "$ref": "#/$defs/NullableDouble"
              },
              {
                "description": "<p>For Glue version 1.0 or earlier jobs, using the standard worker type, the number of Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the <a href=\"https://aws.amazon.com/glue/pricing/\"> Glue pricing page</a>.</p> <p>For Glue version 2.0+ jobs, you cannot specify a <code>Maximum capacity</code>. Instead, you should specify a <code>Worker type</code> and the <code>Number of workers</code>.</p> <p>Do not set <code>MaxCapacity</code> if using <code>WorkerType</code> and <code>NumberOfWorkers</code>.</p> <p>The value that can be allocated for <code>MaxCapacity</code> depends on whether you are running a Python shell job, an Apache Spark ETL job, or an Apache Spark streaming ETL job:</p> <ul> <li> <p>When you specify a Python shell job (<code>JobCommand.Name</code>=\"pythonshell\"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.</p> </li> <li> <p>When you specify an Apache Spark ETL job (<code>JobCommand.Name</code>=\"glueetl\") or Apache Spark streaming ETL job (<code>JobCommand.Name</code>=\"gluestreaming\"), you can allocate from 2 to 100 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.</p> </li> </ul>"
              }
            ]
          },
          "SecurityConfiguration": {
            "allOf": [
              {
                "$ref": "#/$defs/NameString"
              },
              {
                "description": "The name of the <code>SecurityConfiguration</code> structure to be used with this job."
              }
            ]
          },
          "Tags": {
            "allOf": [
              {
                "$ref": "#/$defs/TagsMap"
              },
              {
                "description": "The tags to use with this job. You may use tags to limit access to the job. For more information about tags in Glue, see <a href=\"https://docs.aws.amazon.com/glue/latest/dg/monitor-tags.html\">Amazon Web Services Tags in Glue</a> in the developer guide."
              }
            ]
          },
          "NotificationProperty": {
            "allOf": [
              {
                "$ref": "#/$defs/NotificationProperty"
              },
              {
                "description": "Specifies configuration properties of a job notification."
              }
            ]
          },
          "GlueVersion": {
            "allOf": [
              {
                "$ref": "#/$defs/GlueVersionString"
              },
              {
                "description": "<p>In Spark jobs, <code>GlueVersion</code> determines the versions of Apache Spark and Python that Glue available in a job. The Python version indicates the version supported for jobs of type Spark. </p> <p>Ray jobs should set <code>GlueVersion</code> to <code>4.0</code> or greater. However, the versions of Ray, Python and additional libraries available in your Ray job are determined by the <code>Runtime</code> parameter of the Job command.</p> <p>For more information about the available Glue versions and corresponding Spark and Python versions, see <a href=\"https://docs.aws.amazon.com/glue/latest/dg/add-job.html\">Glue version</a> in the developer guide.</p> <p>Jobs that are created without specifying a Glue version default to Glue 0.9.</p>"
              }
            ]
          },
          "NumberOfWorkers": {
            "allOf": [
              {
                "$ref": "#/$defs/NullableInteger"
              },
              {
                "description": "The number of workers of a defined <code>workerType</code> that are allocated when a job runs."
              }
            ]
          },
          "WorkerType": {
            "allOf": [
              {
                "$ref": "#/$defs/WorkerType"
              },
              {
                "description": "<p>The type of predefined worker that is allocated when a job runs. Accepts a value of G.1X, G.2X, G.4X, G.8X or G.025X for Spark jobs. Accepts the value Z.2X for Ray jobs.</p> <ul> <li> <p>For the <code>G.1X</code> worker type, each worker maps to 1 DPU (4 vCPUs, 16 GB of memory) with 84GB disk (approximately 34GB free), and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.</p> </li> <li> <p>For the <code>G.2X</code> worker type, each worker maps to 2 DPU (8 vCPUs, 32 GB of memory) with 128GB disk (approximately 77GB free), and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.</p> </li> <li> <p>For the <code>G.4X</code> worker type, each worker maps to 4 DPU (16 vCPUs, 64 GB of memory) with 256GB disk (approximately 235GB free), and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs in the following Amazon Web Services Regions: US East (Ohio), US East (N. Virginia), US West (Oregon), Asia Pacific (Singapore), Asia Pacific (Sydney), Asia Pacific (Tokyo), Canada (Central), Europe (Frankfurt), Europe (Ireland), and Europe (Stockholm).</p> </li> <li> <p>For the <code>G.8X</code> worker type, each worker maps to 8 DPU (32 vCPUs, 128 GB of memory) with 512GB disk (approximately 487GB free), and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs, in the same Amazon Web Services Regions as supported for the <code>G.4X</code> worker type.</p> </li> <li> <p>For the <code>G.025X</code> worker type, each worker maps to 0.25 DPU (2 vCPUs, 4 GB of memory) with 84GB disk (approximately 34GB free), and provides 1 executor per worker. We recommend this worker type for low volume streaming jobs. This worker type is only available for Glue version 3.0 streaming jobs.</p> </li> <li> <p>For the <code>Z.2X</code> worker type, each worker maps to 2 M-DPU (8vCPUs, 64 GB of memory) with 128 GB disk (approximately 120GB free), and provides up to 8 Ray workers based on the autoscaler.</p> </li> </ul>"
              }
            ]
          },
          "CodeGenConfigurationNodes": {
            "allOf": [
              {
                "$ref": "#/$defs/CodeGenConfigurationNodes"
              },
              {
                "description": "The representation of a directed acyclic graph on which both the Glue Studio visual component and Glue Studio code generation is based."
              }
            ]
          },
          "ExecutionClass": {
            "allOf": [
              {
                "$ref": "#/$defs/ExecutionClass"
              },
              {
                "description": "<p>Indicates whether the job is run with a standard or flexible execution class. The standard execution-class is ideal for time-sensitive workloads that require fast job startup and dedicated resources.</p> <p>The flexible execution class is appropriate for time-insensitive jobs whose start and completion times may vary. </p> <p>Only jobs with Glue version 3.0 and above and command type <code>glueetl</code> will be allowed to set <code>ExecutionClass</code> to <code>FLEX</code>. The flexible execution class is available for Spark jobs.</p>"
              }
            ]
          },
          "SourceControlDetails": {
            "allOf": [
              {
                "$ref": "#/$defs/SourceControlDetails"
              },
              {
                "description": "The details for a source control configuration for a job, allowing synchronization of job artifacts to or from a remote repository."
              }
            ]
          }
        }
      },
      "NameString": {
        "type": "string",
        "minLength": 1,
        "maxLength": 255,
        "x-pattern": "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*"
      },
      "DescriptionString": {
        "type": "string",
        "minLength": 0,
        "maxLength": 2048,
        "x-pattern": "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*"
      },
      "UriString": {
        "type": "string"
      },
      "RoleString": {
        "type": "string"
      },
      "ExecutionProperty": {
        "type": "object",
        "properties": {
          "MaxConcurrentRuns": {
            "allOf": [
              {
                "$ref": "#/$defs/MaxConcurrentRuns"
              },
              {
                "description": "The maximum number of concurrent runs allowed for the job. The default is 1. An error is returned when this threshold is reached. The maximum value you can specify is controlled by a service limit."
              }
            ]
          }
        },
        "description": "An execution property of a job."
      },
      "MaxConcurrentRuns": {
        "type": "integer"
      },
      "JobCommand": {
        "type": "object",
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/GenericString"
              },
              {
                "description": "The name of the job command. For an Apache Spark ETL job, this must be <code>glueetl</code>. For a Python shell job, it must be <code>pythonshell</code>. For an Apache Spark streaming ETL job, this must be <code>gluestreaming</code>. For a Ray job, this must be <code>glueray</code>."
              }
            ]
          },
          "ScriptLocation": {
            "allOf": [
              {
                "$ref": "#/$defs/ScriptLocationString"
              },
              {
                "description": "Specifies the Amazon Simple Storage Service (Amazon S3) path to a script that runs a job."
              }
            ]
          },
          "PythonVersion": {
            "allOf": [
              {
                "$ref": "#/$defs/PythonVersionString"
              },
              {
                "description": "The Python version being used to run a Python shell job. Allowed values are 2 or 3."
              }
            ]
          },
          "Runtime": {
            "allOf": [
              {
                "$ref": "#/$defs/RuntimeNameString"
              },
              {
                "description": "In Ray jobs, Runtime is used to specify the versions of Ray, Python and additional libraries available in your environment. This field is not used in other job types. For supported runtime environment values, see <a href=\"https://docs.aws.amazon.com/glue/latest/dg/author-job-ray-runtimes.html\">Working with Ray jobs</a> in the Glue Developer Guide."
              }
            ]
          }
        },
        "description": "Specifies code that runs when a job is run."
      },
      "GenericString": {
        "type": "string"
      },
      "ScriptLocationString": {
        "type": "string",
        "maxLength": 400000
      },
      "PythonVersionString": {
        "type": "string",
        "pattern": "^([2-3]|3[.]9)$"
      },
      "RuntimeNameString": {
        "type": "string",
        "pattern": ".*",
        "maxLength": 64
      },
      "GenericMap": {
        "type": "object",
        "additionalProperties": {
          "$ref": "#/$defs/GenericString"
        }
      },
      "ConnectionsList": {
        "type": "object",
        "properties": {
          "Connections": {
            "allOf": [
              {
                "$ref": "#/$defs/OrchestrationStringList"
              },
              {
                "description": "A list of connections used by the job."
              }
            ]
          }
        },
        "description": "Specifies the connections used by a job."
      },
      "OrchestrationStringList": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/GenericString"
        }
      },
      "MaxRetries": {
        "type": "integer"
      },
      "IntegerValue": {
        "type": "integer"
      },
      "Timeout": {
        "type": "integer",
        "minimum": 1
      },
      "NullableDouble": {
        "type": "number",
        "format": "double"
      },
      "TagsMap": {
        "type": "object",
        "minProperties": 0,
        "maxProperties": 50,
        "additionalProperties": {
          "$ref": "#/$defs/TagValue"
        }
      },
      "TagValue": {
        "type": "string",
        "minLength": 0,
        "maxLength": 256
      },
      "NotificationProperty": {
        "type": "object",
        "properties": {
          "NotifyDelayAfter": {
            "allOf": [
              {
                "$ref": "#/$defs/NotifyDelayAfter"
              },
              {
                "description": "After a job run starts, the number of minutes to wait before sending a job run delay notification."
              }
            ]
          }
        },
        "description": "Specifies configuration properties of a notification."
      },
      "NotifyDelayAfter": {
        "type": "integer",
        "minimum": 1
      },
      "GlueVersionString": {
        "type": "string",
        "pattern": "^\\w+\\.\\w+$",
        "minLength": 1,
        "maxLength": 255
      },
      "NullableInteger": {
        "type": "integer"
      },
      "WorkerType": {
        "type": "string",
        "enum": [
          "Standard",
          "G.1X",
          "G.2X",
          "G.025X",
          "G.4X",
          "G.8X",
          "Z.2X"
        ]
      },
      "CodeGenConfigurationNodes": {
        "type": "object",
        "additionalProperties": {
          "$ref": "#/$defs/CodeGenConfigurationNode"
        }
      },
      "CodeGenConfigurationNode": {
        "type": "object",
        "properties": {
          "AthenaConnectorSource": {
            "allOf": [
              {
                "$ref": "#/$defs/AthenaConnectorSource"
              },
              {
                "description": "Specifies a connector to an Amazon Athena data source."
              }
            ]
          },
          "JDBCConnectorSource": {
            "allOf": [
              {
                "$ref": "#/$defs/JDBCConnectorSource"
              },
              {
                "description": "Specifies a connector to a JDBC data source."
              }
            ]
          },
          "SparkConnectorSource": {
            "allOf": [
              {
                "$ref": "#/$defs/SparkConnectorSource"
              },
              {
                "description": "Specifies a connector to an Apache Spark data source."
              }
            ]
          },
          "CatalogSource": {
            "allOf": [
              {
                "$ref": "#/$defs/CatalogSource"
              },
              {
                "description": "Specifies a data store in the Glue Data Catalog."
              }
            ]
          },
          "RedshiftSource": {
            "allOf": [
              {
                "$ref": "#/$defs/RedshiftSource"
              },
              {
                "description": "Specifies an Amazon Redshift data store."
              }
            ]
          },
          "S3CatalogSource": {
            "allOf": [
              {
                "$ref": "#/$defs/S3CatalogSource"
              },
              {
                "description": "Specifies an Amazon S3 data store in the Glue Data Catalog."
              }
            ]
          },
          "S3CsvSource": {
            "allOf": [
              {
                "$ref": "#/$defs/S3CsvSource"
              },
              {
                "description": "Specifies a command-separated value (CSV) data store stored in Amazon S3."
              }
            ]
          },
          "S3JsonSource": {
            "allOf": [
              {
                "$ref": "#/$defs/S3JsonSource"
              },
              {
                "description": "Specifies a JSON data store stored in Amazon S3."
              }
            ]
          },
          "S3ParquetSource": {
            "allOf": [
              {
                "$ref": "#/$defs/S3ParquetSource"
              },
              {
                "description": "Specifies an Apache Parquet data store stored in Amazon S3."
              }
            ]
          },
          "RelationalCatalogSource": {
            "allOf": [
              {
                "$ref": "#/$defs/RelationalCatalogSource"
              },
              {
                "description": "Specifies a relational catalog data store in the Glue Data Catalog."
              }
            ]
          },
          "DynamoDBCatalogSource": {
            "allOf": [
              {
                "$ref": "#/$defs/DynamoDBCatalogSource"
              },
              {
                "description": "Specifies a DynamoDBC Catalog data store in the Glue Data Catalog."
              }
            ]
          },
          "JDBCConnectorTarget": {
            "allOf": [
              {
                "$ref": "#/$defs/JDBCConnectorTarget"
              },
              {
                "description": "Specifies a data target that writes to Amazon S3 in Apache Parquet columnar storage."
              }
            ]
          },
          "SparkConnectorTarget": {
            "allOf": [
              {
                "$ref": "#/$defs/SparkConnectorTarget"
              },
              {
                "description": "Specifies a target that uses an Apache Spark connector."
              }
            ]
          },
          "CatalogTarget": {
            "allOf": [
              {
                "$ref": "#/$defs/BasicCatalogTarget"
              },
              {
                "description": "Specifies a target that uses a Glue Data Catalog table."
              }
            ]
          },
          "RedshiftTarget": {
            "allOf": [
              {
                "$ref": "#/$defs/RedshiftTarget"
              },
              {
                "description": "Specifies a target that uses Amazon Redshift."
              }
            ]
          },
          "S3CatalogTarget": {
            "allOf": [
              {
                "$ref": "#/$defs/S3CatalogTarget"
              },
              {
                "description": "Specifies a data target that writes to Amazon S3 using the Glue Data Catalog."
              }
            ]
          },
          "S3GlueParquetTarget": {
            "allOf": [
              {
                "$ref": "#/$defs/S3GlueParquetTarget"
              },
              {
                "description": "Specifies a data target that writes to Amazon S3 in Apache Parquet columnar storage."
              }
            ]
          },
          "S3DirectTarget": {
            "allOf": [
              {
                "$ref": "#/$defs/S3DirectTarget"
              },
              {
                "description": "Specifies a data target that writes to Amazon S3."
              }
            ]
          },
          "ApplyMapping": {
            "allOf": [
              {
                "$ref": "#/$defs/ApplyMapping"
              },
              {
                "description": "Specifies a transform that maps data property keys in the data source to data property keys in the data target. You can rename keys, modify the data types for keys, and choose which keys to drop from the dataset."
              }
            ]
          },
          "SelectFields": {
            "allOf": [
              {
                "$ref": "#/$defs/SelectFields"
              },
              {
                "description": "Specifies a transform that chooses the data property keys that you want to keep."
              }
            ]
          },
          "DropFields": {
            "allOf": [
              {
                "$ref": "#/$defs/DropFields"
              },
              {
                "description": "Specifies a transform that chooses the data property keys that you want to drop."
              }
            ]
          },
          "RenameField": {
            "allOf": [
              {
                "$ref": "#/$defs/RenameField"
              },
              {
                "description": "Specifies a transform that renames a single data property key."
              }
            ]
          },
          "Spigot": {
            "allOf": [
              {
                "$ref": "#/$defs/Spigot"
              },
              {
                "description": "Specifies a transform that writes samples of the data to an Amazon S3 bucket."
              }
            ]
          },
          "Join": {
            "allOf": [
              {
                "$ref": "#/$defs/Join"
              },
              {
                "description": "Specifies a transform that joins two datasets into one dataset using a comparison phrase on the specified data property keys. You can use inner, outer, left, right, left semi, and left anti joins."
              }
            ]
          },
          "SplitFields": {
            "allOf": [
              {
                "$ref": "#/$defs/SplitFields"
              },
              {
                "description": "Specifies a transform that splits data property keys into two <code>DynamicFrames</code>. The output is a collection of <code>DynamicFrames</code>: one with selected data property keys, and one with the remaining data property keys."
              }
            ]
          },
          "SelectFromCollection": {
            "allOf": [
              {
                "$ref": "#/$defs/SelectFromCollection"
              },
              {
                "description": "Specifies a transform that chooses one <code>DynamicFrame</code> from a collection of <code>DynamicFrames</code>. The output is the selected <code>DynamicFrame</code> "
              }
            ]
          },
          "FillMissingValues": {
            "allOf": [
              {
                "$ref": "#/$defs/FillMissingValues"
              },
              {
                "description": "Specifies a transform that locates records in the dataset that have missing values and adds a new field with a value determined by imputation. The input data set is used to train the machine learning model that determines what the missing value should be."
              }
            ]
          },
          "Filter": {
            "allOf": [
              {
                "$ref": "#/$defs/Filter"
              },
              {
                "description": "Specifies a transform that splits a dataset into two, based on a filter condition."
              }
            ]
          },
          "CustomCode": {
            "allOf": [
              {
                "$ref": "#/$defs/CustomCode"
              },
              {
                "description": "Specifies a transform that uses custom code you provide to perform the data transformation. The output is a collection of DynamicFrames."
              }
            ]
          },
          "SparkSQL": {
            "allOf": [
              {
                "$ref": "#/$defs/SparkSQL"
              },
              {
                "description": "Specifies a transform where you enter a SQL query using Spark SQL syntax to transform the data. The output is a single <code>DynamicFrame</code>."
              }
            ]
          },
          "DirectKinesisSource": {
            "allOf": [
              {
                "$ref": "#/$defs/DirectKinesisSource"
              },
              {
                "description": "Specifies a direct Amazon Kinesis data source."
              }
            ]
          },
          "DirectKafkaSource": {
            "allOf": [
              {
                "$ref": "#/$defs/DirectKafkaSource"
              },
              {
                "description": "Specifies an Apache Kafka data store."
              }
            ]
          },
          "CatalogKinesisSource": {
            "allOf": [
              {
                "$ref": "#/$defs/CatalogKinesisSource"
              },
              {
                "description": "Specifies a Kinesis data source in the Glue Data Catalog."
              }
            ]
          },
          "CatalogKafkaSource": {
            "allOf": [
              {
                "$ref": "#/$defs/CatalogKafkaSource"
              },
              {
                "description": "Specifies an Apache Kafka data store in the Data Catalog."
              }
            ]
          },
          "DropNullFields": {
            "allOf": [
              {
                "$ref": "#/$defs/DropNullFields"
              },
              {
                "description": "Specifies a transform that removes columns from the dataset if all values in the column are 'null'. By default, Glue Studio will recognize null objects, but some values such as empty strings, strings that are \"null\", -1 integers or other placeholders such as zeros, are not automatically recognized as nulls."
              }
            ]
          },
          "Merge": {
            "allOf": [
              {
                "$ref": "#/$defs/Merge"
              },
              {
                "description": "Specifies a transform that merges a <code>DynamicFrame</code> with a staging <code>DynamicFrame</code> based on the specified primary keys to identify records. Duplicate records (records with the same primary keys) are not de-duplicated. "
              }
            ]
          },
          "Union": {
            "allOf": [
              {
                "$ref": "#/$defs/Union"
              },
              {
                "description": "Specifies a transform that combines the rows from two or more datasets into a single result."
              }
            ]
          },
          "PIIDetection": {
            "allOf": [
              {
                "$ref": "#/$defs/PIIDetection"
              },
              {
                "description": "Specifies a transform that identifies, removes or masks PII data."
              }
            ]
          },
          "Aggregate": {
            "allOf": [
              {
                "$ref": "#/$defs/Aggregate"
              },
              {
                "description": "Specifies a transform that groups rows by chosen fields and computes the aggregated value by specified function."
              }
            ]
          },
          "DropDuplicates": {
            "allOf": [
              {
                "$ref": "#/$defs/DropDuplicates"
              },
              {
                "description": "Specifies a transform that removes rows of repeating data from a data set."
              }
            ]
          },
          "GovernedCatalogTarget": {
            "allOf": [
              {
                "$ref": "#/$defs/GovernedCatalogTarget"
              },
              {
                "description": "Specifies a data target that writes to a goverened catalog."
              }
            ]
          },
          "GovernedCatalogSource": {
            "allOf": [
              {
                "$ref": "#/$defs/GovernedCatalogSource"
              },
              {
                "description": "Specifies a data source in a goverened Data Catalog."
              }
            ]
          },
          "MicrosoftSQLServerCatalogSource": {
            "allOf": [
              {
                "$ref": "#/$defs/MicrosoftSQLServerCatalogSource"
              },
              {
                "description": "Specifies a Microsoft SQL server data source in the Glue Data Catalog."
              }
            ]
          },
          "MySQLCatalogSource": {
            "allOf": [
              {
                "$ref": "#/$defs/MySQLCatalogSource"
              },
              {
                "description": "Specifies a MySQL data source in the Glue Data Catalog."
              }
            ]
          },
          "OracleSQLCatalogSource": {
            "allOf": [
              {
                "$ref": "#/$defs/OracleSQLCatalogSource"
              },
              {
                "description": "Specifies an Oracle data source in the Glue Data Catalog."
              }
            ]
          },
          "PostgreSQLCatalogSource": {
            "allOf": [
              {
                "$ref": "#/$defs/PostgreSQLCatalogSource"
              },
              {
                "description": "Specifies a PostgresSQL data source in the Glue Data Catalog."
              }
            ]
          },
          "MicrosoftSQLServerCatalogTarget": {
            "allOf": [
              {
                "$ref": "#/$defs/MicrosoftSQLServerCatalogTarget"
              },
              {
                "description": "Specifies a target that uses Microsoft SQL."
              }
            ]
          },
          "MySQLCatalogTarget": {
            "allOf": [
              {
                "$ref": "#/$defs/MySQLCatalogTarget"
              },
              {
                "description": "Specifies a target that uses MySQL."
              }
            ]
          },
          "OracleSQLCatalogTarget": {
            "allOf": [
              {
                "$ref": "#/$defs/OracleSQLCatalogTarget"
              },
              {
                "description": "Specifies a target that uses Oracle SQL."
              }
            ]
          },
          "PostgreSQLCatalogTarget": {
            "allOf": [
              {
                "$ref": "#/$defs/PostgreSQLCatalogTarget"
              },
              {
                "description": "Specifies a target that uses Postgres SQL."
              }
            ]
          },
          "DynamicTransform": {
            "allOf": [
              {
                "$ref": "#/$defs/DynamicTransform"
              },
              {
                "description": "Specifies a custom visual transform created by a user."
              }
            ]
          },
          "EvaluateDataQuality": {
            "allOf": [
              {
                "$ref": "#/$defs/EvaluateDataQuality"
              },
              {
                "description": "Specifies your data quality evaluation criteria."
              }
            ]
          },
          "S3CatalogHudiSource": {
            "allOf": [
              {
                "$ref": "#/$defs/S3CatalogHudiSource"
              },
              {
                "description": "Specifies a Hudi data source that is registered in the Glue Data Catalog. The data source must be stored in Amazon S3."
              }
            ]
          },
          "CatalogHudiSource": {
            "allOf": [
              {
                "$ref": "#/$defs/CatalogHudiSource"
              },
              {
                "description": "Specifies a Hudi data source that is registered in the Glue Data Catalog."
              }
            ]
          },
          "S3HudiSource": {
            "allOf": [
              {
                "$ref": "#/$defs/S3HudiSource"
              },
              {
                "description": "Specifies a Hudi data source stored in Amazon S3."
              }
            ]
          },
          "S3HudiCatalogTarget": {
            "allOf": [
              {
                "$ref": "#/$defs/S3HudiCatalogTarget"
              },
              {
                "description": "Specifies a target that writes to a Hudi data source in the Glue Data Catalog."
              }
            ]
          },
          "S3HudiDirectTarget": {
            "allOf": [
              {
                "$ref": "#/$defs/S3HudiDirectTarget"
              },
              {
                "description": "Specifies a target that writes to a Hudi data source in Amazon S3."
              }
            ]
          },
          "DirectJDBCSource": {
            "$ref": "#/$defs/DirectJDBCSource"
          },
          "S3CatalogDeltaSource": {
            "allOf": [
              {
                "$ref": "#/$defs/S3CatalogDeltaSource"
              },
              {
                "description": "Specifies a Delta Lake data source that is registered in the Glue Data Catalog. The data source must be stored in Amazon S3."
              }
            ]
          },
          "CatalogDeltaSource": {
            "allOf": [
              {
                "$ref": "#/$defs/CatalogDeltaSource"
              },
              {
                "description": "Specifies a Delta Lake data source that is registered in the Glue Data Catalog."
              }
            ]
          },
          "S3DeltaSource": {
            "allOf": [
              {
                "$ref": "#/$defs/S3DeltaSource"
              },
              {
                "description": "Specifies a Delta Lake data source stored in Amazon S3."
              }
            ]
          },
          "S3DeltaCatalogTarget": {
            "allOf": [
              {
                "$ref": "#/$defs/S3DeltaCatalogTarget"
              },
              {
                "description": "Specifies a target that writes to a Delta Lake data source in the Glue Data Catalog."
              }
            ]
          },
          "S3DeltaDirectTarget": {
            "allOf": [
              {
                "$ref": "#/$defs/S3DeltaDirectTarget"
              },
              {
                "description": "Specifies a target that writes to a Delta Lake data source in Amazon S3."
              }
            ]
          },
          "AmazonRedshiftSource": {
            "allOf": [
              {
                "$ref": "#/$defs/AmazonRedshiftSource"
              },
              {
                "description": "Specifies a target that writes to a data source in Amazon Redshift."
              }
            ]
          },
          "AmazonRedshiftTarget": {
            "allOf": [
              {
                "$ref": "#/$defs/AmazonRedshiftTarget"
              },
              {
                "description": "Specifies a target that writes to a data target in Amazon Redshift."
              }
            ]
          },
          "EvaluateDataQualityMultiFrame": {
            "allOf": [
              {
                "$ref": "#/$defs/EvaluateDataQualityMultiFrame"
              },
              {
                "description": "Specifies your data quality evaluation criteria. Allows multiple input data and returns a collection of Dynamic Frames."
              }
            ]
          },
          "Recipe": {
            "allOf": [
              {
                "$ref": "#/$defs/Recipe"
              },
              {
                "description": "Specifies a Glue DataBrew recipe node."
              }
            ]
          },
          "SnowflakeSource": {
            "allOf": [
              {
                "$ref": "#/$defs/SnowflakeSource"
              },
              {
                "description": "Specifies a Snowflake data source."
              }
            ]
          },
          "SnowflakeTarget": {
            "allOf": [
              {
                "$ref": "#/$defs/SnowflakeTarget"
              },
              {
                "description": "Specifies a target that writes to a Snowflake data source."
              }
            ]
          }
        },
        "description": " <code>CodeGenConfigurationNode</code> enumerates all valid Node types. One and only one of its member variables can be populated."
      },
      "AthenaConnectorSource": {
        "type": "object",
        "required": [
          "Name",
          "ConnectionName",
          "ConnectorName",
          "ConnectionType",
          "SchemaName"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the data source."
              }
            ]
          },
          "ConnectionName": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the connection that is associated with the connector."
              }
            ]
          },
          "ConnectorName": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of a connector that assists with accessing the data store in Glue Studio."
              }
            ]
          },
          "ConnectionType": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The type of connection, such as marketplace.athena or custom.athena, designating a connection to an Amazon Athena data store."
              }
            ]
          },
          "ConnectionTable": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringPropertyWithQuote"
              },
              {
                "description": "The name of the table in the data source."
              }
            ]
          },
          "SchemaName": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the Cloudwatch log group to read from. For example, <code>/aws-glue/jobs/output</code>."
              }
            ]
          },
          "OutputSchemas": {
            "allOf": [
              {
                "$ref": "#/$defs/GlueSchemas"
              },
              {
                "description": "Specifies the data schema for the custom Athena source."
              }
            ]
          }
        },
        "description": "Specifies a connector to an Amazon Athena data source."
      },
      "NodeName": {
        "type": "string",
        "x-pattern": "\\([\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF]\\|[^\\r\\n]\\)*"
      },
      "EnclosedInStringProperty": {
        "type": "string",
        "x-pattern": "\\([\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF]\\|[^\\S\\r\\n\"']\\)*"
      },
      "EnclosedInStringPropertyWithQuote": {
        "type": "string",
        "x-pattern": "\\([\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF]\\|[^\\S\\r\\n]\\)*"
      },
      "GlueSchemas": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/GlueSchema"
        }
      },
      "GlueSchema": {
        "type": "object",
        "properties": {
          "Columns": {
            "allOf": [
              {
                "$ref": "#/$defs/GlueStudioSchemaColumnList"
              },
              {
                "description": "Specifies the column definitions that make up a Glue schema."
              }
            ]
          }
        },
        "description": "Specifies a user-defined schema when a schema cannot be determined by Glue."
      },
      "GlueStudioSchemaColumnList": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/GlueStudioSchemaColumn"
        }
      },
      "GlueStudioSchemaColumn": {
        "type": "object",
        "required": [
          "Name"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/GlueStudioColumnNameString"
              },
              {
                "description": "The name of the column in the Glue Studio schema."
              }
            ]
          },
          "Type": {
            "allOf": [
              {
                "$ref": "#/$defs/ColumnTypeString"
              },
              {
                "description": "The hive type for this column in the Glue Studio schema."
              }
            ]
          }
        },
        "description": "Specifies a single column in a Glue schema definition."
      },
      "GlueStudioColumnNameString": {
        "type": "string",
        "minLength": 0,
        "maxLength": 1024,
        "x-pattern": "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*"
      },
      "ColumnTypeString": {
        "type": "string",
        "minLength": 0,
        "maxLength": 131072,
        "x-pattern": "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*"
      },
      "JDBCConnectorSource": {
        "type": "object",
        "required": [
          "Name",
          "ConnectionName",
          "ConnectorName",
          "ConnectionType"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the data source."
              }
            ]
          },
          "ConnectionName": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the connection that is associated with the connector."
              }
            ]
          },
          "ConnectorName": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of a connector that assists with accessing the data store in Glue Studio."
              }
            ]
          },
          "ConnectionType": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The type of connection, such as marketplace.jdbc or custom.jdbc, designating a connection to a JDBC data store."
              }
            ]
          },
          "AdditionalOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/JDBCConnectorOptions"
              },
              {
                "description": "Additional connection options for the connector."
              }
            ]
          },
          "ConnectionTable": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringPropertyWithQuote"
              },
              {
                "description": "The name of the table in the data source."
              }
            ]
          },
          "Query": {
            "allOf": [
              {
                "$ref": "#/$defs/SqlQuery"
              },
              {
                "description": "The table or SQL query to get the data from. You can specify either <code>ConnectionTable</code> or <code>query</code>, but not both."
              }
            ]
          },
          "OutputSchemas": {
            "allOf": [
              {
                "$ref": "#/$defs/GlueSchemas"
              },
              {
                "description": "Specifies the data schema for the custom JDBC source."
              }
            ]
          }
        },
        "description": "Specifies a connector to a JDBC data source."
      },
      "JDBCConnectorOptions": {
        "type": "object",
        "properties": {
          "FilterPredicate": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "<p>Extra condition clause to filter data from source. For example:</p> <p> <code>BillingCity='Mountain View'</code> </p> <p>When using a query instead of a table name, you should validate that the query works with the specified <code>filterPredicate</code>.</p>"
              }
            ]
          },
          "PartitionColumn": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of an integer column that is used for partitioning. This option works only when it's included with <code>lowerBound</code>, <code>upperBound</code>, and <code>numPartitions</code>. This option works the same way as in the Spark SQL JDBC reader."
              }
            ]
          },
          "LowerBound": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedNonNegativeLong"
              },
              {
                "description": "The minimum value of <code>partitionColumn</code> that is used to decide partition stride."
              }
            ]
          },
          "UpperBound": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedNonNegativeLong"
              },
              {
                "description": "The maximum value of <code>partitionColumn</code> that is used to decide partition stride."
              }
            ]
          },
          "NumPartitions": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedNonNegativeLong"
              },
              {
                "description": "The number of partitions. This value, along with <code>lowerBound</code> (inclusive) and <code>upperBound</code> (exclusive), form partition strides for generated <code>WHERE</code> clause expressions that are used to split the <code>partitionColumn</code>."
              }
            ]
          },
          "JobBookmarkKeys": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperties"
              },
              {
                "description": "The name of the job bookmark keys on which to sort."
              }
            ]
          },
          "JobBookmarkKeysSortOrder": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "Specifies an ascending or descending sort order."
              }
            ]
          },
          "DataTypeMapping": {
            "allOf": [
              {
                "$ref": "#/$defs/JDBCDataTypeMapping"
              },
              {
                "description": "Custom data type mapping that builds a mapping from a JDBC data type to an Glue data type. For example, the option <code>\"dataTypeMapping\":{\"FLOAT\":\"STRING\"}</code> maps data fields of JDBC type <code>FLOAT</code> into the Java <code>String</code> type by calling the <code>ResultSet.getString()</code> method of the driver, and uses it to build the Glue record. The <code>ResultSet</code> object is implemented by each driver, so the behavior is specific to the driver you use. Refer to the documentation for your JDBC driver to understand how the driver performs the conversions."
              }
            ]
          }
        },
        "description": "Additional connection options for the connector."
      },
      "BoxedNonNegativeLong": {
        "type": "integer",
        "minimum": 0
      },
      "EnclosedInStringProperties": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/EnclosedInStringProperty"
        }
      },
      "JDBCDataTypeMapping": {
        "type": "object",
        "additionalProperties": {
          "$ref": "#/$defs/GlueRecordType"
        }
      },
      "GlueRecordType": {
        "type": "string",
        "enum": [
          "DATE",
          "STRING",
          "TIMESTAMP",
          "INT",
          "FLOAT",
          "LONG",
          "BIGDECIMAL",
          "BYTE",
          "SHORT",
          "DOUBLE"
        ]
      },
      "SqlQuery": {
        "type": "string",
        "x-pattern": "\\([\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\s]\\)*"
      },
      "SparkConnectorSource": {
        "type": "object",
        "required": [
          "Name",
          "ConnectionName",
          "ConnectorName",
          "ConnectionType"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the data source."
              }
            ]
          },
          "ConnectionName": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the connection that is associated with the connector."
              }
            ]
          },
          "ConnectorName": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of a connector that assists with accessing the data store in Glue Studio."
              }
            ]
          },
          "ConnectionType": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The type of connection, such as marketplace.spark or custom.spark, designating a connection to an Apache Spark data store."
              }
            ]
          },
          "AdditionalOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/AdditionalOptions"
              },
              {
                "description": "Additional connection options for the connector."
              }
            ]
          },
          "OutputSchemas": {
            "allOf": [
              {
                "$ref": "#/$defs/GlueSchemas"
              },
              {
                "description": "Specifies data schema for the custom spark source."
              }
            ]
          }
        },
        "description": "Specifies a connector to an Apache Spark data source."
      },
      "AdditionalOptions": {
        "type": "object",
        "additionalProperties": {
          "$ref": "#/$defs/EnclosedInStringProperty"
        }
      },
      "CatalogSource": {
        "type": "object",
        "required": [
          "Name",
          "Database",
          "Table"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the data store."
              }
            ]
          },
          "Database": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the database to read from."
              }
            ]
          },
          "Table": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the table in the database to read from."
              }
            ]
          }
        },
        "description": "Specifies a data store in the Glue Data Catalog."
      },
      "RedshiftSource": {
        "type": "object",
        "required": [
          "Name",
          "Database",
          "Table"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the Amazon Redshift data store."
              }
            ]
          },
          "Database": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The database to read from."
              }
            ]
          },
          "Table": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The database table to read from."
              }
            ]
          },
          "RedshiftTmpDir": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The Amazon S3 path where temporary data can be staged when copying out of the database."
              }
            ]
          },
          "TmpDirIAMRole": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The IAM role with permissions."
              }
            ]
          }
        },
        "description": "Specifies an Amazon Redshift data store."
      },
      "S3CatalogSource": {
        "type": "object",
        "required": [
          "Name",
          "Database",
          "Table"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the data store."
              }
            ]
          },
          "Database": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The database to read from."
              }
            ]
          },
          "Table": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The database table to read from."
              }
            ]
          },
          "PartitionPredicate": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "Partitions satisfying this predicate are deleted. Files within the retention period in these partitions are not deleted. Set to <code>\"\"</code> – empty by default."
              }
            ]
          },
          "AdditionalOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/S3SourceAdditionalOptions"
              },
              {
                "description": "Specifies additional connection options."
              }
            ]
          }
        },
        "description": "Specifies an Amazon S3 data store in the Glue Data Catalog."
      },
      "S3SourceAdditionalOptions": {
        "type": "object",
        "properties": {
          "BoundedSize": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedLong"
              },
              {
                "description": "Sets the upper limit for the target size of the dataset in bytes that will be processed."
              }
            ]
          },
          "BoundedFiles": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedLong"
              },
              {
                "description": "Sets the upper limit for the target number of files that will be processed."
              }
            ]
          }
        },
        "description": "Specifies additional connection options for the Amazon S3 data store."
      },
      "BoxedLong": {
        "type": "integer"
      },
      "S3CsvSource": {
        "type": "object",
        "required": [
          "Name",
          "Paths",
          "Separator",
          "QuoteChar"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the data store."
              }
            ]
          },
          "Paths": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperties"
              },
              {
                "description": "A list of the Amazon S3 paths to read from."
              }
            ]
          },
          "CompressionType": {
            "allOf": [
              {
                "$ref": "#/$defs/CompressionType"
              },
              {
                "description": "Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are <code>\"gzip\"</code> and <code>\"bzip\"</code>)."
              }
            ]
          },
          "Exclusions": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperties"
              },
              {
                "description": "A string containing a JSON list of Unix-style glob patterns to exclude. For example, \"[\\\"**.pdf\\\"]\" excludes all PDF files. "
              }
            ]
          },
          "GroupSize": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The target group size in bytes. The default is computed based on the input data size and the size of your cluster. When there are fewer than 50,000 input files, <code>\"groupFiles\"</code> must be set to <code>\"inPartition\"</code> for this to take effect."
              }
            ]
          },
          "GroupFiles": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "Grouping files is turned on by default when the input contains more than 50,000 files. To turn on grouping with fewer than 50,000 files, set this parameter to \"inPartition\". To disable grouping when there are more than 50,000 files, set this parameter to <code>\"none\"</code>."
              }
            ]
          },
          "Recurse": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedBoolean"
              },
              {
                "description": "If set to true, recursively reads files in all subdirectories under the specified paths."
              }
            ]
          },
          "MaxBand": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedNonNegativeInt"
              },
              {
                "description": "This option controls the duration in milliseconds after which the s3 listing is likely to be consistent. Files with modification timestamps falling within the last maxBand milliseconds are tracked specially when using JobBookmarks to account for Amazon S3 eventual consistency. Most users don't need to set this option. The default is 900000 milliseconds, or 15 minutes."
              }
            ]
          },
          "MaxFilesInBand": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedNonNegativeInt"
              },
              {
                "description": "This option specifies the maximum number of files to save from the last maxBand seconds. If this number is exceeded, extra files are skipped and only processed in the next job run."
              }
            ]
          },
          "AdditionalOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/S3DirectSourceAdditionalOptions"
              },
              {
                "description": "Specifies additional connection options."
              }
            ]
          },
          "Separator": {
            "allOf": [
              {
                "$ref": "#/$defs/Separator"
              },
              {
                "description": "Specifies the delimiter character. The default is a comma: \",\", but any other character can be specified."
              }
            ]
          },
          "Escaper": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringPropertyWithQuote"
              },
              {
                "description": "Specifies a character to use for escaping. This option is used only when reading CSV files. The default value is <code>none</code>. If enabled, the character which immediately follows is used as-is, except for a small set of well-known escapes (<code>\\n</code>, <code>\\r</code>, <code>\\t</code>, and <code>\\0</code>)."
              }
            ]
          },
          "QuoteChar": {
            "allOf": [
              {
                "$ref": "#/$defs/QuoteChar"
              },
              {
                "description": "Specifies the character to use for quoting. The default is a double quote: <code>'\"'</code>. Set this to <code>-1</code> to turn off quoting entirely."
              }
            ]
          },
          "Multiline": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedBoolean"
              },
              {
                "description": "A Boolean value that specifies whether a single record can span multiple lines. This can occur when a field contains a quoted new-line character. You must set this option to True if any record spans multiple lines. The default value is <code>False</code>, which allows for more aggressive file-splitting during parsing."
              }
            ]
          },
          "WithHeader": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedBoolean"
              },
              {
                "description": "A Boolean value that specifies whether to treat the first line as a header. The default value is <code>False</code>."
              }
            ]
          },
          "WriteHeader": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedBoolean"
              },
              {
                "description": "A Boolean value that specifies whether to write the header to output. The default value is <code>True</code>. "
              }
            ]
          },
          "SkipFirst": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedBoolean"
              },
              {
                "description": "A Boolean value that specifies whether to skip the first data line. The default value is <code>False</code>."
              }
            ]
          },
          "OptimizePerformance": {
            "allOf": [
              {
                "$ref": "#/$defs/BooleanValue"
              },
              {
                "description": "A Boolean value that specifies whether to use the advanced SIMD CSV reader along with Apache Arrow based columnar memory formats. Only available in Glue version 3.0."
              }
            ]
          },
          "OutputSchemas": {
            "allOf": [
              {
                "$ref": "#/$defs/GlueSchemas"
              },
              {
                "description": "Specifies the data schema for the S3 CSV source."
              }
            ]
          }
        },
        "description": "Specifies a command-separated value (CSV) data store stored in Amazon S3."
      },
      "CompressionType": {
        "type": "string",
        "enum": [
          "gzip",
          "bzip2"
        ]
      },
      "BoxedBoolean": {
        "type": "boolean"
      },
      "BoxedNonNegativeInt": {
        "type": "integer",
        "minimum": 0
      },
      "S3DirectSourceAdditionalOptions": {
        "type": "object",
        "properties": {
          "BoundedSize": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedLong"
              },
              {
                "description": "Sets the upper limit for the target size of the dataset in bytes that will be processed."
              }
            ]
          },
          "BoundedFiles": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedLong"
              },
              {
                "description": "Sets the upper limit for the target number of files that will be processed."
              }
            ]
          },
          "EnableSamplePath": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedBoolean"
              },
              {
                "description": "Sets option to enable a sample path."
              }
            ]
          },
          "SamplePath": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "If enabled, specifies the sample path."
              }
            ]
          }
        },
        "description": "Specifies additional connection options for the Amazon S3 data store."
      },
      "Separator": {
        "type": "string",
        "enum": [
          "comma",
          "ctrla",
          "pipe",
          "semicolon",
          "tab"
        ]
      },
      "QuoteChar": {
        "type": "string",
        "enum": [
          "quote",
          "quillemet",
          "single_quote",
          "disabled"
        ]
      },
      "BooleanValue": {
        "type": "boolean"
      },
      "S3JsonSource": {
        "type": "object",
        "required": [
          "Name",
          "Paths"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the data store."
              }
            ]
          },
          "Paths": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperties"
              },
              {
                "description": "A list of the Amazon S3 paths to read from."
              }
            ]
          },
          "CompressionType": {
            "allOf": [
              {
                "$ref": "#/$defs/CompressionType"
              },
              {
                "description": "Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are <code>\"gzip\"</code> and <code>\"bzip\"</code>)."
              }
            ]
          },
          "Exclusions": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperties"
              },
              {
                "description": "A string containing a JSON list of Unix-style glob patterns to exclude. For example, \"[\\\"**.pdf\\\"]\" excludes all PDF files. "
              }
            ]
          },
          "GroupSize": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The target group size in bytes. The default is computed based on the input data size and the size of your cluster. When there are fewer than 50,000 input files, <code>\"groupFiles\"</code> must be set to <code>\"inPartition\"</code> for this to take effect."
              }
            ]
          },
          "GroupFiles": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "Grouping files is turned on by default when the input contains more than 50,000 files. To turn on grouping with fewer than 50,000 files, set this parameter to \"inPartition\". To disable grouping when there are more than 50,000 files, set this parameter to <code>\"none\"</code>."
              }
            ]
          },
          "Recurse": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedBoolean"
              },
              {
                "description": "If set to true, recursively reads files in all subdirectories under the specified paths."
              }
            ]
          },
          "MaxBand": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedNonNegativeInt"
              },
              {
                "description": "This option controls the duration in milliseconds after which the s3 listing is likely to be consistent. Files with modification timestamps falling within the last maxBand milliseconds are tracked specially when using JobBookmarks to account for Amazon S3 eventual consistency. Most users don't need to set this option. The default is 900000 milliseconds, or 15 minutes."
              }
            ]
          },
          "MaxFilesInBand": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedNonNegativeInt"
              },
              {
                "description": "This option specifies the maximum number of files to save from the last maxBand seconds. If this number is exceeded, extra files are skipped and only processed in the next job run."
              }
            ]
          },
          "AdditionalOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/S3DirectSourceAdditionalOptions"
              },
              {
                "description": "Specifies additional connection options."
              }
            ]
          },
          "JsonPath": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "A JsonPath string defining the JSON data."
              }
            ]
          },
          "Multiline": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedBoolean"
              },
              {
                "description": "A Boolean value that specifies whether a single record can span multiple lines. This can occur when a field contains a quoted new-line character. You must set this option to True if any record spans multiple lines. The default value is <code>False</code>, which allows for more aggressive file-splitting during parsing."
              }
            ]
          },
          "OutputSchemas": {
            "allOf": [
              {
                "$ref": "#/$defs/GlueSchemas"
              },
              {
                "description": "Specifies the data schema for the S3 JSON source."
              }
            ]
          }
        },
        "description": "Specifies a JSON data store stored in Amazon S3."
      },
      "S3ParquetSource": {
        "type": "object",
        "required": [
          "Name",
          "Paths"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the data store."
              }
            ]
          },
          "Paths": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperties"
              },
              {
                "description": "A list of the Amazon S3 paths to read from."
              }
            ]
          },
          "CompressionType": {
            "allOf": [
              {
                "$ref": "#/$defs/ParquetCompressionType"
              },
              {
                "description": "Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are <code>\"gzip\"</code> and <code>\"bzip\"</code>)."
              }
            ]
          },
          "Exclusions": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperties"
              },
              {
                "description": "A string containing a JSON list of Unix-style glob patterns to exclude. For example, \"[\\\"**.pdf\\\"]\" excludes all PDF files. "
              }
            ]
          },
          "GroupSize": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The target group size in bytes. The default is computed based on the input data size and the size of your cluster. When there are fewer than 50,000 input files, <code>\"groupFiles\"</code> must be set to <code>\"inPartition\"</code> for this to take effect."
              }
            ]
          },
          "GroupFiles": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "Grouping files is turned on by default when the input contains more than 50,000 files. To turn on grouping with fewer than 50,000 files, set this parameter to \"inPartition\". To disable grouping when there are more than 50,000 files, set this parameter to <code>\"none\"</code>."
              }
            ]
          },
          "Recurse": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedBoolean"
              },
              {
                "description": "If set to true, recursively reads files in all subdirectories under the specified paths."
              }
            ]
          },
          "MaxBand": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedNonNegativeInt"
              },
              {
                "description": "This option controls the duration in milliseconds after which the s3 listing is likely to be consistent. Files with modification timestamps falling within the last maxBand milliseconds are tracked specially when using JobBookmarks to account for Amazon S3 eventual consistency. Most users don't need to set this option. The default is 900000 milliseconds, or 15 minutes."
              }
            ]
          },
          "MaxFilesInBand": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedNonNegativeInt"
              },
              {
                "description": "This option specifies the maximum number of files to save from the last maxBand seconds. If this number is exceeded, extra files are skipped and only processed in the next job run."
              }
            ]
          },
          "AdditionalOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/S3DirectSourceAdditionalOptions"
              },
              {
                "description": "Specifies additional connection options."
              }
            ]
          },
          "OutputSchemas": {
            "allOf": [
              {
                "$ref": "#/$defs/GlueSchemas"
              },
              {
                "description": "Specifies the data schema for the S3 Parquet source."
              }
            ]
          }
        },
        "description": "Specifies an Apache Parquet data store stored in Amazon S3."
      },
      "ParquetCompressionType": {
        "type": "string",
        "enum": [
          "snappy",
          "lzo",
          "gzip",
          "uncompressed",
          "none"
        ]
      },
      "RelationalCatalogSource": {
        "type": "object",
        "required": [
          "Name",
          "Database",
          "Table"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the data source."
              }
            ]
          },
          "Database": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the database to read from."
              }
            ]
          },
          "Table": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the table in the database to read from."
              }
            ]
          }
        },
        "description": "Specifies a Relational database data source in the Glue Data Catalog."
      },
      "DynamoDBCatalogSource": {
        "type": "object",
        "required": [
          "Name",
          "Database",
          "Table"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the data source."
              }
            ]
          },
          "Database": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the database to read from."
              }
            ]
          },
          "Table": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the table in the database to read from."
              }
            ]
          }
        },
        "description": "Specifies a DynamoDB data source in the Glue Data Catalog."
      },
      "JDBCConnectorTarget": {
        "type": "object",
        "required": [
          "Name",
          "Inputs",
          "ConnectionName",
          "ConnectionTable",
          "ConnectorName",
          "ConnectionType"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the data target."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/OneInput"
              },
              {
                "description": "The nodes that are inputs to the data target."
              }
            ]
          },
          "ConnectionName": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the connection that is associated with the connector."
              }
            ]
          },
          "ConnectionTable": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringPropertyWithQuote"
              },
              {
                "description": "The name of the table in the data target."
              }
            ]
          },
          "ConnectorName": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of a connector that will be used."
              }
            ]
          },
          "ConnectionType": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The type of connection, such as marketplace.jdbc or custom.jdbc, designating a connection to a JDBC data target."
              }
            ]
          },
          "AdditionalOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/AdditionalOptions"
              },
              {
                "description": "Additional connection options for the connector."
              }
            ]
          },
          "OutputSchemas": {
            "allOf": [
              {
                "$ref": "#/$defs/GlueSchemas"
              },
              {
                "description": "Specifies the data schema for the JDBC target."
              }
            ]
          }
        },
        "description": "Specifies a data target that writes to Amazon S3 in Apache Parquet columnar storage."
      },
      "OneInput": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/NodeId"
        },
        "minItems": 1,
        "maxItems": 1
      },
      "NodeId": {
        "type": "string",
        "pattern": "[A-Za-z0-9_-]*"
      },
      "SparkConnectorTarget": {
        "type": "object",
        "required": [
          "Name",
          "Inputs",
          "ConnectionName",
          "ConnectorName",
          "ConnectionType"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the data target."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/OneInput"
              },
              {
                "description": "The nodes that are inputs to the data target."
              }
            ]
          },
          "ConnectionName": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of a connection for an Apache Spark connector."
              }
            ]
          },
          "ConnectorName": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of an Apache Spark connector."
              }
            ]
          },
          "ConnectionType": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The type of connection, such as marketplace.spark or custom.spark, designating a connection to an Apache Spark data store."
              }
            ]
          },
          "AdditionalOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/AdditionalOptions"
              },
              {
                "description": "Additional connection options for the connector."
              }
            ]
          },
          "OutputSchemas": {
            "allOf": [
              {
                "$ref": "#/$defs/GlueSchemas"
              },
              {
                "description": "Specifies the data schema for the custom spark target."
              }
            ]
          }
        },
        "description": "Specifies a target that uses an Apache Spark connector."
      },
      "BasicCatalogTarget": {
        "type": "object",
        "required": [
          "Name",
          "Inputs",
          "Database",
          "Table"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of your data target."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/OneInput"
              },
              {
                "description": "The nodes that are inputs to the data target."
              }
            ]
          },
          "Database": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The database that contains the table you want to use as the target. This database must already exist in the Data Catalog."
              }
            ]
          },
          "Table": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The table that defines the schema of your output data. This table must already exist in the Data Catalog."
              }
            ]
          }
        },
        "description": "Specifies a target that uses a Glue Data Catalog table."
      },
      "RedshiftTarget": {
        "type": "object",
        "required": [
          "Name",
          "Inputs",
          "Database",
          "Table"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the data target."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/OneInput"
              },
              {
                "description": "The nodes that are inputs to the data target."
              }
            ]
          },
          "Database": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the database to write to."
              }
            ]
          },
          "Table": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the table in the database to write to."
              }
            ]
          },
          "RedshiftTmpDir": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The Amazon S3 path where temporary data can be staged when copying out of the database."
              }
            ]
          },
          "TmpDirIAMRole": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The IAM role with permissions."
              }
            ]
          },
          "UpsertRedshiftOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/UpsertRedshiftTargetOptions"
              },
              {
                "description": "The set of options to configure an upsert operation when writing to a Redshift target."
              }
            ]
          }
        },
        "description": "Specifies a target that uses Amazon Redshift."
      },
      "UpsertRedshiftTargetOptions": {
        "type": "object",
        "properties": {
          "TableLocation": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The physical location of the Redshift table."
              }
            ]
          },
          "ConnectionName": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the connection to use to write to Redshift."
              }
            ]
          },
          "UpsertKeys": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringPropertiesMinOne"
              },
              {
                "description": "The keys used to determine whether to perform an update or insert."
              }
            ]
          }
        },
        "description": "The options to configure an upsert operation when writing to a Redshift target ."
      },
      "EnclosedInStringPropertiesMinOne": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/EnclosedInStringProperty"
        }
      },
      "S3CatalogTarget": {
        "type": "object",
        "required": [
          "Name",
          "Inputs",
          "Table",
          "Database"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the data target."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/OneInput"
              },
              {
                "description": "The nodes that are inputs to the data target."
              }
            ]
          },
          "PartitionKeys": {
            "allOf": [
              {
                "$ref": "#/$defs/GlueStudioPathList"
              },
              {
                "description": "Specifies native partitioning using a sequence of keys."
              }
            ]
          },
          "Table": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the table in the database to write to."
              }
            ]
          },
          "Database": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the database to write to."
              }
            ]
          },
          "SchemaChangePolicy": {
            "allOf": [
              {
                "$ref": "#/$defs/CatalogSchemaChangePolicy"
              },
              {
                "description": "A policy that specifies update behavior for the crawler."
              }
            ]
          }
        },
        "description": "Specifies a data target that writes to Amazon S3 using the Glue Data Catalog."
      },
      "GlueStudioPathList": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/EnclosedInStringProperties"
        }
      },
      "CatalogSchemaChangePolicy": {
        "type": "object",
        "properties": {
          "EnableUpdateCatalog": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedBoolean"
              },
              {
                "description": "Whether to use the specified update behavior when the crawler finds a changed schema."
              }
            ]
          },
          "UpdateBehavior": {
            "allOf": [
              {
                "$ref": "#/$defs/UpdateCatalogBehavior"
              },
              {
                "description": "The update behavior when the crawler finds a changed schema."
              }
            ]
          }
        },
        "description": "A policy that specifies update behavior for the crawler."
      },
      "UpdateCatalogBehavior": {
        "type": "string",
        "enum": [
          "UPDATE_IN_DATABASE",
          "LOG"
        ]
      },
      "S3GlueParquetTarget": {
        "type": "object",
        "required": [
          "Name",
          "Inputs",
          "Path"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the data target."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/OneInput"
              },
              {
                "description": "The nodes that are inputs to the data target."
              }
            ]
          },
          "PartitionKeys": {
            "allOf": [
              {
                "$ref": "#/$defs/GlueStudioPathList"
              },
              {
                "description": "Specifies native partitioning using a sequence of keys."
              }
            ]
          },
          "Path": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "A single Amazon S3 path to write to."
              }
            ]
          },
          "Compression": {
            "allOf": [
              {
                "$ref": "#/$defs/ParquetCompressionType"
              },
              {
                "description": "Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are <code>\"gzip\"</code> and <code>\"bzip\"</code>)."
              }
            ]
          },
          "SchemaChangePolicy": {
            "allOf": [
              {
                "$ref": "#/$defs/DirectSchemaChangePolicy"
              },
              {
                "description": "A policy that specifies update behavior for the crawler."
              }
            ]
          }
        },
        "description": "Specifies a data target that writes to Amazon S3 in Apache Parquet columnar storage."
      },
      "DirectSchemaChangePolicy": {
        "type": "object",
        "properties": {
          "EnableUpdateCatalog": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedBoolean"
              },
              {
                "description": "Whether to use the specified update behavior when the crawler finds a changed schema."
              }
            ]
          },
          "UpdateBehavior": {
            "allOf": [
              {
                "$ref": "#/$defs/UpdateCatalogBehavior"
              },
              {
                "description": "The update behavior when the crawler finds a changed schema."
              }
            ]
          },
          "Table": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "Specifies the table in the database that the schema change policy applies to."
              }
            ]
          },
          "Database": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "Specifies the database that the schema change policy applies to."
              }
            ]
          }
        },
        "description": "A policy that specifies update behavior for the crawler."
      },
      "S3DirectTarget": {
        "type": "object",
        "required": [
          "Name",
          "Inputs",
          "Path",
          "Format"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the data target."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/OneInput"
              },
              {
                "description": "The nodes that are inputs to the data target."
              }
            ]
          },
          "PartitionKeys": {
            "allOf": [
              {
                "$ref": "#/$defs/GlueStudioPathList"
              },
              {
                "description": "Specifies native partitioning using a sequence of keys."
              }
            ]
          },
          "Path": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "A single Amazon S3 path to write to."
              }
            ]
          },
          "Compression": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are <code>\"gzip\"</code> and <code>\"bzip\"</code>)."
              }
            ]
          },
          "Format": {
            "allOf": [
              {
                "$ref": "#/$defs/TargetFormat"
              },
              {
                "description": "Specifies the data output format for the target."
              }
            ]
          },
          "SchemaChangePolicy": {
            "allOf": [
              {
                "$ref": "#/$defs/DirectSchemaChangePolicy"
              },
              {
                "description": "A policy that specifies update behavior for the crawler."
              }
            ]
          }
        },
        "description": "Specifies a data target that writes to Amazon S3."
      },
      "TargetFormat": {
        "type": "string",
        "enum": [
          "json",
          "csv",
          "avro",
          "orc",
          "parquet",
          "hudi",
          "delta"
        ]
      },
      "ApplyMapping": {
        "type": "object",
        "required": [
          "Name",
          "Inputs",
          "Mapping"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the transform node."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/OneInput"
              },
              {
                "description": "The data inputs identified by their node names."
              }
            ]
          },
          "Mapping": {
            "allOf": [
              {
                "$ref": "#/$defs/Mappings"
              },
              {
                "description": "Specifies the mapping of data property keys in the data source to data property keys in the data target."
              }
            ]
          }
        },
        "description": "Specifies a transform that maps data property keys in the data source to data property keys in the data target. You can rename keys, modify the data types for keys, and choose which keys to drop from the dataset."
      },
      "Mappings": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/Mapping"
        }
      },
      "Mapping": {
        "type": "object",
        "properties": {
          "ToKey": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "After the apply mapping, what the name of the column should be. Can be the same as <code>FromPath</code>."
              }
            ]
          },
          "FromPath": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperties"
              },
              {
                "description": "The table or column to be modified."
              }
            ]
          },
          "FromType": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The type of the data to be modified."
              }
            ]
          },
          "ToType": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The data type that the data is to be modified to."
              }
            ]
          },
          "Dropped": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedBoolean"
              },
              {
                "description": "If true, then the column is removed."
              }
            ]
          },
          "Children": {
            "allOf": [
              {
                "$ref": "#/$defs/Mappings"
              },
              {
                "description": "<p>Only applicable to nested data structures. If you want to change the parent structure, but also one of its children, you can fill out this data strucutre. It is also <code>Mapping</code>, but its <code>FromPath</code> will be the parent's <code>FromPath</code> plus the <code>FromPath</code> from this structure.</p> <p>For the children part, suppose you have the structure:</p> <p> <code>{ \"FromPath\": \"OuterStructure\", \"ToKey\": \"OuterStructure\", \"ToType\": \"Struct\", \"Dropped\": false, \"Chidlren\": [{ \"FromPath\": \"inner\", \"ToKey\": \"inner\", \"ToType\": \"Double\", \"Dropped\": false, }] }</code> </p> <p>You can specify a <code>Mapping</code> that looks like:</p> <p> <code>{ \"FromPath\": \"OuterStructure\", \"ToKey\": \"OuterStructure\", \"ToType\": \"Struct\", \"Dropped\": false, \"Chidlren\": [{ \"FromPath\": \"inner\", \"ToKey\": \"inner\", \"ToType\": \"Double\", \"Dropped\": false, }] }</code> </p>"
              }
            ]
          }
        },
        "description": "Specifies the mapping of data property keys."
      },
      "SelectFields": {
        "type": "object",
        "required": [
          "Name",
          "Inputs",
          "Paths"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the transform node."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/OneInput"
              },
              {
                "description": "The data inputs identified by their node names."
              }
            ]
          },
          "Paths": {
            "allOf": [
              {
                "$ref": "#/$defs/GlueStudioPathList"
              },
              {
                "description": "A JSON path to a variable in the data structure."
              }
            ]
          }
        },
        "description": "Specifies a transform that chooses the data property keys that you want to keep."
      },
      "DropFields": {
        "type": "object",
        "required": [
          "Name",
          "Inputs",
          "Paths"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the transform node."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/OneInput"
              },
              {
                "description": "The data inputs identified by their node names."
              }
            ]
          },
          "Paths": {
            "allOf": [
              {
                "$ref": "#/$defs/GlueStudioPathList"
              },
              {
                "description": "A JSON path to a variable in the data structure."
              }
            ]
          }
        },
        "description": "Specifies a transform that chooses the data property keys that you want to drop."
      },
      "RenameField": {
        "type": "object",
        "required": [
          "Name",
          "Inputs",
          "SourcePath",
          "TargetPath"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the transform node."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/OneInput"
              },
              {
                "description": "The data inputs identified by their node names."
              }
            ]
          },
          "SourcePath": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperties"
              },
              {
                "description": "A JSON path to a variable in the data structure for the source data."
              }
            ]
          },
          "TargetPath": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperties"
              },
              {
                "description": "A JSON path to a variable in the data structure for the target data."
              }
            ]
          }
        },
        "description": "Specifies a transform that renames a single data property key."
      },
      "Spigot": {
        "type": "object",
        "required": [
          "Name",
          "Inputs",
          "Path"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the transform node."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/OneInput"
              },
              {
                "description": "The data inputs identified by their node names."
              }
            ]
          },
          "Path": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "A path in Amazon S3 where the transform will write a subset of records from the dataset to a JSON file in an Amazon S3 bucket."
              }
            ]
          },
          "Topk": {
            "allOf": [
              {
                "$ref": "#/$defs/Topk"
              },
              {
                "description": "Specifies a number of records to write starting from the beginning of the dataset."
              }
            ]
          },
          "Prob": {
            "allOf": [
              {
                "$ref": "#/$defs/Prob"
              },
              {
                "description": "The probability (a decimal value with a maximum value of 1) of picking any given record. A value of 1 indicates that each row read from the dataset should be included in the sample output."
              }
            ]
          }
        },
        "description": "Specifies a transform that writes samples of the data to an Amazon S3 bucket."
      },
      "Topk": {
        "type": "integer",
        "minimum": 0,
        "maximum": 100
      },
      "Prob": {
        "type": "number",
        "format": "double",
        "minimum": 0,
        "maximum": 1
      },
      "Join": {
        "type": "object",
        "required": [
          "Name",
          "Inputs",
          "JoinType",
          "Columns"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the transform node."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/TwoInputs"
              },
              {
                "description": "The data inputs identified by their node names."
              }
            ]
          },
          "JoinType": {
            "allOf": [
              {
                "$ref": "#/$defs/JoinType"
              },
              {
                "description": "Specifies the type of join to be performed on the datasets."
              }
            ]
          },
          "Columns": {
            "allOf": [
              {
                "$ref": "#/$defs/JoinColumns"
              },
              {
                "description": "A list of the two columns to be joined."
              }
            ]
          }
        },
        "description": "Specifies a transform that joins two datasets into one dataset using a comparison phrase on the specified data property keys. You can use inner, outer, left, right, left semi, and left anti joins."
      },
      "TwoInputs": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/NodeId"
        },
        "minItems": 2,
        "maxItems": 2
      },
      "JoinType": {
        "type": "string",
        "enum": [
          "equijoin",
          "left",
          "right",
          "outer",
          "leftsemi",
          "leftanti"
        ]
      },
      "JoinColumns": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/JoinColumn"
        },
        "minItems": 2,
        "maxItems": 2
      },
      "JoinColumn": {
        "type": "object",
        "required": [
          "From",
          "Keys"
        ],
        "properties": {
          "From": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The column to be joined."
              }
            ]
          },
          "Keys": {
            "allOf": [
              {
                "$ref": "#/$defs/GlueStudioPathList"
              },
              {
                "description": "The key of the column to be joined."
              }
            ]
          }
        },
        "description": "Specifies a column to be joined."
      },
      "SplitFields": {
        "type": "object",
        "required": [
          "Name",
          "Inputs",
          "Paths"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the transform node."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/OneInput"
              },
              {
                "description": "The data inputs identified by their node names."
              }
            ]
          },
          "Paths": {
            "allOf": [
              {
                "$ref": "#/$defs/GlueStudioPathList"
              },
              {
                "description": "A JSON path to a variable in the data structure."
              }
            ]
          }
        },
        "description": "Specifies a transform that splits data property keys into two <code>DynamicFrames</code>. The output is a collection of <code>DynamicFrames</code>: one with selected data property keys, and one with the remaining data property keys."
      },
      "SelectFromCollection": {
        "type": "object",
        "required": [
          "Name",
          "Inputs",
          "Index"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the transform node."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/OneInput"
              },
              {
                "description": "The data inputs identified by their node names."
              }
            ]
          },
          "Index": {
            "allOf": [
              {
                "$ref": "#/$defs/NonNegativeInt"
              },
              {
                "description": "The index for the DynamicFrame to be selected."
              }
            ]
          }
        },
        "description": "Specifies a transform that chooses one <code>DynamicFrame</code> from a collection of <code>DynamicFrames</code>. The output is the selected <code>DynamicFrame</code> "
      },
      "NonNegativeInt": {
        "type": "integer",
        "minimum": 0
      },
      "FillMissingValues": {
        "type": "object",
        "required": [
          "Name",
          "Inputs",
          "ImputedPath"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the transform node."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/OneInput"
              },
              {
                "description": "The data inputs identified by their node names."
              }
            ]
          },
          "ImputedPath": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "A JSON path to a variable in the data structure for the dataset that is imputed."
              }
            ]
          },
          "FilledPath": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "A JSON path to a variable in the data structure for the dataset that is filled."
              }
            ]
          }
        },
        "description": "Specifies a transform that locates records in the dataset that have missing values and adds a new field with a value determined by imputation. The input data set is used to train the machine learning model that determines what the missing value should be."
      },
      "Filter": {
        "type": "object",
        "required": [
          "Name",
          "Inputs",
          "LogicalOperator",
          "Filters"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the transform node."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/OneInput"
              },
              {
                "description": "The data inputs identified by their node names."
              }
            ]
          },
          "LogicalOperator": {
            "allOf": [
              {
                "$ref": "#/$defs/FilterLogicalOperator"
              },
              {
                "description": "The operator used to filter rows by comparing the key value to a specified value."
              }
            ]
          },
          "Filters": {
            "allOf": [
              {
                "$ref": "#/$defs/FilterExpressions"
              },
              {
                "description": "Specifies a filter expression."
              }
            ]
          }
        },
        "description": "Specifies a transform that splits a dataset into two, based on a filter condition."
      },
      "FilterLogicalOperator": {
        "type": "string",
        "enum": [
          "AND",
          "OR"
        ]
      },
      "FilterExpressions": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/FilterExpression"
        }
      },
      "FilterExpression": {
        "type": "object",
        "required": [
          "Operation",
          "Values"
        ],
        "properties": {
          "Operation": {
            "allOf": [
              {
                "$ref": "#/$defs/FilterOperation"
              },
              {
                "description": "The type of operation to perform in the expression."
              }
            ]
          },
          "Negated": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedBoolean"
              },
              {
                "description": "Whether the expression is to be negated."
              }
            ]
          },
          "Values": {
            "allOf": [
              {
                "$ref": "#/$defs/FilterValues"
              },
              {
                "description": "A list of filter values."
              }
            ]
          }
        },
        "description": "Specifies a filter expression."
      },
      "FilterOperation": {
        "type": "string",
        "enum": [
          "EQ",
          "LT",
          "GT",
          "LTE",
          "GTE",
          "REGEX",
          "ISNULL"
        ]
      },
      "FilterValues": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/FilterValue"
        }
      },
      "FilterValue": {
        "type": "object",
        "required": [
          "Type",
          "Value"
        ],
        "properties": {
          "Type": {
            "allOf": [
              {
                "$ref": "#/$defs/FilterValueType"
              },
              {
                "description": "The type of filter value."
              }
            ]
          },
          "Value": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperties"
              },
              {
                "description": "The value to be associated."
              }
            ]
          }
        },
        "description": "Represents a single entry in the list of values for a <code>FilterExpression</code>. "
      },
      "FilterValueType": {
        "type": "string",
        "enum": [
          "COLUMNEXTRACTED",
          "CONSTANT"
        ]
      },
      "CustomCode": {
        "type": "object",
        "required": [
          "Name",
          "Inputs",
          "Code",
          "ClassName"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the transform node."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/ManyInputs"
              },
              {
                "description": "The data inputs identified by their node names."
              }
            ]
          },
          "Code": {
            "allOf": [
              {
                "$ref": "#/$defs/ExtendedString"
              },
              {
                "description": "The custom code that is used to perform the data transformation."
              }
            ]
          },
          "ClassName": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name defined for the custom code node class."
              }
            ]
          },
          "OutputSchemas": {
            "allOf": [
              {
                "$ref": "#/$defs/GlueSchemas"
              },
              {
                "description": "Specifies the data schema for the custom code transform."
              }
            ]
          }
        },
        "description": "Specifies a transform that uses custom code you provide to perform the data transformation. The output is a collection of DynamicFrames."
      },
      "ManyInputs": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/NodeId"
        },
        "minItems": 1
      },
      "ExtendedString": {
        "type": "string",
        "pattern": "[\\s\\S]*"
      },
      "SparkSQL": {
        "type": "object",
        "required": [
          "Name",
          "Inputs",
          "SqlQuery",
          "SqlAliases"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the transform node."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/ManyInputs"
              },
              {
                "description": "The data inputs identified by their node names. You can associate a table name with each input node to use in the SQL query. The name you choose must meet the Spark SQL naming restrictions."
              }
            ]
          },
          "SqlQuery": {
            "allOf": [
              {
                "$ref": "#/$defs/SqlQuery"
              },
              {
                "description": "A SQL query that must use Spark SQL syntax and return a single data set."
              }
            ]
          },
          "SqlAliases": {
            "allOf": [
              {
                "$ref": "#/$defs/SqlAliases"
              },
              {
                "description": "<p>A list of aliases. An alias allows you to specify what name to use in the SQL for a given input. For example, you have a datasource named \"MyDataSource\". If you specify <code>From</code> as MyDataSource, and <code>Alias</code> as SqlName, then in your SQL you can do:</p> <p> <code>select * from SqlName</code> </p> <p>and that gets data from MyDataSource.</p>"
              }
            ]
          },
          "OutputSchemas": {
            "allOf": [
              {
                "$ref": "#/$defs/GlueSchemas"
              },
              {
                "description": "Specifies the data schema for the SparkSQL transform."
              }
            ]
          }
        },
        "description": "Specifies a transform where you enter a SQL query using Spark SQL syntax to transform the data. The output is a single <code>DynamicFrame</code>."
      },
      "SqlAliases": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/SqlAlias"
        }
      },
      "SqlAlias": {
        "type": "object",
        "required": [
          "From",
          "Alias"
        ],
        "properties": {
          "From": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeId"
              },
              {
                "description": "A table, or a column in a table."
              }
            ]
          },
          "Alias": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringPropertyWithQuote"
              },
              {
                "description": "A temporary name given to a table, or a column in a table."
              }
            ]
          }
        },
        "description": "Represents a single entry in the list of values for <code>SqlAliases</code>. "
      },
      "DirectKinesisSource": {
        "type": "object",
        "required": [
          "Name"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the data source."
              }
            ]
          },
          "WindowSize": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedPositiveInt"
              },
              {
                "description": "The amount of time to spend processing each micro batch."
              }
            ]
          },
          "DetectSchema": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedBoolean"
              },
              {
                "description": "Whether to automatically determine the schema from the incoming data."
              }
            ]
          },
          "StreamingOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/KinesisStreamingSourceOptions"
              },
              {
                "description": "Additional options for the Kinesis streaming data source."
              }
            ]
          },
          "DataPreviewOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/StreamingDataPreviewOptions"
              },
              {
                "description": "Additional options for data preview."
              }
            ]
          }
        },
        "description": "Specifies a direct Amazon Kinesis data source."
      },
      "BoxedPositiveInt": {
        "type": "integer",
        "minimum": 0
      },
      "KinesisStreamingSourceOptions": {
        "type": "object",
        "properties": {
          "EndpointUrl": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The URL of the Kinesis endpoint."
              }
            ]
          },
          "StreamName": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the Kinesis data stream."
              }
            ]
          },
          "Classification": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "An optional classification."
              }
            ]
          },
          "Delimiter": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "Specifies the delimiter character."
              }
            ]
          },
          "StartingPosition": {
            "allOf": [
              {
                "$ref": "#/$defs/StartingPosition"
              },
              {
                "description": "<p>The starting position in the Kinesis data stream to read data from. The possible values are <code>\"latest\"</code>, <code>\"trim_horizon\"</code>, <code>\"earliest\"</code>, or a timestamp string in UTC format in the pattern <code>yyyy-mm-ddTHH:MM:SSZ</code> (where <code>Z</code> represents a UTC timezone offset with a +/-. For example: \"2023-04-04T08:00:00-04:00\"). The default value is <code>\"latest\"</code>.</p> <p>Note: Using a value that is a timestamp string in UTC format for \"startingPosition\" is supported only for Glue version 4.0 or later.</p>"
              }
            ]
          },
          "MaxFetchTimeInMs": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedNonNegativeLong"
              },
              {
                "description": "The maximum time spent in the job executor to fetch a record from the Kinesis data stream per shard, specified in milliseconds (ms). The default value is <code>1000</code>."
              }
            ]
          },
          "MaxFetchRecordsPerShard": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedNonNegativeLong"
              },
              {
                "description": "The maximum number of records to fetch per shard in the Kinesis data stream. The default value is <code>100000</code>."
              }
            ]
          },
          "MaxRecordPerRead": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedNonNegativeLong"
              },
              {
                "description": "The maximum number of records to fetch from the Kinesis data stream in each getRecords operation. The default value is <code>10000</code>."
              }
            ]
          },
          "AddIdleTimeBetweenReads": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedBoolean"
              },
              {
                "description": "Adds a time delay between two consecutive getRecords operations. The default value is <code>\"False\"</code>. This option is only configurable for Glue version 2.0 and above."
              }
            ]
          },
          "IdleTimeBetweenReadsInMs": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedNonNegativeLong"
              },
              {
                "description": "The minimum time delay between two consecutive getRecords operations, specified in ms. The default value is <code>1000</code>. This option is only configurable for Glue version 2.0 and above."
              }
            ]
          },
          "DescribeShardInterval": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedNonNegativeLong"
              },
              {
                "description": "The minimum time interval between two ListShards API calls for your script to consider resharding. The default value is <code>1s</code>."
              }
            ]
          },
          "NumRetries": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedNonNegativeInt"
              },
              {
                "description": "The maximum number of retries for Kinesis Data Streams API requests. The default value is <code>3</code>."
              }
            ]
          },
          "RetryIntervalMs": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedNonNegativeLong"
              },
              {
                "description": "The cool-off time period (specified in ms) before retrying the Kinesis Data Streams API call. The default value is <code>1000</code>."
              }
            ]
          },
          "MaxRetryIntervalMs": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedNonNegativeLong"
              },
              {
                "description": "The maximum cool-off time period (specified in ms) between two retries of a Kinesis Data Streams API call. The default value is <code>10000</code>."
              }
            ]
          },
          "AvoidEmptyBatches": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedBoolean"
              },
              {
                "description": "Avoids creating an empty microbatch job by checking for unread data in the Kinesis data stream before the batch is started. The default value is <code>\"False\"</code>."
              }
            ]
          },
          "StreamArn": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The Amazon Resource Name (ARN) of the Kinesis data stream."
              }
            ]
          },
          "RoleArn": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The Amazon Resource Name (ARN) of the role to assume using AWS Security Token Service (AWS STS). This role must have permissions for describe or read record operations for the Kinesis data stream. You must use this parameter when accessing a data stream in a different account. Used in conjunction with <code>\"awsSTSSessionName\"</code>."
              }
            ]
          },
          "RoleSessionName": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "An identifier for the session assuming the role using AWS STS. You must use this parameter when accessing a data stream in a different account. Used in conjunction with <code>\"awsSTSRoleARN\"</code>."
              }
            ]
          },
          "AddRecordTimestamp": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "When this option is set to 'true', the data output will contain an additional column named \"__src_timestamp\" that indicates the time when the corresponding record received by the stream. The default value is 'false'. This option is supported in Glue version 4.0 or later."
              }
            ]
          },
          "EmitConsumerLagMetrics": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "When this option is set to 'true', for each batch, it will emit the metrics for the duration between the oldest record received by the stream and the time it arrives in Glue to CloudWatch. The metric's name is \"glue.driver.streaming.maxConsumerLagInMs\". The default value is 'false'. This option is supported in Glue version 4.0 or later."
              }
            ]
          },
          "StartingTimestamp": {
            "allOf": [
              {
                "$ref": "#/$defs/Iso8601DateTime"
              },
              {
                "description": "The timestamp of the record in the Kinesis data stream to start reading data from. The possible values are a timestamp string in UTC format of the pattern <code>yyyy-mm-ddTHH:MM:SSZ</code> (where Z represents a UTC timezone offset with a +/-. For example: \"2023-04-04T08:00:00+08:00\"). "
              }
            ]
          }
        },
        "description": "Additional options for the Amazon Kinesis streaming data source."
      },
      "StartingPosition": {
        "type": "string",
        "enum": [
          "latest",
          "trim_horizon",
          "earliest",
          "timestamp"
        ]
      },
      "Iso8601DateTime": {
        "type": "string",
        "format": "date-time"
      },
      "StreamingDataPreviewOptions": {
        "type": "object",
        "properties": {
          "PollingTime": {
            "allOf": [
              {
                "$ref": "#/$defs/PollingTime"
              },
              {
                "description": "The polling time in milliseconds."
              }
            ]
          },
          "RecordPollingLimit": {
            "allOf": [
              {
                "$ref": "#/$defs/PositiveLong"
              },
              {
                "description": "The limit to the number of records polled."
              }
            ]
          }
        },
        "description": "Specifies options related to data preview for viewing a sample of your data."
      },
      "PollingTime": {
        "type": "integer",
        "minimum": 10
      },
      "PositiveLong": {
        "type": "integer",
        "minimum": 1
      },
      "DirectKafkaSource": {
        "type": "object",
        "required": [
          "Name"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the data store."
              }
            ]
          },
          "StreamingOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/KafkaStreamingSourceOptions"
              },
              {
                "description": "Specifies the streaming options."
              }
            ]
          },
          "WindowSize": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedPositiveInt"
              },
              {
                "description": "The amount of time to spend processing each micro batch."
              }
            ]
          },
          "DetectSchema": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedBoolean"
              },
              {
                "description": "Whether to automatically determine the schema from the incoming data."
              }
            ]
          },
          "DataPreviewOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/StreamingDataPreviewOptions"
              },
              {
                "description": "Specifies options related to data preview for viewing a sample of your data."
              }
            ]
          }
        },
        "description": "Specifies an Apache Kafka data store."
      },
      "KafkaStreamingSourceOptions": {
        "type": "object",
        "properties": {
          "BootstrapServers": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "A list of bootstrap server URLs, for example, as <code>b-1.vpc-test-2.o4q88o.c6.kafka.us-east-1.amazonaws.com:9094</code>. This option must be specified in the API call or defined in the table metadata in the Data Catalog."
              }
            ]
          },
          "SecurityProtocol": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The protocol used to communicate with brokers. The possible values are <code>\"SSL\"</code> or <code>\"PLAINTEXT\"</code>."
              }
            ]
          },
          "ConnectionName": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the connection."
              }
            ]
          },
          "TopicName": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The topic name as specified in Apache Kafka. You must specify at least one of <code>\"topicName\"</code>, <code>\"assign\"</code> or <code>\"subscribePattern\"</code>."
              }
            ]
          },
          "Assign": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The specific <code>TopicPartitions</code> to consume. You must specify at least one of <code>\"topicName\"</code>, <code>\"assign\"</code> or <code>\"subscribePattern\"</code>."
              }
            ]
          },
          "SubscribePattern": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "A Java regex string that identifies the topic list to subscribe to. You must specify at least one of <code>\"topicName\"</code>, <code>\"assign\"</code> or <code>\"subscribePattern\"</code>."
              }
            ]
          },
          "Classification": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "An optional classification."
              }
            ]
          },
          "Delimiter": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "Specifies the delimiter character."
              }
            ]
          },
          "StartingOffsets": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The starting position in the Kafka topic to read data from. The possible values are <code>\"earliest\"</code> or <code>\"latest\"</code>. The default value is <code>\"latest\"</code>."
              }
            ]
          },
          "EndingOffsets": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The end point when a batch query is ended. Possible values are either <code>\"latest\"</code> or a JSON string that specifies an ending offset for each <code>TopicPartition</code>."
              }
            ]
          },
          "PollTimeoutMs": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedNonNegativeLong"
              },
              {
                "description": "The timeout in milliseconds to poll data from Kafka in Spark job executors. The default value is <code>512</code>."
              }
            ]
          },
          "NumRetries": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedNonNegativeInt"
              },
              {
                "description": "The number of times to retry before failing to fetch Kafka offsets. The default value is <code>3</code>."
              }
            ]
          },
          "RetryIntervalMs": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedNonNegativeLong"
              },
              {
                "description": "The time in milliseconds to wait before retrying to fetch Kafka offsets. The default value is <code>10</code>."
              }
            ]
          },
          "MaxOffsetsPerTrigger": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedNonNegativeLong"
              },
              {
                "description": "The rate limit on the maximum number of offsets that are processed per trigger interval. The specified total number of offsets is proportionally split across <code>topicPartitions</code> of different volumes. The default value is null, which means that the consumer reads all offsets until the known latest offset."
              }
            ]
          },
          "MinPartitions": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedNonNegativeInt"
              },
              {
                "description": "The desired minimum number of partitions to read from Kafka. The default value is null, which means that the number of spark partitions is equal to the number of Kafka partitions."
              }
            ]
          },
          "IncludeHeaders": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedBoolean"
              },
              {
                "description": "Whether to include the Kafka headers. When the option is set to \"true\", the data output will contain an additional column named \"glue_streaming_kafka_headers\" with type <code>Array[Struct(key: String, value: String)]</code>. The default value is \"false\". This option is available in Glue version 3.0 or later only."
              }
            ]
          },
          "AddRecordTimestamp": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "When this option is set to 'true', the data output will contain an additional column named \"__src_timestamp\" that indicates the time when the corresponding record received by the topic. The default value is 'false'. This option is supported in Glue version 4.0 or later."
              }
            ]
          },
          "EmitConsumerLagMetrics": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "When this option is set to 'true', for each batch, it will emit the metrics for the duration between the oldest record received by the topic and the time it arrives in Glue to CloudWatch. The metric's name is \"glue.driver.streaming.maxConsumerLagInMs\". The default value is 'false'. This option is supported in Glue version 4.0 or later."
              }
            ]
          },
          "StartingTimestamp": {
            "allOf": [
              {
                "$ref": "#/$defs/Iso8601DateTime"
              },
              {
                "description": "<p>The timestamp of the record in the Kafka topic to start reading data from. The possible values are a timestamp string in UTC format of the pattern <code>yyyy-mm-ddTHH:MM:SSZ</code> (where Z represents a UTC timezone offset with a +/-. For example: \"2023-04-04T08:00:00+08:00\"). </p> <p>Only one of <code>StartingTimestamp</code> or <code>StartingOffsets</code> must be set.</p>"
              }
            ]
          }
        },
        "description": "Additional options for streaming."
      },
      "CatalogKinesisSource": {
        "type": "object",
        "required": [
          "Name",
          "Table",
          "Database"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the data source."
              }
            ]
          },
          "WindowSize": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedPositiveInt"
              },
              {
                "description": "The amount of time to spend processing each micro batch."
              }
            ]
          },
          "DetectSchema": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedBoolean"
              },
              {
                "description": "Whether to automatically determine the schema from the incoming data."
              }
            ]
          },
          "Table": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the table in the database to read from."
              }
            ]
          },
          "Database": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the database to read from."
              }
            ]
          },
          "StreamingOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/KinesisStreamingSourceOptions"
              },
              {
                "description": "Additional options for the Kinesis streaming data source."
              }
            ]
          },
          "DataPreviewOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/StreamingDataPreviewOptions"
              },
              {
                "description": "Additional options for data preview."
              }
            ]
          }
        },
        "description": "Specifies a Kinesis data source in the Glue Data Catalog."
      },
      "CatalogKafkaSource": {
        "type": "object",
        "required": [
          "Name",
          "Table",
          "Database"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the data store."
              }
            ]
          },
          "WindowSize": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedPositiveInt"
              },
              {
                "description": "The amount of time to spend processing each micro batch."
              }
            ]
          },
          "DetectSchema": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedBoolean"
              },
              {
                "description": "Whether to automatically determine the schema from the incoming data."
              }
            ]
          },
          "Table": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the table in the database to read from."
              }
            ]
          },
          "Database": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the database to read from."
              }
            ]
          },
          "StreamingOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/KafkaStreamingSourceOptions"
              },
              {
                "description": "Specifies the streaming options."
              }
            ]
          },
          "DataPreviewOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/StreamingDataPreviewOptions"
              },
              {
                "description": "Specifies options related to data preview for viewing a sample of your data."
              }
            ]
          }
        },
        "description": "Specifies an Apache Kafka data store in the Data Catalog."
      },
      "DropNullFields": {
        "type": "object",
        "required": [
          "Name",
          "Inputs"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the transform node."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/OneInput"
              },
              {
                "description": "The data inputs identified by their node names."
              }
            ]
          },
          "NullCheckBoxList": {
            "allOf": [
              {
                "$ref": "#/$defs/NullCheckBoxList"
              },
              {
                "description": "A structure that represents whether certain values are recognized as null values for removal."
              }
            ]
          },
          "NullTextList": {
            "allOf": [
              {
                "$ref": "#/$defs/NullValueFields"
              },
              {
                "description": "<p>A structure that specifies a list of NullValueField structures that represent a custom null value such as zero or other value being used as a null placeholder unique to the dataset.</p> <p>The <code>DropNullFields</code> transform removes custom null values only if both the value of the null placeholder and the datatype match the data.</p>"
              }
            ]
          }
        },
        "description": "Specifies a transform that removes columns from the dataset if all values in the column are 'null'. By default, Glue Studio will recognize null objects, but some values such as empty strings, strings that are \"null\", -1 integers or other placeholders such as zeros, are not automatically recognized as nulls."
      },
      "NullCheckBoxList": {
        "type": "object",
        "properties": {
          "IsEmpty": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedBoolean"
              },
              {
                "description": "Specifies that an empty string is considered as a null value."
              }
            ]
          },
          "IsNullString": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedBoolean"
              },
              {
                "description": "Specifies that a value spelling out the word 'null' is considered as a null value."
              }
            ]
          },
          "IsNegOne": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedBoolean"
              },
              {
                "description": "Specifies that an integer value of -1 is considered as a null value."
              }
            ]
          }
        },
        "description": "Represents whether certain values are recognized as null values for removal."
      },
      "NullValueFields": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/NullValueField"
        },
        "minItems": 0,
        "maxItems": 50
      },
      "NullValueField": {
        "type": "object",
        "required": [
          "Value",
          "Datatype"
        ],
        "properties": {
          "Value": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The value of the null placeholder."
              }
            ]
          },
          "Datatype": {
            "allOf": [
              {
                "$ref": "#/$defs/Datatype"
              },
              {
                "description": "The datatype of the value."
              }
            ]
          }
        },
        "description": "Represents a custom null value such as a zeros or other value being used as a null placeholder unique to the dataset."
      },
      "Datatype": {
        "type": "object",
        "required": [
          "Id",
          "Label"
        ],
        "properties": {
          "Id": {
            "allOf": [
              {
                "$ref": "#/$defs/GenericLimitedString"
              },
              {
                "description": "The datatype of the value."
              }
            ]
          },
          "Label": {
            "allOf": [
              {
                "$ref": "#/$defs/GenericLimitedString"
              },
              {
                "description": "A label assigned to the datatype."
              }
            ]
          }
        },
        "description": "A structure representing the datatype of the value."
      },
      "GenericLimitedString": {
        "type": "string",
        "pattern": "[A-Za-z0-9_-]*"
      },
      "Merge": {
        "type": "object",
        "required": [
          "Name",
          "Inputs",
          "Source",
          "PrimaryKeys"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the transform node."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/TwoInputs"
              },
              {
                "description": "The data inputs identified by their node names."
              }
            ]
          },
          "Source": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeId"
              },
              {
                "description": "The source <code>DynamicFrame</code> that will be merged with a staging <code>DynamicFrame</code>."
              }
            ]
          },
          "PrimaryKeys": {
            "allOf": [
              {
                "$ref": "#/$defs/GlueStudioPathList"
              },
              {
                "description": "The list of primary key fields to match records from the source and staging dynamic frames."
              }
            ]
          }
        },
        "description": "Specifies a transform that merges a <code>DynamicFrame</code> with a staging <code>DynamicFrame</code> based on the specified primary keys to identify records. Duplicate records (records with the same primary keys) are not de-duplicated. "
      },
      "Union": {
        "type": "object",
        "required": [
          "Name",
          "Inputs",
          "UnionType"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the transform node."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/TwoInputs"
              },
              {
                "description": "The node ID inputs to the transform."
              }
            ]
          },
          "UnionType": {
            "allOf": [
              {
                "$ref": "#/$defs/UnionType"
              },
              {
                "description": "<p>Indicates the type of Union transform. </p> <p>Specify <code>ALL</code> to join all rows from data sources to the resulting DynamicFrame. The resulting union does not remove duplicate rows.</p> <p>Specify <code>DISTINCT</code> to remove duplicate rows in the resulting DynamicFrame.</p>"
              }
            ]
          }
        },
        "description": "Specifies a transform that combines the rows from two or more datasets into a single result."
      },
      "UnionType": {
        "type": "string",
        "enum": [
          "ALL",
          "DISTINCT"
        ]
      },
      "PIIDetection": {
        "type": "object",
        "required": [
          "Name",
          "Inputs",
          "PiiType",
          "EntityTypesToDetect"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the transform node."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/OneInput"
              },
              {
                "description": "The node ID inputs to the transform."
              }
            ]
          },
          "PiiType": {
            "allOf": [
              {
                "$ref": "#/$defs/PiiType"
              },
              {
                "description": "Indicates the type of PIIDetection transform. "
              }
            ]
          },
          "EntityTypesToDetect": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperties"
              },
              {
                "description": "<p>Indicates the types of entities the PIIDetection transform will identify as PII data. </p> <p> PII type entities include: PERSON_NAME, DATE, USA_SNN, EMAIL, USA_ITIN, USA_PASSPORT_NUMBER, PHONE_NUMBER, BANK_ACCOUNT, IP_ADDRESS, MAC_ADDRESS, USA_CPT_CODE, USA_HCPCS_CODE, USA_NATIONAL_DRUG_CODE, USA_MEDICARE_BENEFICIARY_IDENTIFIER, USA_HEALTH_INSURANCE_CLAIM_NUMBER,CREDIT_CARD,USA_NATIONAL_PROVIDER_IDENTIFIER,USA_DEA_NUMBER,USA_DRIVING_LICENSE </p>"
              }
            ]
          },
          "OutputColumnName": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "Indicates the output column name that will contain any entity type detected in that row. "
              }
            ]
          },
          "SampleFraction": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedDoubleFraction"
              },
              {
                "description": "Indicates the fraction of the data to sample when scanning for PII entities. "
              }
            ]
          },
          "ThresholdFraction": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedDoubleFraction"
              },
              {
                "description": "Indicates the fraction of the data that must be met in order for a column to be identified as PII data. "
              }
            ]
          },
          "MaskValue": {
            "allOf": [
              {
                "$ref": "#/$defs/MaskValue"
              },
              {
                "description": "Indicates the value that will replace the detected entity. "
              }
            ]
          }
        },
        "description": "Specifies a transform that identifies, removes or masks PII data."
      },
      "PiiType": {
        "type": "string",
        "enum": [
          "RowAudit",
          "RowMasking",
          "ColumnAudit",
          "ColumnMasking"
        ]
      },
      "BoxedDoubleFraction": {
        "type": "number",
        "format": "double",
        "minimum": 0,
        "maximum": 1
      },
      "MaskValue": {
        "type": "string",
        "pattern": "[*A-Za-z0-9_-]*",
        "minLength": 0,
        "maxLength": 256
      },
      "Aggregate": {
        "type": "object",
        "required": [
          "Name",
          "Inputs",
          "Groups",
          "Aggs"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the transform node."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/OneInput"
              },
              {
                "description": "Specifies the fields and rows to use as inputs for the aggregate transform."
              }
            ]
          },
          "Groups": {
            "allOf": [
              {
                "$ref": "#/$defs/GlueStudioPathList"
              },
              {
                "description": "Specifies the fields to group by."
              }
            ]
          },
          "Aggs": {
            "allOf": [
              {
                "$ref": "#/$defs/AggregateOperations"
              },
              {
                "description": "Specifies the aggregate functions to be performed on specified fields. "
              }
            ]
          }
        },
        "description": "Specifies a transform that groups rows by chosen fields and computes the aggregated value by specified function."
      },
      "AggregateOperations": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/AggregateOperation"
        },
        "minItems": 1,
        "maxItems": 30
      },
      "AggregateOperation": {
        "type": "object",
        "required": [
          "Column",
          "AggFunc"
        ],
        "properties": {
          "Column": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperties"
              },
              {
                "description": "Specifies the column on the data set on which the aggregation function will be applied."
              }
            ]
          },
          "AggFunc": {
            "allOf": [
              {
                "$ref": "#/$defs/AggFunction"
              },
              {
                "description": "<p>Specifies the aggregation function to apply.</p> <p>Possible aggregation functions include: avg countDistinct, count, first, last, kurtosis, max, min, skewness, stddev_samp, stddev_pop, sum, sumDistinct, var_samp, var_pop</p>"
              }
            ]
          }
        },
        "description": "Specifies the set of parameters needed to perform aggregation in the aggregate transform."
      },
      "AggFunction": {
        "type": "string",
        "enum": [
          "avg",
          "countDistinct",
          "count",
          "first",
          "last",
          "kurtosis",
          "max",
          "min",
          "skewness",
          "stddev_samp",
          "stddev_pop",
          "sum",
          "sumDistinct",
          "var_samp",
          "var_pop"
        ]
      },
      "DropDuplicates": {
        "type": "object",
        "required": [
          "Name",
          "Inputs"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the transform node."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/OneInput"
              },
              {
                "description": "The data inputs identified by their node names."
              }
            ]
          },
          "Columns": {
            "allOf": [
              {
                "$ref": "#/$defs/LimitedPathList"
              },
              {
                "description": "The name of the columns to be merged or removed if repeating."
              }
            ]
          }
        },
        "description": "Specifies a transform that removes rows of repeating data from a data set. "
      },
      "LimitedPathList": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/LimitedStringList"
        }
      },
      "LimitedStringList": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/GenericLimitedString"
        }
      },
      "GovernedCatalogTarget": {
        "type": "object",
        "required": [
          "Name",
          "Inputs",
          "Table",
          "Database"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the data target."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/OneInput"
              },
              {
                "description": "The nodes that are inputs to the data target."
              }
            ]
          },
          "PartitionKeys": {
            "allOf": [
              {
                "$ref": "#/$defs/GlueStudioPathList"
              },
              {
                "description": "Specifies native partitioning using a sequence of keys."
              }
            ]
          },
          "Table": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the table in the database to write to."
              }
            ]
          },
          "Database": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the database to write to."
              }
            ]
          },
          "SchemaChangePolicy": {
            "allOf": [
              {
                "$ref": "#/$defs/CatalogSchemaChangePolicy"
              },
              {
                "description": "A policy that specifies update behavior for the governed catalog."
              }
            ]
          }
        },
        "description": "Specifies a data target that writes to Amazon S3 using the Glue Data Catalog."
      },
      "GovernedCatalogSource": {
        "type": "object",
        "required": [
          "Name",
          "Database",
          "Table"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the data store."
              }
            ]
          },
          "Database": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The database to read from."
              }
            ]
          },
          "Table": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The database table to read from."
              }
            ]
          },
          "PartitionPredicate": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "Partitions satisfying this predicate are deleted. Files within the retention period in these partitions are not deleted. Set to <code>\"\"</code> – empty by default."
              }
            ]
          },
          "AdditionalOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/S3SourceAdditionalOptions"
              },
              {
                "description": "Specifies additional connection options."
              }
            ]
          }
        },
        "description": "Specifies the data store in the governed Glue Data Catalog."
      },
      "MicrosoftSQLServerCatalogSource": {
        "type": "object",
        "required": [
          "Name",
          "Database",
          "Table"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the data source."
              }
            ]
          },
          "Database": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the database to read from."
              }
            ]
          },
          "Table": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the table in the database to read from."
              }
            ]
          }
        },
        "description": "Specifies a Microsoft SQL server data source in the Glue Data Catalog."
      },
      "MySQLCatalogSource": {
        "type": "object",
        "required": [
          "Name",
          "Database",
          "Table"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the data source."
              }
            ]
          },
          "Database": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the database to read from."
              }
            ]
          },
          "Table": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the table in the database to read from."
              }
            ]
          }
        },
        "description": "Specifies a MySQL data source in the Glue Data Catalog."
      },
      "OracleSQLCatalogSource": {
        "type": "object",
        "required": [
          "Name",
          "Database",
          "Table"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the data source."
              }
            ]
          },
          "Database": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the database to read from."
              }
            ]
          },
          "Table": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the table in the database to read from."
              }
            ]
          }
        },
        "description": "Specifies an Oracle data source in the Glue Data Catalog."
      },
      "PostgreSQLCatalogSource": {
        "type": "object",
        "required": [
          "Name",
          "Database",
          "Table"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the data source."
              }
            ]
          },
          "Database": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the database to read from."
              }
            ]
          },
          "Table": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the table in the database to read from."
              }
            ]
          }
        },
        "description": "Specifies a PostgresSQL data source in the Glue Data Catalog."
      },
      "MicrosoftSQLServerCatalogTarget": {
        "type": "object",
        "required": [
          "Name",
          "Inputs",
          "Database",
          "Table"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the data target."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/OneInput"
              },
              {
                "description": "The nodes that are inputs to the data target."
              }
            ]
          },
          "Database": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the database to write to."
              }
            ]
          },
          "Table": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the table in the database to write to."
              }
            ]
          }
        },
        "description": "Specifies a target that uses Microsoft SQL."
      },
      "MySQLCatalogTarget": {
        "type": "object",
        "required": [
          "Name",
          "Inputs",
          "Database",
          "Table"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the data target."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/OneInput"
              },
              {
                "description": "The nodes that are inputs to the data target."
              }
            ]
          },
          "Database": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the database to write to."
              }
            ]
          },
          "Table": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the table in the database to write to."
              }
            ]
          }
        },
        "description": "Specifies a target that uses MySQL."
      },
      "OracleSQLCatalogTarget": {
        "type": "object",
        "required": [
          "Name",
          "Inputs",
          "Database",
          "Table"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the data target."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/OneInput"
              },
              {
                "description": "The nodes that are inputs to the data target."
              }
            ]
          },
          "Database": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the database to write to."
              }
            ]
          },
          "Table": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the table in the database to write to."
              }
            ]
          }
        },
        "description": "Specifies a target that uses Oracle SQL."
      },
      "PostgreSQLCatalogTarget": {
        "type": "object",
        "required": [
          "Name",
          "Inputs",
          "Database",
          "Table"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the data target."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/OneInput"
              },
              {
                "description": "The nodes that are inputs to the data target."
              }
            ]
          },
          "Database": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the database to write to."
              }
            ]
          },
          "Table": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the table in the database to write to."
              }
            ]
          }
        },
        "description": "Specifies a target that uses Postgres SQL."
      },
      "DynamicTransform": {
        "type": "object",
        "required": [
          "Name",
          "TransformName",
          "Inputs",
          "FunctionName",
          "Path"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "Specifies the name of the dynamic transform."
              }
            ]
          },
          "TransformName": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "Specifies the name of the dynamic transform as it appears in the Glue Studio visual editor."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/OneInput"
              },
              {
                "description": "Specifies the inputs for the dynamic transform that are required."
              }
            ]
          },
          "Parameters": {
            "allOf": [
              {
                "$ref": "#/$defs/TransformConfigParameterList"
              },
              {
                "description": "Specifies the parameters of the dynamic transform."
              }
            ]
          },
          "FunctionName": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "Specifies the name of the function of the dynamic transform."
              }
            ]
          },
          "Path": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "Specifies the path of the dynamic transform source and config files."
              }
            ]
          },
          "Version": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "This field is not used and will be deprecated in future release."
              }
            ]
          },
          "OutputSchemas": {
            "allOf": [
              {
                "$ref": "#/$defs/GlueSchemas"
              },
              {
                "description": "Specifies the data schema for the dynamic transform."
              }
            ]
          }
        },
        "description": "Specifies the set of parameters needed to perform the dynamic transform."
      },
      "TransformConfigParameterList": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/TransformConfigParameter"
        }
      },
      "TransformConfigParameter": {
        "type": "object",
        "required": [
          "Name",
          "Type"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "Specifies the name of the parameter in the config file of the dynamic transform."
              }
            ]
          },
          "Type": {
            "allOf": [
              {
                "$ref": "#/$defs/ParamType"
              },
              {
                "description": "Specifies the parameter type in the config file of the dynamic transform."
              }
            ]
          },
          "ValidationRule": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "Specifies the validation rule in the config file of the dynamic transform."
              }
            ]
          },
          "ValidationMessage": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "Specifies the validation message in the config file of the dynamic transform."
              }
            ]
          },
          "Value": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperties"
              },
              {
                "description": "Specifies the value of the parameter in the config file of the dynamic transform."
              }
            ]
          },
          "ListType": {
            "allOf": [
              {
                "$ref": "#/$defs/ParamType"
              },
              {
                "description": "Specifies the list type of the parameter in the config file of the dynamic transform."
              }
            ]
          },
          "IsOptional": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedBoolean"
              },
              {
                "description": "Specifies whether the parameter is optional or not in the config file of the dynamic transform."
              }
            ]
          }
        },
        "description": "Specifies the parameters in the config file of the dynamic transform."
      },
      "ParamType": {
        "type": "string",
        "enum": [
          "str",
          "int",
          "float",
          "complex",
          "bool",
          "list",
          "null"
        ]
      },
      "EvaluateDataQuality": {
        "type": "object",
        "required": [
          "Name",
          "Inputs",
          "Ruleset"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the data quality evaluation."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/OneInput"
              },
              {
                "description": "The inputs of your data quality evaluation."
              }
            ]
          },
          "Ruleset": {
            "allOf": [
              {
                "$ref": "#/$defs/DQDLString"
              },
              {
                "description": "The ruleset for your data quality evaluation."
              }
            ]
          },
          "Output": {
            "allOf": [
              {
                "$ref": "#/$defs/DQTransformOutput"
              },
              {
                "description": "The output of your data quality evaluation."
              }
            ]
          },
          "PublishingOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/DQResultsPublishingOptions"
              },
              {
                "description": "Options to configure how your results are published."
              }
            ]
          },
          "StopJobOnFailureOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/DQStopJobOnFailureOptions"
              },
              {
                "description": "Options to configure how your job will stop if your data quality evaluation fails."
              }
            ]
          }
        },
        "description": "Specifies your data quality evaluation criteria."
      },
      "DQDLString": {
        "type": "string",
        "pattern": "([\\u0020-\\u007E\\r\\s\\n])*",
        "minLength": 1,
        "maxLength": 65536
      },
      "DQTransformOutput": {
        "type": "string",
        "enum": [
          "PrimaryInput",
          "EvaluationResults"
        ]
      },
      "DQResultsPublishingOptions": {
        "type": "object",
        "properties": {
          "EvaluationContext": {
            "allOf": [
              {
                "$ref": "#/$defs/GenericLimitedString"
              },
              {
                "description": "The context of the evaluation."
              }
            ]
          },
          "ResultsS3Prefix": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The Amazon S3 prefix prepended to the results."
              }
            ]
          },
          "CloudWatchMetricsEnabled": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedBoolean"
              },
              {
                "description": "Enable metrics for your data quality results."
              }
            ]
          },
          "ResultsPublishingEnabled": {
            "allOf": [
              {
                "$ref": "#/$defs/BoxedBoolean"
              },
              {
                "description": "Enable publishing for your data quality results."
              }
            ]
          }
        },
        "description": "Options to configure how your data quality evaluation results are published."
      },
      "DQStopJobOnFailureOptions": {
        "type": "object",
        "properties": {
          "StopJobOnFailureTiming": {
            "allOf": [
              {
                "$ref": "#/$defs/DQStopJobOnFailureTiming"
              },
              {
                "description": "When to stop job if your data quality evaluation fails. Options are Immediate or AfterDataLoad."
              }
            ]
          }
        },
        "description": "Options to configure how your job will stop if your data quality evaluation fails."
      },
      "DQStopJobOnFailureTiming": {
        "type": "string",
        "enum": [
          "Immediate",
          "AfterDataLoad"
        ]
      },
      "S3CatalogHudiSource": {
        "type": "object",
        "required": [
          "Name",
          "Database",
          "Table"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the Hudi data source."
              }
            ]
          },
          "Database": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the database to read from."
              }
            ]
          },
          "Table": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the table in the database to read from."
              }
            ]
          },
          "AdditionalHudiOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/AdditionalOptions"
              },
              {
                "description": "Specifies additional connection options."
              }
            ]
          },
          "OutputSchemas": {
            "allOf": [
              {
                "$ref": "#/$defs/GlueSchemas"
              },
              {
                "description": "Specifies the data schema for the Hudi source."
              }
            ]
          }
        },
        "description": "Specifies a Hudi data source that is registered in the Glue Data Catalog. The Hudi data source must be stored in Amazon S3."
      },
      "CatalogHudiSource": {
        "type": "object",
        "required": [
          "Name",
          "Database",
          "Table"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the Hudi data source."
              }
            ]
          },
          "Database": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the database to read from."
              }
            ]
          },
          "Table": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the table in the database to read from."
              }
            ]
          },
          "AdditionalHudiOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/AdditionalOptions"
              },
              {
                "description": "Specifies additional connection options."
              }
            ]
          },
          "OutputSchemas": {
            "allOf": [
              {
                "$ref": "#/$defs/GlueSchemas"
              },
              {
                "description": "Specifies the data schema for the Hudi source."
              }
            ]
          }
        },
        "description": "Specifies a Hudi data source that is registered in the Glue Data Catalog."
      },
      "S3HudiSource": {
        "type": "object",
        "required": [
          "Name",
          "Paths"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the Hudi source."
              }
            ]
          },
          "Paths": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperties"
              },
              {
                "description": "A list of the Amazon S3 paths to read from."
              }
            ]
          },
          "AdditionalHudiOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/AdditionalOptions"
              },
              {
                "description": "Specifies additional connection options."
              }
            ]
          },
          "AdditionalOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/S3DirectSourceAdditionalOptions"
              },
              {
                "description": "Specifies additional options for the connector."
              }
            ]
          },
          "OutputSchemas": {
            "allOf": [
              {
                "$ref": "#/$defs/GlueSchemas"
              },
              {
                "description": "Specifies the data schema for the Hudi source."
              }
            ]
          }
        },
        "description": "Specifies a Hudi data source stored in Amazon S3."
      },
      "S3HudiCatalogTarget": {
        "type": "object",
        "required": [
          "Name",
          "Inputs",
          "Table",
          "Database",
          "AdditionalOptions"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the data target."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/OneInput"
              },
              {
                "description": "The nodes that are inputs to the data target."
              }
            ]
          },
          "PartitionKeys": {
            "allOf": [
              {
                "$ref": "#/$defs/GlueStudioPathList"
              },
              {
                "description": "Specifies native partitioning using a sequence of keys."
              }
            ]
          },
          "Table": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the table in the database to write to."
              }
            ]
          },
          "Database": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the database to write to."
              }
            ]
          },
          "AdditionalOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/AdditionalOptions"
              },
              {
                "description": "Specifies additional connection options for the connector."
              }
            ]
          },
          "SchemaChangePolicy": {
            "allOf": [
              {
                "$ref": "#/$defs/CatalogSchemaChangePolicy"
              },
              {
                "description": "A policy that specifies update behavior for the crawler."
              }
            ]
          }
        },
        "description": "Specifies a target that writes to a Hudi data source in the Glue Data Catalog."
      },
      "S3HudiDirectTarget": {
        "type": "object",
        "required": [
          "Name",
          "Inputs",
          "Path",
          "Compression",
          "Format",
          "AdditionalOptions"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the data target."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/OneInput"
              },
              {
                "description": "The nodes that are inputs to the data target."
              }
            ]
          },
          "Path": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The Amazon S3 path of your Hudi data source to write to."
              }
            ]
          },
          "Compression": {
            "allOf": [
              {
                "$ref": "#/$defs/HudiTargetCompressionType"
              },
              {
                "description": "Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are <code>\"gzip\"</code> and <code>\"bzip\"</code>)."
              }
            ]
          },
          "PartitionKeys": {
            "allOf": [
              {
                "$ref": "#/$defs/GlueStudioPathList"
              },
              {
                "description": "Specifies native partitioning using a sequence of keys."
              }
            ]
          },
          "Format": {
            "allOf": [
              {
                "$ref": "#/$defs/TargetFormat"
              },
              {
                "description": "Specifies the data output format for the target."
              }
            ]
          },
          "AdditionalOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/AdditionalOptions"
              },
              {
                "description": "Specifies additional connection options for the connector."
              }
            ]
          },
          "SchemaChangePolicy": {
            "allOf": [
              {
                "$ref": "#/$defs/DirectSchemaChangePolicy"
              },
              {
                "description": "A policy that specifies update behavior for the crawler."
              }
            ]
          }
        },
        "description": "Specifies a target that writes to a Hudi data source in Amazon S3."
      },
      "HudiTargetCompressionType": {
        "type": "string",
        "enum": [
          "gzip",
          "lzo",
          "uncompressed",
          "snappy"
        ]
      },
      "DirectJDBCSource": {
        "type": "object",
        "required": [
          "Name",
          "Database",
          "Table",
          "ConnectionName",
          "ConnectionType"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the JDBC source connection."
              }
            ]
          },
          "Database": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The database of the JDBC source connection."
              }
            ]
          },
          "Table": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The table of the JDBC source connection."
              }
            ]
          },
          "ConnectionName": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The connection name of the JDBC source."
              }
            ]
          },
          "ConnectionType": {
            "allOf": [
              {
                "$ref": "#/$defs/JDBCConnectionType"
              },
              {
                "description": "The connection type of the JDBC source."
              }
            ]
          },
          "RedshiftTmpDir": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The temp directory of the JDBC Redshift source."
              }
            ]
          }
        },
        "description": "Specifies the direct JDBC source connection."
      },
      "JDBCConnectionType": {
        "type": "string",
        "enum": [
          "sqlserver",
          "mysql",
          "oracle",
          "postgresql",
          "redshift"
        ]
      },
      "S3CatalogDeltaSource": {
        "type": "object",
        "required": [
          "Name",
          "Database",
          "Table"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the Delta Lake data source."
              }
            ]
          },
          "Database": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the database to read from."
              }
            ]
          },
          "Table": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the table in the database to read from."
              }
            ]
          },
          "AdditionalDeltaOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/AdditionalOptions"
              },
              {
                "description": "Specifies additional connection options."
              }
            ]
          },
          "OutputSchemas": {
            "allOf": [
              {
                "$ref": "#/$defs/GlueSchemas"
              },
              {
                "description": "Specifies the data schema for the Delta Lake source."
              }
            ]
          }
        },
        "description": "Specifies a Delta Lake data source that is registered in the Glue Data Catalog. The data source must be stored in Amazon S3."
      },
      "CatalogDeltaSource": {
        "type": "object",
        "required": [
          "Name",
          "Database",
          "Table"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the Delta Lake data source."
              }
            ]
          },
          "Database": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the database to read from."
              }
            ]
          },
          "Table": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the table in the database to read from."
              }
            ]
          },
          "AdditionalDeltaOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/AdditionalOptions"
              },
              {
                "description": "Specifies additional connection options."
              }
            ]
          },
          "OutputSchemas": {
            "allOf": [
              {
                "$ref": "#/$defs/GlueSchemas"
              },
              {
                "description": "Specifies the data schema for the Delta Lake source."
              }
            ]
          }
        },
        "description": "Specifies a Delta Lake data source that is registered in the Glue Data Catalog."
      },
      "S3DeltaSource": {
        "type": "object",
        "required": [
          "Name",
          "Paths"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the Delta Lake source."
              }
            ]
          },
          "Paths": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperties"
              },
              {
                "description": "A list of the Amazon S3 paths to read from."
              }
            ]
          },
          "AdditionalDeltaOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/AdditionalOptions"
              },
              {
                "description": "Specifies additional connection options."
              }
            ]
          },
          "AdditionalOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/S3DirectSourceAdditionalOptions"
              },
              {
                "description": "Specifies additional options for the connector."
              }
            ]
          },
          "OutputSchemas": {
            "allOf": [
              {
                "$ref": "#/$defs/GlueSchemas"
              },
              {
                "description": "Specifies the data schema for the Delta Lake source."
              }
            ]
          }
        },
        "description": "Specifies a Delta Lake data source stored in Amazon S3."
      },
      "S3DeltaCatalogTarget": {
        "type": "object",
        "required": [
          "Name",
          "Inputs",
          "Table",
          "Database"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the data target."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/OneInput"
              },
              {
                "description": "The nodes that are inputs to the data target."
              }
            ]
          },
          "PartitionKeys": {
            "allOf": [
              {
                "$ref": "#/$defs/GlueStudioPathList"
              },
              {
                "description": "Specifies native partitioning using a sequence of keys."
              }
            ]
          },
          "Table": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the table in the database to write to."
              }
            ]
          },
          "Database": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The name of the database to write to."
              }
            ]
          },
          "AdditionalOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/AdditionalOptions"
              },
              {
                "description": "Specifies additional connection options for the connector."
              }
            ]
          },
          "SchemaChangePolicy": {
            "allOf": [
              {
                "$ref": "#/$defs/CatalogSchemaChangePolicy"
              },
              {
                "description": "A policy that specifies update behavior for the crawler."
              }
            ]
          }
        },
        "description": "Specifies a target that writes to a Delta Lake data source in the Glue Data Catalog."
      },
      "S3DeltaDirectTarget": {
        "type": "object",
        "required": [
          "Name",
          "Inputs",
          "Path",
          "Compression",
          "Format"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the data target."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/OneInput"
              },
              {
                "description": "The nodes that are inputs to the data target."
              }
            ]
          },
          "PartitionKeys": {
            "allOf": [
              {
                "$ref": "#/$defs/GlueStudioPathList"
              },
              {
                "description": "Specifies native partitioning using a sequence of keys."
              }
            ]
          },
          "Path": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The Amazon S3 path of your Delta Lake data source to write to."
              }
            ]
          },
          "Compression": {
            "allOf": [
              {
                "$ref": "#/$defs/DeltaTargetCompressionType"
              },
              {
                "description": "Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are <code>\"gzip\"</code> and <code>\"bzip\"</code>)."
              }
            ]
          },
          "Format": {
            "allOf": [
              {
                "$ref": "#/$defs/TargetFormat"
              },
              {
                "description": "Specifies the data output format for the target."
              }
            ]
          },
          "AdditionalOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/AdditionalOptions"
              },
              {
                "description": "Specifies additional connection options for the connector."
              }
            ]
          },
          "SchemaChangePolicy": {
            "allOf": [
              {
                "$ref": "#/$defs/DirectSchemaChangePolicy"
              },
              {
                "description": "A policy that specifies update behavior for the crawler."
              }
            ]
          }
        },
        "description": "Specifies a target that writes to a Delta Lake data source in Amazon S3."
      },
      "DeltaTargetCompressionType": {
        "type": "string",
        "enum": [
          "uncompressed",
          "snappy"
        ]
      },
      "AmazonRedshiftSource": {
        "type": "object",
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the Amazon Redshift source."
              }
            ]
          },
          "Data": {
            "allOf": [
              {
                "$ref": "#/$defs/AmazonRedshiftNodeData"
              },
              {
                "description": "Specifies the data of the Amazon Reshift source node."
              }
            ]
          }
        },
        "description": "Specifies an Amazon Redshift source."
      },
      "AmazonRedshiftNodeData": {
        "type": "object",
        "properties": {
          "AccessType": {
            "allOf": [
              {
                "$ref": "#/$defs/GenericLimitedString"
              },
              {
                "description": "The access type for the Redshift connection. Can be a direct connection or catalog connections."
              }
            ]
          },
          "SourceType": {
            "allOf": [
              {
                "$ref": "#/$defs/GenericLimitedString"
              },
              {
                "description": "The source type to specify whether a specific table is the source or a custom query."
              }
            ]
          },
          "Connection": {
            "allOf": [
              {
                "$ref": "#/$defs/Option"
              },
              {
                "description": "The Glue connection to the Redshift cluster."
              }
            ]
          },
          "Schema": {
            "allOf": [
              {
                "$ref": "#/$defs/Option"
              },
              {
                "description": "The Redshift schema name when working with a direct connection."
              }
            ]
          },
          "Table": {
            "allOf": [
              {
                "$ref": "#/$defs/Option"
              },
              {
                "description": "The Redshift table name when working with a direct connection."
              }
            ]
          },
          "CatalogDatabase": {
            "allOf": [
              {
                "$ref": "#/$defs/Option"
              },
              {
                "description": "The name of the Glue Data Catalog database when working with a data catalog."
              }
            ]
          },
          "CatalogTable": {
            "allOf": [
              {
                "$ref": "#/$defs/Option"
              },
              {
                "description": "The Glue Data Catalog table name when working with a data catalog."
              }
            ]
          },
          "CatalogRedshiftSchema": {
            "allOf": [
              {
                "$ref": "#/$defs/GenericString"
              },
              {
                "description": "The Redshift schema name when working with a data catalog."
              }
            ]
          },
          "CatalogRedshiftTable": {
            "allOf": [
              {
                "$ref": "#/$defs/GenericString"
              },
              {
                "description": "The database table to read from."
              }
            ]
          },
          "TempDir": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The Amazon S3 path where temporary data can be staged when copying out of the database."
              }
            ]
          },
          "IamRole": {
            "allOf": [
              {
                "$ref": "#/$defs/Option"
              },
              {
                "description": "Optional. The role name use when connection to S3. The IAM role ill default to the role on the job when left blank."
              }
            ]
          },
          "AdvancedOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/AmazonRedshiftAdvancedOptions"
              },
              {
                "description": "Optional values when connecting to the Redshift cluster."
              }
            ]
          },
          "SampleQuery": {
            "allOf": [
              {
                "$ref": "#/$defs/GenericString"
              },
              {
                "description": "The SQL used to fetch the data from a Redshift sources when the SourceType is 'query'."
              }
            ]
          },
          "PreAction": {
            "allOf": [
              {
                "$ref": "#/$defs/GenericString"
              },
              {
                "description": "The SQL used before a MERGE or APPEND with upsert is run."
              }
            ]
          },
          "PostAction": {
            "allOf": [
              {
                "$ref": "#/$defs/GenericString"
              },
              {
                "description": "The SQL used before a MERGE or APPEND with upsert is run."
              }
            ]
          },
          "Action": {
            "allOf": [
              {
                "$ref": "#/$defs/GenericString"
              },
              {
                "description": "Specifies how writing to a Redshift cluser will occur."
              }
            ]
          },
          "TablePrefix": {
            "allOf": [
              {
                "$ref": "#/$defs/GenericLimitedString"
              },
              {
                "description": "Specifies the prefix to a table."
              }
            ]
          },
          "Upsert": {
            "allOf": [
              {
                "$ref": "#/$defs/BooleanValue"
              },
              {
                "description": "The action used on Redshift sinks when doing an APPEND."
              }
            ]
          },
          "MergeAction": {
            "allOf": [
              {
                "$ref": "#/$defs/GenericLimitedString"
              },
              {
                "description": "The action used when to detemine how a MERGE in a Redshift sink will be handled."
              }
            ]
          },
          "MergeWhenMatched": {
            "allOf": [
              {
                "$ref": "#/$defs/GenericLimitedString"
              },
              {
                "description": "The action used when to detemine how a MERGE in a Redshift sink will be handled when an existing record matches a new record."
              }
            ]
          },
          "MergeWhenNotMatched": {
            "allOf": [
              {
                "$ref": "#/$defs/GenericLimitedString"
              },
              {
                "description": "The action used when to detemine how a MERGE in a Redshift sink will be handled when an existing record doesn't match a new record."
              }
            ]
          },
          "MergeClause": {
            "allOf": [
              {
                "$ref": "#/$defs/GenericString"
              },
              {
                "description": "The SQL used in a custom merge to deal with matching records."
              }
            ]
          },
          "CrawlerConnection": {
            "allOf": [
              {
                "$ref": "#/$defs/GenericString"
              },
              {
                "description": "Specifies the name of the connection that is associated with the catalog table used."
              }
            ]
          },
          "TableSchema": {
            "allOf": [
              {
                "$ref": "#/$defs/OptionList"
              },
              {
                "description": "The array of schema output for a given node."
              }
            ]
          },
          "StagingTable": {
            "allOf": [
              {
                "$ref": "#/$defs/GenericString"
              },
              {
                "description": "The name of the temporary staging table that is used when doing a MERGE or APPEND with upsert."
              }
            ]
          },
          "SelectedColumns": {
            "allOf": [
              {
                "$ref": "#/$defs/OptionList"
              },
              {
                "description": "The list of column names used to determine a matching record when doing a MERGE or APPEND with upsert."
              }
            ]
          }
        },
        "description": "Specifies an Amazon Redshift node."
      },
      "Option": {
        "type": "object",
        "properties": {
          "Value": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "Specifies the value of the option."
              }
            ]
          },
          "Label": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "Specifies the label of the option."
              }
            ]
          },
          "Description": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "Specifies the description of the option."
              }
            ]
          }
        },
        "description": "Specifies an option value."
      },
      "AmazonRedshiftAdvancedOptions": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/AmazonRedshiftAdvancedOption"
        }
      },
      "AmazonRedshiftAdvancedOption": {
        "type": "object",
        "properties": {
          "Key": {
            "allOf": [
              {
                "$ref": "#/$defs/GenericString"
              },
              {
                "description": "The key for the additional connection option."
              }
            ]
          },
          "Value": {
            "allOf": [
              {
                "$ref": "#/$defs/GenericString"
              },
              {
                "description": "The value for the additional connection option."
              }
            ]
          }
        },
        "description": "Specifies an optional value when connecting to the Redshift cluster."
      },
      "OptionList": {
        "type": "array",
        "items": {
          "$ref": "#/$defs/Option"
        }
      },
      "AmazonRedshiftTarget": {
        "type": "object",
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the Amazon Redshift target."
              }
            ]
          },
          "Data": {
            "allOf": [
              {
                "$ref": "#/$defs/AmazonRedshiftNodeData"
              },
              {
                "description": "Specifies the data of the Amazon Redshift target node."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/OneInput"
              },
              {
                "description": "The nodes that are inputs to the data target."
              }
            ]
          }
        },
        "description": "Specifies an Amazon Redshift target."
      },
      "EvaluateDataQualityMultiFrame": {
        "type": "object",
        "required": [
          "Name",
          "Inputs",
          "Ruleset"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the data quality evaluation."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/ManyInputs"
              },
              {
                "description": "The inputs of your data quality evaluation. The first input in this list is the primary data source."
              }
            ]
          },
          "AdditionalDataSources": {
            "allOf": [
              {
                "$ref": "#/$defs/DQDLAliases"
              },
              {
                "description": "The aliases of all data sources except primary."
              }
            ]
          },
          "Ruleset": {
            "allOf": [
              {
                "$ref": "#/$defs/DQDLString"
              },
              {
                "description": "The ruleset for your data quality evaluation."
              }
            ]
          },
          "PublishingOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/DQResultsPublishingOptions"
              },
              {
                "description": "Options to configure how your results are published."
              }
            ]
          },
          "AdditionalOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/DQAdditionalOptions"
              },
              {
                "description": "Options to configure runtime behavior of the transform."
              }
            ]
          },
          "StopJobOnFailureOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/DQStopJobOnFailureOptions"
              },
              {
                "description": "Options to configure how your job will stop if your data quality evaluation fails."
              }
            ]
          }
        },
        "description": "Specifies your data quality evaluation criteria."
      },
      "DQDLAliases": {
        "type": "object",
        "additionalProperties": {
          "$ref": "#/$defs/EnclosedInStringProperty"
        }
      },
      "DQAdditionalOptions": {
        "type": "object",
        "additionalProperties": {
          "$ref": "#/$defs/GenericString"
        }
      },
      "Recipe": {
        "type": "object",
        "required": [
          "Name",
          "Inputs",
          "RecipeReference"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the Glue Studio node."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/OneInput"
              },
              {
                "description": "The nodes that are inputs to the recipe node, identified by id."
              }
            ]
          },
          "RecipeReference": {
            "allOf": [
              {
                "$ref": "#/$defs/RecipeReference"
              },
              {
                "description": "A reference to the DataBrew recipe used by the node."
              }
            ]
          }
        },
        "description": "A Glue Studio node that uses a Glue DataBrew recipe in Glue jobs."
      },
      "RecipeReference": {
        "type": "object",
        "required": [
          "RecipeArn",
          "RecipeVersion"
        ],
        "properties": {
          "RecipeArn": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "The ARN of the DataBrew recipe."
              }
            ]
          },
          "RecipeVersion": {
            "allOf": [
              {
                "$ref": "#/$defs/RecipeVersion"
              },
              {
                "description": "The RecipeVersion of the DataBrew recipe."
              }
            ]
          }
        },
        "description": "A reference to a Glue DataBrew recipe."
      },
      "RecipeVersion": {
        "type": "string",
        "minLength": 1,
        "maxLength": 16
      },
      "SnowflakeSource": {
        "type": "object",
        "required": [
          "Name",
          "Data"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the Snowflake data source."
              }
            ]
          },
          "Data": {
            "allOf": [
              {
                "$ref": "#/$defs/SnowflakeNodeData"
              },
              {
                "description": "Configuration for the Snowflake data source."
              }
            ]
          },
          "OutputSchemas": {
            "allOf": [
              {
                "$ref": "#/$defs/GlueSchemas"
              },
              {
                "description": "Specifies user-defined schemas for your output data."
              }
            ]
          }
        },
        "description": "Specifies a Snowflake data source."
      },
      "SnowflakeNodeData": {
        "type": "object",
        "properties": {
          "SourceType": {
            "allOf": [
              {
                "$ref": "#/$defs/GenericLimitedString"
              },
              {
                "description": "Specifies how retrieved data is specified. Valid values: <code>\"table\"</code>, <code> \"query\"</code>."
              }
            ]
          },
          "Connection": {
            "allOf": [
              {
                "$ref": "#/$defs/Option"
              },
              {
                "description": "Specifies a Glue Data Catalog Connection to a Snowflake endpoint."
              }
            ]
          },
          "Schema": {
            "allOf": [
              {
                "$ref": "#/$defs/GenericString"
              },
              {
                "description": "Specifies a Snowflake database schema for your node to use."
              }
            ]
          },
          "Table": {
            "allOf": [
              {
                "$ref": "#/$defs/GenericString"
              },
              {
                "description": "Specifies a Snowflake table for your node to use."
              }
            ]
          },
          "Database": {
            "allOf": [
              {
                "$ref": "#/$defs/GenericString"
              },
              {
                "description": "Specifies a Snowflake database for your node to use."
              }
            ]
          },
          "TempDir": {
            "allOf": [
              {
                "$ref": "#/$defs/EnclosedInStringProperty"
              },
              {
                "description": "Not currently used."
              }
            ]
          },
          "IamRole": {
            "allOf": [
              {
                "$ref": "#/$defs/Option"
              },
              {
                "description": "Not currently used."
              }
            ]
          },
          "AdditionalOptions": {
            "allOf": [
              {
                "$ref": "#/$defs/AdditionalOptions"
              },
              {
                "description": "Specifies additional options passed to the Snowflake connector. If options are specified elsewhere in this node, this will take precedence."
              }
            ]
          },
          "SampleQuery": {
            "allOf": [
              {
                "$ref": "#/$defs/GenericString"
              },
              {
                "description": "A SQL string used to retrieve data with the <code>query</code> sourcetype."
              }
            ]
          },
          "PreAction": {
            "allOf": [
              {
                "$ref": "#/$defs/GenericString"
              },
              {
                "description": "A SQL string run before the Snowflake connector performs its standard actions."
              }
            ]
          },
          "PostAction": {
            "allOf": [
              {
                "$ref": "#/$defs/GenericString"
              },
              {
                "description": "A SQL string run after the Snowflake connector performs its standard actions."
              }
            ]
          },
          "Action": {
            "allOf": [
              {
                "$ref": "#/$defs/GenericString"
              },
              {
                "description": "Specifies what action to take when writing to a table with preexisting data. Valid values: <code> append</code>, <code>merge</code>, <code>truncate</code>, <code>drop</code>."
              }
            ]
          },
          "Upsert": {
            "allOf": [
              {
                "$ref": "#/$defs/BooleanValue"
              },
              {
                "description": "Used when Action is <code>append</code>. Specifies the resolution behavior when a row already exists. If true, preexisting rows will be updated. If false, those rows will be inserted."
              }
            ]
          },
          "MergeAction": {
            "allOf": [
              {
                "$ref": "#/$defs/GenericLimitedString"
              },
              {
                "description": "Specifies a merge action. Valid values: <code>simple</code>, <code>custom</code>. If simple, merge behavior is defined by <code>MergeWhenMatched</code> and <code> MergeWhenNotMatched</code>. If custom, defined by <code>MergeClause</code>."
              }
            ]
          },
          "MergeWhenMatched": {
            "allOf": [
              {
                "$ref": "#/$defs/GenericLimitedString"
              },
              {
                "description": "Specifies how to resolve records that match preexisting data when merging. Valid values: <code> update</code>, <code>delete</code>."
              }
            ]
          },
          "MergeWhenNotMatched": {
            "allOf": [
              {
                "$ref": "#/$defs/GenericLimitedString"
              },
              {
                "description": "Specifies how to process records that do not match preexisting data when merging. Valid values: <code>insert</code>, <code>none</code>."
              }
            ]
          },
          "MergeClause": {
            "allOf": [
              {
                "$ref": "#/$defs/GenericString"
              },
              {
                "description": "A SQL statement that specifies a custom merge behavior."
              }
            ]
          },
          "StagingTable": {
            "allOf": [
              {
                "$ref": "#/$defs/GenericString"
              },
              {
                "description": "The name of a staging table used when performing <code>merge</code> or upsert <code>append</code> actions. Data is written to this table, then moved to <code>table</code> by a generated postaction."
              }
            ]
          },
          "SelectedColumns": {
            "allOf": [
              {
                "$ref": "#/$defs/OptionList"
              },
              {
                "description": "Specifies the columns combined to identify a record when detecting matches for merges and upserts. A list of structures with <code>value</code>, <code>label</code> and <code> description</code> keys. Each structure describes a column."
              }
            ]
          },
          "AutoPushdown": {
            "allOf": [
              {
                "$ref": "#/$defs/BooleanValue"
              },
              {
                "description": "Specifies whether automatic query pushdown is enabled. If pushdown is enabled, then when a query is run on Spark, if part of the query can be \"pushed down\" to the Snowflake server, it is pushed down. This improves performance of some queries."
              }
            ]
          },
          "TableSchema": {
            "allOf": [
              {
                "$ref": "#/$defs/OptionList"
              },
              {
                "description": "Manually defines the target schema for the node. A list of structures with <code>value</code> , <code>label</code> and <code>description</code> keys. Each structure defines a column."
              }
            ]
          }
        },
        "description": "Specifies configuration for Snowflake nodes in Glue Studio."
      },
      "SnowflakeTarget": {
        "type": "object",
        "required": [
          "Name",
          "Data"
        ],
        "properties": {
          "Name": {
            "allOf": [
              {
                "$ref": "#/$defs/NodeName"
              },
              {
                "description": "The name of the Snowflake target."
              }
            ]
          },
          "Data": {
            "allOf": [
              {
                "$ref": "#/$defs/SnowflakeNodeData"
              },
              {
                "description": "Specifies the data of the Snowflake target node."
              }
            ]
          },
          "Inputs": {
            "allOf": [
              {
                "$ref": "#/$defs/OneInput"
              },
              {
                "description": "The nodes that are inputs to the data target."
              }
            ]
          }
        },
        "description": "Specifies a Snowflake target."
      },
      "ExecutionClass": {
        "type": "string",
        "enum": [
          "FLEX",
          "STANDARD"
        ],
        "maxLength": 16
      },
      "SourceControlDetails": {
        "type": "object",
        "properties": {
          "Provider": {
            "allOf": [
              {
                "$ref": "#/$defs/SourceControlProvider"
              },
              {
                "description": "The provider for the remote repository."
              }
            ]
          },
          "Repository": {
            "allOf": [
              {
                "$ref": "#/$defs/Generic512CharString"
              },
              {
                "description": "The name of the remote repository that contains the job artifacts."
              }
            ]
          },
          "Owner": {
            "allOf": [
              {
                "$ref": "#/$defs/Generic512CharString"
              },
              {
                "description": "The owner of the remote repository that contains the job artifacts."
              }
            ]
          },
          "Branch": {
            "allOf": [
              {
                "$ref": "#/$defs/Generic512CharString"
              },
              {
                "description": "An optional branch in the remote repository."
              }
            ]
          },
          "Folder": {
            "allOf": [
              {
                "$ref": "#/$defs/Generic512CharString"
              },
              {
                "description": "An optional folder in the remote repository."
              }
            ]
          },
          "LastCommitId": {
            "allOf": [
              {
                "$ref": "#/$defs/Generic512CharString"
              },
              {
                "description": "The last commit ID for a commit in the remote repository."
              }
            ]
          },
          "AuthStrategy": {
            "allOf": [
              {
                "$ref": "#/$defs/SourceControlAuthStrategy"
              },
              {
                "description": "The type of authentication, which can be an authentication token stored in Amazon Web Services Secrets Manager, or a personal access token."
              }
            ]
          },
          "AuthToken": {
            "allOf": [
              {
                "$ref": "#/$defs/Generic512CharString"
              },
              {
                "description": "The value of an authorization token."
              }
            ]
          }
        },
        "description": "The details for a source control configuration for a job, allowing synchronization of job artifacts to or from a remote repository."
      },
      "SourceControlProvider": {
        "type": "string",
        "enum": [
          "GITHUB",
          "AWS_CODE_COMMIT"
        ]
      },
      "Generic512CharString": {
        "type": "string",
        "minLength": 1,
        "maxLength": 512
      },
      "SourceControlAuthStrategy": {
        "type": "string",
        "enum": [
          "PERSONAL_ACCESS_TOKEN",
          "AWS_SECRETS_MANAGER"
        ]
      }
    }
  },
  "handler": "http",
  "request": {
    "method": "POST",
    "url": {
      "$uri": "http://glue.us-east-1.amazonaws.com/#X-Amz-Target=AWSGlue.CreateJob"
    },
    "headers": {
      "X-Amz-Target": {
        "$": "X-Amz-Target"
      },
      "X-Amz-Content-Sha256": {
        "$": "X-Amz-Content-Sha256"
      },
      "X-Amz-Date": {
        "$": "X-Amz-Date"
      },
      "X-Amz-Algorithm": {
        "$": "X-Amz-Algorithm"
      },
      "X-Amz-Credential": {
        "$": "X-Amz-Credential"
      },
      "X-Amz-Security-Token": {
        "$": "X-Amz-Security-Token"
      },
      "X-Amz-Signature": {
        "$": "X-Amz-Signature"
      },
      "X-Amz-SignedHeaders": {
        "$": "X-Amz-SignedHeaders"
      }
    },
    "body": {
      "$": "body",
      "encode": "json"
    }
  },
  "responses": {
    "200": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "**Key properties:**",
        {
          "$ul": [
            "**Name**"
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    },
    "480": {
      "$encode": "markdown",
      "$lang": "json",
      "$code": {
        "$encode": "json",
        "$indent": true,
        "$content": {
          "$": "$.body"
        }
      }
    },
    "481": {
      "$encode": "markdown",
      "$lang": "json",
      "$code": {
        "$encode": "json",
        "$indent": true,
        "$content": {
          "$": "$.body"
        }
      }
    },
    "482": {
      "$encode": "markdown",
      "$lang": "json",
      "$code": {
        "$encode": "json",
        "$indent": true,
        "$content": {
          "$": "$.body"
        }
      }
    },
    "483": {
      "$encode": "markdown",
      "$lang": "json",
      "$code": {
        "$encode": "json",
        "$indent": true,
        "$content": {
          "$": "$.body"
        }
      }
    },
    "484": {
      "$encode": "markdown",
      "$lang": "json",
      "$code": {
        "$encode": "json",
        "$indent": true,
        "$content": {
          "$": "$.body"
        }
      }
    },
    "485": {
      "$encode": "markdown",
      "$lang": "json",
      "$code": {
        "$encode": "json",
        "$indent": true,
        "$content": {
          "$": "$.body"
        }
      }
    },
    "486": {
      "$encode": "markdown",
      "$lang": "json",
      "$code": {
        "$encode": "json",
        "$indent": true,
        "$content": {
          "$": "$.body"
        }
      }
    }
  }
}
