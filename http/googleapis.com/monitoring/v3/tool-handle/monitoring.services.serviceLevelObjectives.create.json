{
  "name": "monitoring_services_serviceLevelObjectives_create",
  "description": "Create a ServiceLevelObjective for the given Service.",
  "parameters": {
    "type": "object",
    "properties": {
      "parent": {
        "type": "string",
        "description": "Required. Resource name of the parent Service. The format is: projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID] "
      },
      "serviceLevelObjectiveId": {
        "type": "string",
        "description": "Optional. The ServiceLevelObjective id to use for this ServiceLevelObjective. If omitted, an id will be generated instead. Must match the pattern ^[a-zA-Z0-9-_:.]+$"
      },
      "$.xgafv": {
        "enum": [
          "1",
          "2"
        ],
        "type": "string",
        "description": "V1 error format."
      },
      "access_token": {
        "type": "string",
        "description": "OAuth access token."
      },
      "alt": {
        "enum": [
          "json",
          "media",
          "proto"
        ],
        "type": "string",
        "description": "Data format for response."
      },
      "callback": {
        "type": "string",
        "description": "JSONP"
      },
      "fields": {
        "type": "string",
        "description": "Selector specifying which fields to include in a partial response."
      },
      "key": {
        "type": "string",
        "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
      },
      "oauth_token": {
        "type": "string",
        "description": "OAuth 2.0 token for the current user."
      },
      "prettyPrint": {
        "type": "boolean",
        "description": "Returns response with indentations and line breaks."
      },
      "quotaUser": {
        "type": "string",
        "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
      },
      "upload_protocol": {
        "type": "string",
        "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
      },
      "uploadType": {
        "type": "string",
        "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
      },
      "body": {
        "$ref": "#/$defs/ServiceLevelObjective"
      }
    },
    "required": [
      "parent"
    ],
    "$defs": {
      "ServiceLevelObjective": {
        "description": "A Service-Level Objective (SLO) describes a level of desired good service. It consists of a service-level indicator (SLI), a performance goal, and a period over which the objective is to be evaluated against that goal. The SLO can use SLIs defined in a number of different manners. Typical SLOs might include \"99% of requests in each rolling week have latency below 200 milliseconds\" or \"99.5% of requests in each calendar month return successfully.\"",
        "properties": {
          "calendarPeriod": {
            "description": "A calendar period, semantically \"since the start of the current \". At this time, only DAY, WEEK, FORTNIGHT, and MONTH are supported.",
            "enum": [
              "CALENDAR_PERIOD_UNSPECIFIED",
              "DAY",
              "WEEK",
              "FORTNIGHT",
              "MONTH",
              "QUARTER",
              "HALF",
              "YEAR"
            ],
            "type": "string"
          },
          "displayName": {
            "description": "Name used for UI elements listing this SLO.",
            "type": "string"
          },
          "goal": {
            "description": "The fraction of service that must be good in order for this objective to be met. 0 < goal <= 0.999.",
            "format": "double",
            "type": "number"
          },
          "name": {
            "description": "Resource name for this ServiceLevelObjective. The format is: projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME] ",
            "type": "string"
          },
          "rollingPeriod": {
            "description": "A rolling time period, semantically \"in the past \". Must be an integer multiple of 1 day no larger than 30 days.",
            "format": "google-duration",
            "type": "string"
          },
          "serviceLevelIndicator": {
            "$ref": "#/$defs/ServiceLevelIndicator"
          },
          "userLabels": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Labels which have been used to annotate the service-level objective. Label keys must start with a letter. Label keys and values may contain lowercase letters, numbers, underscores, and dashes. Label keys and values have a maximum length of 63 characters, and must be less than 128 bytes in size. Up to 64 label entries may be stored. For labels which do not have a semantic value, the empty string may be supplied for the label value.",
            "type": "object"
          }
        },
        "type": "object"
      },
      "ServiceLevelIndicator": {
        "description": "A Service-Level Indicator (SLI) describes the \"performance\" of a service. For some services, the SLI is well-defined. In such cases, the SLI can be described easily by referencing the well-known SLI and providing the needed parameters. Alternatively, a \"custom\" SLI can be defined with a query to the underlying metric store. An SLI is defined to be good_service / total_service over any queried time interval. The value of performance always falls into the range 0 <= performance <= 1. A custom SLI describes how to compute this ratio, whether this is by dividing values from a pair of time series, cutting a Distribution into good and bad counts, or counting time windows in which the service complies with a criterion. For separation of concerns, a single Service-Level Indicator measures performance for only one aspect of service quality, such as fraction of successful queries or fast-enough queries.",
        "properties": {
          "basicSli": {
            "$ref": "#/$defs/BasicSli"
          },
          "requestBased": {
            "$ref": "#/$defs/RequestBasedSli"
          },
          "windowsBased": {
            "$ref": "#/$defs/WindowsBasedSli"
          }
        },
        "type": "object"
      },
      "BasicSli": {
        "description": "An SLI measuring performance on a well-known service type. Performance will be computed on the basis of pre-defined metrics. The type of the service_resource determines the metrics to use and the service_resource.labels and metric_labels are used to construct a monitoring filter to filter that metric down to just the data relevant to this service.",
        "properties": {
          "availability": {
            "$ref": "#/$defs/AvailabilityCriteria"
          },
          "latency": {
            "$ref": "#/$defs/LatencyCriteria"
          },
          "location": {
            "description": "OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don't support breaking down by location, setting this field will result in an error.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "method": {
            "description": "OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service's methods. For service types that don't support breaking down by method, setting this field will result in an error.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "version": {
            "description": "OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don't support breaking down by version, setting this field will result in an error.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "AvailabilityCriteria": {
        "description": "Future parameters for the availability SLI.",
        "properties": {},
        "type": "object"
      },
      "LatencyCriteria": {
        "description": "Parameters for a latency threshold SLI.",
        "properties": {
          "threshold": {
            "description": "Good service is defined to be the count of requests made to this service that return in no more than threshold.",
            "format": "google-duration",
            "type": "string"
          }
        },
        "type": "object"
      },
      "RequestBasedSli": {
        "description": "Service Level Indicators for which atomic units of service are counted directly.",
        "properties": {
          "distributionCut": {
            "$ref": "#/$defs/DistributionCut"
          },
          "goodTotalRatio": {
            "$ref": "#/$defs/TimeSeriesRatio"
          }
        },
        "type": "object"
      },
      "DistributionCut": {
        "description": "A DistributionCut defines a TimeSeries and thresholds used for measuring good service and total service. The TimeSeries must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE. The computed good_service will be the estimated count of values in the Distribution that fall within the specified min and max.",
        "properties": {
          "distributionFilter": {
            "description": "A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries aggregating values. Must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE.",
            "type": "string"
          },
          "range": {
            "$ref": "#/$defs/GoogleMonitoringV3Range"
          }
        },
        "type": "object"
      },
      "GoogleMonitoringV3Range": {
        "description": "Range of numerical values within min and max.",
        "properties": {
          "max": {
            "description": "Range maximum.",
            "format": "double",
            "type": "number"
          },
          "min": {
            "description": "Range minimum.",
            "format": "double",
            "type": "number"
          }
        },
        "type": "object"
      },
      "TimeSeriesRatio": {
        "description": "A TimeSeriesRatio specifies two TimeSeries to use for computing the good_service / total_service ratio. The specified TimeSeries must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE. The TimeSeriesRatio must specify exactly two of good, bad, and total, and the relationship good_service + bad_service = total_service will be assumed.",
        "properties": {
          "badServiceFilter": {
            "description": "A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.",
            "type": "string"
          },
          "goodServiceFilter": {
            "description": "A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying good service provided. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.",
            "type": "string"
          },
          "totalServiceFilter": {
            "description": "A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying total demanded service. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "WindowsBasedSli": {
        "description": "A WindowsBasedSli defines good_service as the count of time windows for which the provided service was of good quality. Criteria for determining if service was good are embedded in the window_criterion.",
        "properties": {
          "goodBadMetricFilter": {
            "description": "A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries with ValueType = BOOL. The window is good if any true values appear in the window.",
            "type": "string"
          },
          "goodTotalRatioThreshold": {
            "$ref": "#/$defs/PerformanceThreshold"
          },
          "metricMeanInRange": {
            "$ref": "#/$defs/MetricRange"
          },
          "metricSumInRange": {
            "$ref": "#/$defs/MetricRange"
          },
          "windowPeriod": {
            "description": "Duration over which window quality is evaluated. Must be an integer fraction of a day and at least 60s.",
            "format": "google-duration",
            "type": "string"
          }
        },
        "type": "object"
      },
      "PerformanceThreshold": {
        "description": "A PerformanceThreshold is used when each window is good when that window has a sufficiently high performance.",
        "properties": {
          "basicSliPerformance": {
            "$ref": "#/$defs/BasicSli"
          },
          "performance": {
            "$ref": "#/$defs/RequestBasedSli"
          },
          "threshold": {
            "description": "If window performance >= threshold, the window is counted as good.",
            "format": "double",
            "type": "number"
          }
        },
        "type": "object"
      },
      "MetricRange": {
        "description": "A MetricRange is used when each window is good when the value x of a single TimeSeries satisfies range.min <= x <= range.max. The provided TimeSeries must have ValueType = INT64 or ValueType = DOUBLE and MetricKind = GAUGE.",
        "properties": {
          "range": {
            "$ref": "#/$defs/GoogleMonitoringV3Range"
          },
          "timeSeries": {
            "description": "A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying the TimeSeries to use for evaluating window quality.",
            "type": "string"
          }
        },
        "type": "object"
      }
    }
  },
  "handler": "http",
  "request": {
    "method": "POST",
    "url": {
      "$uri": "https://monitoring.googleapis.com//v3/{parent}/serviceLevelObjectives{?serviceLevelObjectiveId,$.xgafv,access_token,alt,callback,fields,key,oauth_token,prettyPrint,quotaUser,upload_protocol,uploadType}"
    },
    "body": {
      "$": "body",
      "encode": "json"
    }
  },
  "responses": {
    "200": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "A Service-Level Objective (SLO) describes a level of desired good service. It consists of a service-level indicator (SLI), a performance goal, and a period over which the objective is to be evaluated against that goal. The SLO can use SLIs defined in a number of different manners. Typical SLOs might include \"99% of requests in each rolling week have latency below 200 milliseconds\" or \"99.5% of requests in each calendar month return successfully.\"",
        "**Key properties:**",
        {
          "$ul": [
            "**calendarPeriod**: A calendar period, semantically \"since the start of the current \". At this time, only DAY, WEEK, FORTNIGHT, and MONTH are supported.",
            "**displayName**: Name used for UI elements listing this SLO.",
            "**goal**: The fraction of service that must be good in order for this objective to be met. 0 < goal <= 0.999.",
            "**name**: Resource name for this ServiceLevelObjective. The format is: projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME] ",
            "**rollingPeriod**: A rolling time period, semantically \"in the past \". Must be an integer multiple of 1 day no larger than 30 days.",
            [
              "**serviceLevelIndicator**: A Service-Level Indicator (SLI) describes the \"performance\" of a service. For some services, the SLI is well-defined. In such cases, the SLI can be described easily by referencing the well-known SLI and providing the needed parameters. Alternatively, a \"custom\" SLI can be defined with a query to the underlying metric store. An SLI is defined to be good_service / total_service over any queried time interval. The value of performance always falls into the range 0 <= performance <= 1. A custom SLI describes how to compute this ratio, whether this is by dividing values from a pair of time series, cutting a Distribution into good and bad counts, or counting time windows in which the service complies with a criterion. For separation of concerns, a single Service-Level Indicator measures performance for only one aspect of service quality, such as fraction of successful queries or fast-enough queries.",
              {
                "$ul": [
                  [
                    "**basicSli**: An SLI measuring performance on a well-known service type. Performance will be computed on the basis of pre-defined metrics. The type of the service_resource determines the metrics to use and the service_resource.labels and metric_labels are used to construct a monitoring filter to filter that metric down to just the data relevant to this service.",
                    {
                      "$ul": [
                        "**availability**: Future parameters for the availability SLI.",
                        [
                          "**latency**: Parameters for a latency threshold SLI.",
                          {
                            "$ul": [
                              "**threshold**: Good service is defined to be the count of requests made to this service that return in no more than threshold."
                            ]
                          }
                        ],
                        "**location**: OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don't support breaking down by location, setting this field will result in an error.",
                        "**method**: OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service's methods. For service types that don't support breaking down by method, setting this field will result in an error.",
                        "**version**: OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don't support breaking down by version, setting this field will result in an error."
                      ]
                    }
                  ],
                  [
                    "**requestBased**: Service Level Indicators for which atomic units of service are counted directly.",
                    {
                      "$ul": [
                        [
                          "**distributionCut**: A DistributionCut defines a TimeSeries and thresholds used for measuring good service and total service. The TimeSeries must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE. The computed good_service will be the estimated count of values in the Distribution that fall within the specified min and max.",
                          {
                            "$ul": [
                              "**distributionFilter**: A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries aggregating values. Must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE.",
                              [
                                "**range**: Range of numerical values within min and max.",
                                {
                                  "$ul": [
                                    "**max**: Range maximum.",
                                    "**min**: Range minimum."
                                  ]
                                }
                              ]
                            ]
                          }
                        ],
                        [
                          "**goodTotalRatio**: A TimeSeriesRatio specifies two TimeSeries to use for computing the good_service / total_service ratio. The specified TimeSeries must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE. The TimeSeriesRatio must specify exactly two of good, bad, and total, and the relationship good_service + bad_service = total_service will be assumed.",
                          {
                            "$ul": [
                              "**badServiceFilter**: A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.",
                              "**goodServiceFilter**: A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying good service provided. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.",
                              "**totalServiceFilter**: A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying total demanded service. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE."
                            ]
                          }
                        ]
                      ]
                    }
                  ],
                  [
                    "**windowsBased**: A WindowsBasedSli defines good_service as the count of time windows for which the provided service was of good quality. Criteria for determining if service was good are embedded in the window_criterion.",
                    {
                      "$ul": [
                        "**goodBadMetricFilter**: A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries with ValueType = BOOL. The window is good if any true values appear in the window.",
                        [
                          "**goodTotalRatioThreshold**: A PerformanceThreshold is used when each window is good when that window has a sufficiently high performance.",
                          {
                            "$ul": [
                              [
                                "**basicSliPerformance**: An SLI measuring performance on a well-known service type. Performance will be computed on the basis of pre-defined metrics. The type of the service_resource determines the metrics to use and the service_resource.labels and metric_labels are used to construct a monitoring filter to filter that metric down to just the data relevant to this service.",
                                {
                                  "$ul": [
                                    "**availability**: Future parameters for the availability SLI.",
                                    [
                                      "**latency**: Parameters for a latency threshold SLI.",
                                      {
                                        "$ul": [
                                          "**threshold**: Good service is defined to be the count of requests made to this service that return in no more than threshold."
                                        ]
                                      }
                                    ],
                                    "**location**: OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don't support breaking down by location, setting this field will result in an error.",
                                    "**method**: OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service's methods. For service types that don't support breaking down by method, setting this field will result in an error.",
                                    "**version**: OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don't support breaking down by version, setting this field will result in an error."
                                  ]
                                }
                              ],
                              [
                                "**performance**: Service Level Indicators for which atomic units of service are counted directly.",
                                {
                                  "$ul": [
                                    [
                                      "**distributionCut**: A DistributionCut defines a TimeSeries and thresholds used for measuring good service and total service. The TimeSeries must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE. The computed good_service will be the estimated count of values in the Distribution that fall within the specified min and max.",
                                      {
                                        "$ul": [
                                          "**distributionFilter**: A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries aggregating values. Must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE.",
                                          [
                                            "**range**: Range of numerical values within min and max.",
                                            {
                                              "$ul": [
                                                "**max**: Range maximum.",
                                                "**min**: Range minimum."
                                              ]
                                            }
                                          ]
                                        ]
                                      }
                                    ],
                                    [
                                      "**goodTotalRatio**: A TimeSeriesRatio specifies two TimeSeries to use for computing the good_service / total_service ratio. The specified TimeSeries must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE. The TimeSeriesRatio must specify exactly two of good, bad, and total, and the relationship good_service + bad_service = total_service will be assumed.",
                                      {
                                        "$ul": [
                                          "**badServiceFilter**: A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.",
                                          "**goodServiceFilter**: A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying good service provided. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.",
                                          "**totalServiceFilter**: A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying total demanded service. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE."
                                        ]
                                      }
                                    ]
                                  ]
                                }
                              ],
                              "**threshold**: If window performance >= threshold, the window is counted as good."
                            ]
                          }
                        ],
                        [
                          "**metricMeanInRange**: A MetricRange is used when each window is good when the value x of a single TimeSeries satisfies range.min <= x <= range.max. The provided TimeSeries must have ValueType = INT64 or ValueType = DOUBLE and MetricKind = GAUGE.",
                          {
                            "$ul": [
                              [
                                "**range**: Range of numerical values within min and max.",
                                {
                                  "$ul": [
                                    "**max**: Range maximum.",
                                    "**min**: Range minimum."
                                  ]
                                }
                              ],
                              "**timeSeries**: A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying the TimeSeries to use for evaluating window quality."
                            ]
                          }
                        ],
                        [
                          "**metricSumInRange**: A MetricRange is used when each window is good when the value x of a single TimeSeries satisfies range.min <= x <= range.max. The provided TimeSeries must have ValueType = INT64 or ValueType = DOUBLE and MetricKind = GAUGE.",
                          {
                            "$ul": [
                              [
                                "**range**: Range of numerical values within min and max.",
                                {
                                  "$ul": [
                                    "**max**: Range maximum.",
                                    "**min**: Range minimum."
                                  ]
                                }
                              ],
                              "**timeSeries**: A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying the TimeSeries to use for evaluating window quality."
                            ]
                          }
                        ],
                        "**windowPeriod**: Duration over which window quality is evaluated. Must be an integer fraction of a day and at least 60s."
                      ]
                    }
                  ]
                ]
              }
            ],
            "**userLabels**: Labels which have been used to annotate the service-level objective. Label keys must start with a letter. Label keys and values may contain lowercase letters, numbers, underscores, and dashes. Label keys and values have a maximum length of 63 characters, and must be less than 128 bytes in size. Up to 64 label entries may be stored. For labels which do not have a semantic value, the empty string may be supplied for the label value."
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    }
  }
}
