{
  "name": "clouddebugger_debugger_debuggees_breakpoints_get",
  "description": "Gets breakpoint information.",
  "parameters": {
    "type": "object",
    "properties": {
      "debuggeeId": {
        "type": "string",
        "description": "Required. ID of the debuggee whose breakpoint to get."
      },
      "breakpointId": {
        "type": "string",
        "description": "Required. ID of the breakpoint to get."
      },
      "clientVersion": {
        "type": "string",
        "description": "Required. The client version making the call. Schema: `domain/type/version` (e.g., `google.com/intellij/v1`)."
      },
      "$.xgafv": {
        "enum": [
          "1",
          "2"
        ],
        "type": "string",
        "description": "V1 error format."
      },
      "access_token": {
        "type": "string",
        "description": "OAuth access token."
      },
      "alt": {
        "enum": [
          "json",
          "media",
          "proto"
        ],
        "type": "string",
        "description": "Data format for response."
      },
      "callback": {
        "type": "string",
        "description": "JSONP"
      },
      "fields": {
        "type": "string",
        "description": "Selector specifying which fields to include in a partial response."
      },
      "key": {
        "type": "string",
        "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
      },
      "oauth_token": {
        "type": "string",
        "description": "OAuth 2.0 token for the current user."
      },
      "prettyPrint": {
        "type": "boolean",
        "description": "Returns response with indentations and line breaks."
      },
      "quotaUser": {
        "type": "string",
        "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
      },
      "upload_protocol": {
        "type": "string",
        "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
      },
      "uploadType": {
        "type": "string",
        "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
      }
    },
    "required": [
      "debuggeeId",
      "breakpointId"
    ]
  },
  "handler": "http",
  "request": {
    "method": "GET",
    "url": {
      "$uri": "https://clouddebugger.googleapis.com//v2/debugger/debuggees/{debuggeeId}/breakpoints/{breakpointId}{?clientVersion,$.xgafv,access_token,alt,callback,fields,key,oauth_token,prettyPrint,quotaUser,upload_protocol,uploadType}"
    }
  },
  "responses": {
    "200": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "Response for getting breakpoint information.",
        "**Key properties:**",
        {
          "$ul": [
            [
              "**breakpoint**: ------------------------------------------------------------------------------ ## Breakpoint (the resource) Represents the breakpoint specification, status and results.",
              {
                "$ul": [
                  "**action**: Action that the agent should perform when the code at the breakpoint location is hit.",
                  "**canaryExpireTime**: The deadline for the breakpoint to stay in CANARY_ACTIVE state. The value is meaningless when the breakpoint is not in CANARY_ACTIVE state.",
                  "**condition**: Condition that triggers the breakpoint. The condition is a compound boolean expression composed using expressions in a programming language at the source location.",
                  "**createTime**: Time this breakpoint was created by the server in seconds resolution.",
                  "**evaluatedExpressions**: Values of evaluated expressions at breakpoint time. The evaluated expressions appear in exactly the same order they are listed in the `expressions` field. The `name` field holds the original expression text, the `value` or `members` field holds the result of the evaluated expression. If the expression cannot be evaluated, the `status` inside the `Variable` will indicate an error and contain the error text.",
                  "**expressions**: List of read-only expressions to evaluate at the breakpoint location. The expressions are composed using expressions in the programming language at the source location. If the breakpoint action is `LOG`, the evaluated expressions are included in log statements.",
                  "**finalTime**: Time this breakpoint was finalized as seen by the server in seconds resolution.",
                  "**id**: Breakpoint identifier, unique in the scope of the debuggee.",
                  "**isFinalState**: When true, indicates that this is a final result and the breakpoint state will not change from here on.",
                  "**labels**: A set of custom breakpoint properties, populated by the agent, to be displayed to the user.",
                  [
                    "**location**: Represents a location in the source code.",
                    {
                      "$ul": [
                        "**column**: Column within a line. The first column in a line as the value `1`. Agents that do not support setting breakpoints on specific columns ignore this field.",
                        "**line**: Line inside the file. The first line in the file has the value `1`.",
                        "**path**: Path to the source file within the source context of the target binary."
                      ]
                    }
                  ],
                  "**logLevel**: Indicates the severity of the log. Only relevant when action is `LOG`.",
                  "**logMessageFormat**: Only relevant when action is `LOG`. Defines the message to log when the breakpoint hits. The message may include parameter placeholders `$0`, `$1`, etc. These placeholders are replaced with the evaluated value of the appropriate expression. Expressions not referenced in `log_message_format` are not logged. Example: `Message received, id = $0, count = $1` with `expressions` = `[ message.id, message.count ]`.",
                  "**stackFrames**: The stack at breakpoint time, where stack_frames[0] represents the most recently entered function.",
                  "**state**: The current state of the breakpoint.",
                  [
                    "**status**: Represents a contextual status message. The message can indicate an error or informational status, and refer to specific parts of the containing object. For example, the `Breakpoint.status` field can indicate an error referring to the `BREAKPOINT_SOURCE_LOCATION` with the message `Location not found`.",
                    {
                      "$ul": [
                        [
                          "**description**: Represents a message with parameters.",
                          {
                            "$ul": [
                              "**format**: Format template for the message. The `format` uses placeholders `$0`, `$1`, etc. to reference parameters. `$$` can be used to denote the `$` character. Examples: * `Failed to load '$0' which helps debug $1 the first time it is loaded. Again, $0 is very important.` * `Please pay $$10 to use $0 instead of $1.`",
                              "**parameters**: Optional parameters to be embedded into the message."
                            ]
                          }
                        ],
                        "**isError**: Distinguishes errors from informational messages.",
                        "**refersTo**: Reference to which the message applies."
                      ]
                    }
                  ],
                  "**userEmail**: E-mail address of the user that created this breakpoint",
                  "**variableTable**: The `variable_table` exists to aid with computation, memory and network traffic optimization. It enables storing a variable once and reference it from multiple variables, including variables stored in the `variable_table` itself. For example, the same `this` object, which may appear at many levels of the stack, can have all of its data stored once in this table. The stack frame variables then would hold only a reference to it. The variable `var_table_index` field is an index into this repeated field. The stored objects are nameless and get their name from the referencing variable. The effective variable is a merge of the referencing variable and the referenced variable."
                ]
              }
            ]
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    }
  }
}
