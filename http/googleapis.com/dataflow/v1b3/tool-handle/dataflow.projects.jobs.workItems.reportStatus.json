{
  "name": "dataflow_projects_jobs_workItems_reportStatus",
  "description": "Reports the status of dataflow WorkItems leased by a worker.",
  "parameters": {
    "type": "object",
    "properties": {
      "projectId": {
        "type": "string",
        "description": "The project which owns the WorkItem's job."
      },
      "jobId": {
        "type": "string",
        "description": "The job which the WorkItem is part of."
      },
      "$.xgafv": {
        "enum": [
          "1",
          "2"
        ],
        "type": "string",
        "description": "V1 error format."
      },
      "access_token": {
        "type": "string",
        "description": "OAuth access token."
      },
      "alt": {
        "enum": [
          "json",
          "media",
          "proto"
        ],
        "type": "string",
        "description": "Data format for response."
      },
      "callback": {
        "type": "string",
        "description": "JSONP"
      },
      "fields": {
        "type": "string",
        "description": "Selector specifying which fields to include in a partial response."
      },
      "key": {
        "type": "string",
        "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
      },
      "oauth_token": {
        "type": "string",
        "description": "OAuth 2.0 token for the current user."
      },
      "prettyPrint": {
        "type": "boolean",
        "description": "Returns response with indentations and line breaks."
      },
      "quotaUser": {
        "type": "string",
        "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
      },
      "upload_protocol": {
        "type": "string",
        "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
      },
      "uploadType": {
        "type": "string",
        "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
      },
      "body": {
        "$ref": "#/$defs/ReportWorkItemStatusRequest"
      }
    },
    "required": [
      "projectId",
      "jobId"
    ],
    "$defs": {
      "ReportWorkItemStatusRequest": {
        "description": "Request to report the status of WorkItems.",
        "properties": {
          "currentWorkerTime": {
            "description": "The current timestamp at the worker.",
            "format": "google-datetime",
            "type": "string"
          },
          "location": {
            "description": "The [regional endpoint] (https://cloud.google.com/dataflow/docs/concepts/regional-endpoints) that contains the WorkItem's job.",
            "type": "string"
          },
          "unifiedWorkerRequest": {
            "additionalProperties": {
              "description": "Properties of the object. Contains field @type with type URL."
            },
            "description": "Untranslated bag-of-bytes WorkProgressUpdateRequest from UnifiedWorker.",
            "type": "object"
          },
          "workItemStatuses": {
            "description": "The order is unimportant, except that the order of the WorkItemServiceState messages in the ReportWorkItemStatusResponse corresponds to the order of WorkItemStatus messages here.",
            "items": {
              "$ref": "#/$defs/WorkItemStatus"
            },
            "type": "array"
          },
          "workerId": {
            "description": "The ID of the worker reporting the WorkItem status. If this does not match the ID of the worker which the Dataflow service believes currently has the lease on the WorkItem, the report will be dropped (with an error response).",
            "type": "string"
          }
        },
        "type": "object"
      },
      "WorkItemStatus": {
        "description": "Conveys a worker's progress through the work described by a WorkItem.",
        "properties": {
          "completed": {
            "description": "True if the WorkItem was completed (successfully or unsuccessfully).",
            "type": "boolean"
          },
          "counterUpdates": {
            "description": "Worker output counters for this WorkItem.",
            "items": {
              "$ref": "#/$defs/CounterUpdate"
            },
            "type": "array"
          },
          "dynamicSourceSplit": {
            "$ref": "#/$defs/DynamicSourceSplit"
          },
          "errors": {
            "description": "Specifies errors which occurred during processing. If errors are provided, and completed = true, then the WorkItem is considered to have failed.",
            "items": {
              "$ref": "#/$defs/Status"
            },
            "type": "array"
          },
          "metricUpdates": {
            "deprecated": true,
            "description": "DEPRECATED in favor of counter_updates.",
            "items": {
              "$ref": "#/$defs/MetricUpdate"
            },
            "type": "array"
          },
          "progress": {
            "$ref": "#/$defs/ApproximateProgress"
          },
          "reportIndex": {
            "description": "The report index. When a WorkItem is leased, the lease will contain an initial report index. When a WorkItem's status is reported to the system, the report should be sent with that report index, and the response will contain the index the worker should use for the next report. Reports received with unexpected index values will be rejected by the service. In order to preserve idempotency, the worker should not alter the contents of a report, even if the worker must submit the same report multiple times before getting back a response. The worker should not submit a subsequent report until the response for the previous report had been received from the service.",
            "format": "int64",
            "type": "string"
          },
          "reportedProgress": {
            "$ref": "#/$defs/ApproximateReportedProgress"
          },
          "requestedLeaseDuration": {
            "description": "Amount of time the worker requests for its lease.",
            "format": "google-duration",
            "type": "string"
          },
          "sourceFork": {
            "$ref": "#/$defs/SourceFork"
          },
          "sourceOperationResponse": {
            "$ref": "#/$defs/SourceOperationResponse"
          },
          "stopPosition": {
            "$ref": "#/$defs/Position"
          },
          "totalThrottlerWaitTimeSeconds": {
            "description": "Total time the worker spent being throttled by external systems.",
            "format": "double",
            "type": "number"
          },
          "workItemId": {
            "description": "Identifies the WorkItem.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "CounterUpdate": {
        "description": "An update to a Counter sent from a worker.",
        "properties": {
          "boolean": {
            "description": "Boolean value for And, Or.",
            "type": "boolean"
          },
          "cumulative": {
            "description": "True if this counter is reported as the total cumulative aggregate value accumulated since the worker started working on this WorkItem. By default this is false, indicating that this counter is reported as a delta.",
            "type": "boolean"
          },
          "distribution": {
            "$ref": "#/$defs/DistributionUpdate"
          },
          "floatingPoint": {
            "description": "Floating point value for Sum, Max, Min.",
            "format": "double",
            "type": "number"
          },
          "floatingPointList": {
            "$ref": "#/$defs/FloatingPointList"
          },
          "floatingPointMean": {
            "$ref": "#/$defs/FloatingPointMean"
          },
          "integer": {
            "$ref": "#/$defs/SplitInt64"
          },
          "integerGauge": {
            "$ref": "#/$defs/IntegerGauge"
          },
          "integerList": {
            "$ref": "#/$defs/IntegerList"
          },
          "integerMean": {
            "$ref": "#/$defs/IntegerMean"
          },
          "internal": {
            "description": "Value for internally-defined counters used by the Dataflow service."
          },
          "nameAndKind": {
            "$ref": "#/$defs/NameAndKind"
          },
          "shortId": {
            "description": "The service-generated short identifier for this counter. The short_id -> (name, metadata) mapping is constant for the lifetime of a job.",
            "format": "int64",
            "type": "string"
          },
          "stringList": {
            "$ref": "#/$defs/StringList"
          },
          "structuredNameAndMetadata": {
            "$ref": "#/$defs/CounterStructuredNameAndMetadata"
          }
        },
        "type": "object"
      },
      "DistributionUpdate": {
        "description": "A metric value representing a distribution.",
        "properties": {
          "count": {
            "$ref": "#/$defs/SplitInt64"
          },
          "histogram": {
            "$ref": "#/$defs/Histogram"
          },
          "max": {
            "$ref": "#/$defs/SplitInt64"
          },
          "min": {
            "$ref": "#/$defs/SplitInt64"
          },
          "sum": {
            "$ref": "#/$defs/SplitInt64"
          },
          "sumOfSquares": {
            "description": "Use a double since the sum of squares is likely to overflow int64.",
            "format": "double",
            "type": "number"
          }
        },
        "type": "object"
      },
      "SplitInt64": {
        "description": "A representation of an int64, n, that is immune to precision loss when encoded in JSON.",
        "properties": {
          "highBits": {
            "description": "The high order bits, including the sign: n >> 32.",
            "format": "int32",
            "type": "integer"
          },
          "lowBits": {
            "description": "The low order bits: n & 0xffffffff.",
            "format": "uint32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "Histogram": {
        "description": "Histogram of value counts for a distribution. Buckets have an inclusive lower bound and exclusive upper bound and use \"1,2,5 bucketing\": The first bucket range is from [0,1) and all subsequent bucket boundaries are powers of ten multiplied by 1, 2, or 5. Thus, bucket boundaries are 0, 1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, ... Negative values are not supported.",
        "properties": {
          "bucketCounts": {
            "description": "Counts of values in each bucket. For efficiency, prefix and trailing buckets with count = 0 are elided. Buckets can store the full range of values of an unsigned long, with ULLONG_MAX falling into the 59th bucket with range [1e19, 2e19).",
            "items": {
              "format": "int64",
              "type": "string"
            },
            "type": "array"
          },
          "firstBucketOffset": {
            "description": "Starting index of first stored bucket. The non-inclusive upper-bound of the ith bucket is given by: pow(10,(i-first_bucket_offset)/3) * (1,2,5)[(i-first_bucket_offset)%3]",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "FloatingPointList": {
        "description": "A metric value representing a list of floating point numbers.",
        "properties": {
          "elements": {
            "description": "Elements of the list.",
            "items": {
              "format": "double",
              "type": "number"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "FloatingPointMean": {
        "description": "A representation of a floating point mean metric contribution.",
        "properties": {
          "count": {
            "$ref": "#/$defs/SplitInt64"
          },
          "sum": {
            "description": "The sum of all values being aggregated.",
            "format": "double",
            "type": "number"
          }
        },
        "type": "object"
      },
      "IntegerGauge": {
        "description": "A metric value representing temporal values of a variable.",
        "properties": {
          "timestamp": {
            "description": "The time at which this value was measured. Measured as msecs from epoch.",
            "format": "google-datetime",
            "type": "string"
          },
          "value": {
            "$ref": "#/$defs/SplitInt64"
          }
        },
        "type": "object"
      },
      "IntegerList": {
        "description": "A metric value representing a list of integers.",
        "properties": {
          "elements": {
            "description": "Elements of the list.",
            "items": {
              "$ref": "#/$defs/SplitInt64"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "IntegerMean": {
        "description": "A representation of an integer mean metric contribution.",
        "properties": {
          "count": {
            "$ref": "#/$defs/SplitInt64"
          },
          "sum": {
            "$ref": "#/$defs/SplitInt64"
          }
        },
        "type": "object"
      },
      "NameAndKind": {
        "description": "Basic metadata about a counter.",
        "properties": {
          "kind": {
            "description": "Counter aggregation kind.",
            "enum": [
              "INVALID",
              "SUM",
              "MAX",
              "MIN",
              "MEAN",
              "OR",
              "AND",
              "SET",
              "DISTRIBUTION",
              "LATEST_VALUE"
            ],
            "type": "string"
          },
          "name": {
            "description": "Name of the counter.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "StringList": {
        "description": "A metric value representing a list of strings.",
        "properties": {
          "elements": {
            "description": "Elements of the list.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "CounterStructuredNameAndMetadata": {
        "description": "A single message which encapsulates structured name and metadata for a given counter.",
        "properties": {
          "metadata": {
            "$ref": "#/$defs/CounterMetadata"
          },
          "name": {
            "$ref": "#/$defs/CounterStructuredName"
          }
        },
        "type": "object"
      },
      "CounterMetadata": {
        "description": "CounterMetadata includes all static non-name non-value counter attributes.",
        "properties": {
          "description": {
            "description": "Human-readable description of the counter semantics.",
            "type": "string"
          },
          "kind": {
            "description": "Counter aggregation kind.",
            "enum": [
              "INVALID",
              "SUM",
              "MAX",
              "MIN",
              "MEAN",
              "OR",
              "AND",
              "SET",
              "DISTRIBUTION",
              "LATEST_VALUE"
            ],
            "type": "string"
          },
          "otherUnits": {
            "description": "A string referring to the unit type.",
            "type": "string"
          },
          "standardUnits": {
            "description": "System defined Units, see above enum.",
            "enum": [
              "BYTES",
              "BYTES_PER_SEC",
              "MILLISECONDS",
              "MICROSECONDS",
              "NANOSECONDS",
              "TIMESTAMP_MSEC",
              "TIMESTAMP_USEC",
              "TIMESTAMP_NSEC"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "CounterStructuredName": {
        "description": "Identifies a counter within a per-job namespace. Counters whose structured names are the same get merged into a single value for the job.",
        "properties": {
          "componentStepName": {
            "description": "Name of the optimized step being executed by the workers.",
            "type": "string"
          },
          "executionStepName": {
            "description": "Name of the stage. An execution step contains multiple component steps.",
            "type": "string"
          },
          "inputIndex": {
            "description": "Index of an input collection that's being read from/written to as a side input. The index identifies a step's side inputs starting by 1 (e.g. the first side input has input_index 1, the third has input_index 3). Side inputs are identified by a pair of (original_step_name, input_index). This field helps uniquely identify them.",
            "format": "int32",
            "type": "integer"
          },
          "name": {
            "description": "Counter name. Not necessarily globally-unique, but unique within the context of the other fields. Required.",
            "type": "string"
          },
          "origin": {
            "description": "One of the standard Origins defined above.",
            "enum": [
              "SYSTEM",
              "USER"
            ],
            "type": "string"
          },
          "originNamespace": {
            "description": "A string containing a more specific namespace of the counter's origin.",
            "type": "string"
          },
          "originalRequestingStepName": {
            "description": "The step name requesting an operation, such as GBK. I.e. the ParDo causing a read/write from shuffle to occur, or a read from side inputs.",
            "type": "string"
          },
          "originalStepName": {
            "description": "System generated name of the original step in the user's graph, before optimization.",
            "type": "string"
          },
          "portion": {
            "description": "Portion of this counter, either key or value.",
            "enum": [
              "ALL",
              "KEY",
              "VALUE"
            ],
            "type": "string"
          },
          "workerId": {
            "description": "ID of a particular worker.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "DynamicSourceSplit": {
        "description": "When a task splits using WorkItemStatus.dynamic_source_split, this message describes the two parts of the split relative to the description of the current task's input.",
        "properties": {
          "primary": {
            "$ref": "#/$defs/DerivedSource"
          },
          "residual": {
            "$ref": "#/$defs/DerivedSource"
          }
        },
        "type": "object"
      },
      "DerivedSource": {
        "description": "Specification of one of the bundles produced as a result of splitting a Source (e.g. when executing a SourceSplitRequest, or when splitting an active task using WorkItemStatus.dynamic_source_split), relative to the source being split.",
        "properties": {
          "derivationMode": {
            "description": "What source to base the produced source on (if any).",
            "enum": [
              "SOURCE_DERIVATION_MODE_UNKNOWN",
              "SOURCE_DERIVATION_MODE_INDEPENDENT",
              "SOURCE_DERIVATION_MODE_CHILD_OF_CURRENT",
              "SOURCE_DERIVATION_MODE_SIBLING_OF_CURRENT"
            ],
            "type": "string"
          },
          "source": {
            "$ref": "#/$defs/Source"
          }
        },
        "type": "object"
      },
      "Source": {
        "description": "A source that records can be read and decoded from.",
        "properties": {
          "baseSpecs": {
            "description": "While splitting, sources may specify the produced bundles as differences against another source, in order to save backend-side memory and allow bigger jobs. For details, see SourceSplitRequest. To support this use case, the full set of parameters of the source is logically obtained by taking the latest explicitly specified value of each parameter in the order: base_specs (later items win), spec (overrides anything in base_specs).",
            "items": {
              "additionalProperties": {
                "description": "Properties of the object."
              },
              "type": "object"
            },
            "type": "array"
          },
          "codec": {
            "additionalProperties": {
              "description": "Properties of the object."
            },
            "description": "The codec to use to decode data read from the source.",
            "type": "object"
          },
          "doesNotNeedSplitting": {
            "description": "Setting this value to true hints to the framework that the source doesn't need splitting, and using SourceSplitRequest on it would yield SOURCE_SPLIT_OUTCOME_USE_CURRENT. E.g. a file splitter may set this to true when splitting a single file into a set of byte ranges of appropriate size, and set this to false when splitting a filepattern into individual files. However, for efficiency, a file splitter may decide to produce file subranges directly from the filepattern to avoid a splitting round-trip. See SourceSplitRequest for an overview of the splitting process. This field is meaningful only in the Source objects populated by the user (e.g. when filling in a DerivedSource). Source objects supplied by the framework to the user don't have this field populated.",
            "type": "boolean"
          },
          "metadata": {
            "$ref": "#/$defs/SourceMetadata"
          },
          "spec": {
            "additionalProperties": {
              "description": "Properties of the object."
            },
            "description": "The source to read from, plus its parameters.",
            "type": "object"
          }
        },
        "type": "object"
      },
      "SourceMetadata": {
        "description": "Metadata about a Source useful for automatically optimizing and tuning the pipeline, etc.",
        "properties": {
          "estimatedSizeBytes": {
            "description": "An estimate of the total size (in bytes) of the data that would be read from this source. This estimate is in terms of external storage size, before any decompression or other processing done by the reader.",
            "format": "int64",
            "type": "string"
          },
          "infinite": {
            "description": "Specifies that the size of this source is known to be infinite (this is a streaming source).",
            "type": "boolean"
          },
          "producesSortedKeys": {
            "description": "Whether this source is known to produce key/value pairs with the (encoded) keys in lexicographically sorted order.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "Status": {
        "description": "The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).",
        "properties": {
          "code": {
            "description": "The status code, which should be an enum value of google.rpc.Code.",
            "format": "int32",
            "type": "integer"
          },
          "details": {
            "description": "A list of messages that carry the error details. There is a common set of message types for APIs to use.",
            "items": {
              "additionalProperties": {
                "description": "Properties of the object. Contains field @type with type URL."
              },
              "type": "object"
            },
            "type": "array"
          },
          "message": {
            "description": "A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "MetricUpdate": {
        "description": "Describes the state of a metric.",
        "properties": {
          "cumulative": {
            "description": "True if this metric is reported as the total cumulative aggregate value accumulated since the worker started working on this WorkItem. By default this is false, indicating that this metric is reported as a delta that is not associated with any WorkItem.",
            "type": "boolean"
          },
          "distribution": {
            "description": "A struct value describing properties of a distribution of numeric values."
          },
          "gauge": {
            "description": "A struct value describing properties of a Gauge. Metrics of gauge type show the value of a metric across time, and is aggregated based on the newest value."
          },
          "internal": {
            "description": "Worker-computed aggregate value for internal use by the Dataflow service."
          },
          "kind": {
            "description": "Metric aggregation kind. The possible metric aggregation kinds are \"Sum\", \"Max\", \"Min\", \"Mean\", \"Set\", \"And\", \"Or\", and \"Distribution\". The specified aggregation kind is case-insensitive. If omitted, this is not an aggregated value but instead a single metric sample value.",
            "type": "string"
          },
          "meanCount": {
            "description": "Worker-computed aggregate value for the \"Mean\" aggregation kind. This holds the count of the aggregated values and is used in combination with mean_sum above to obtain the actual mean aggregate value. The only possible value type is Long."
          },
          "meanSum": {
            "description": "Worker-computed aggregate value for the \"Mean\" aggregation kind. This holds the sum of the aggregated values and is used in combination with mean_count below to obtain the actual mean aggregate value. The only possible value types are Long and Double."
          },
          "name": {
            "$ref": "#/$defs/MetricStructuredName"
          },
          "scalar": {
            "description": "Worker-computed aggregate value for aggregation kinds \"Sum\", \"Max\", \"Min\", \"And\", and \"Or\". The possible value types are Long, Double, and Boolean."
          },
          "set": {
            "description": "Worker-computed aggregate value for the \"Set\" aggregation kind. The only possible value type is a list of Values whose type can be Long, Double, or String, according to the metric's type. All Values in the list must be of the same type."
          },
          "updateTime": {
            "description": "Timestamp associated with the metric value. Optional when workers are reporting work progress; it will be filled in responses from the metrics API.",
            "format": "google-datetime",
            "type": "string"
          }
        },
        "type": "object"
      },
      "MetricStructuredName": {
        "description": "Identifies a metric, by describing the source which generated the metric.",
        "properties": {
          "context": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Zero or more labeled fields which identify the part of the job this metric is associated with, such as the name of a step or collection. For example, built-in counters associated with steps will have context['step'] = . Counters associated with PCollections in the SDK will have context['pcollection'] = .",
            "type": "object"
          },
          "name": {
            "description": "Worker-defined metric name.",
            "type": "string"
          },
          "origin": {
            "description": "Origin (namespace) of metric name. May be blank for user-define metrics; will be \"dataflow\" for metrics defined by the Dataflow service or SDK.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "ApproximateProgress": {
        "description": "Obsolete in favor of ApproximateReportedProgress and ApproximateSplitRequest.",
        "properties": {
          "percentComplete": {
            "deprecated": true,
            "description": "Obsolete.",
            "format": "float",
            "type": "number"
          },
          "position": {
            "$ref": "#/$defs/Position"
          },
          "remainingTime": {
            "deprecated": true,
            "description": "Obsolete.",
            "format": "google-duration",
            "type": "string"
          }
        },
        "type": "object"
      },
      "Position": {
        "description": "Position defines a position within a collection of data. The value can be either the end position, a key (used with ordered collections), a byte offset, or a record index.",
        "properties": {
          "byteOffset": {
            "description": "Position is a byte offset.",
            "format": "int64",
            "type": "string"
          },
          "concatPosition": {
            "$ref": "#/$defs/ConcatPosition"
          },
          "end": {
            "description": "Position is past all other positions. Also useful for the end position of an unbounded range.",
            "type": "boolean"
          },
          "key": {
            "description": "Position is a string key, ordered lexicographically.",
            "type": "string"
          },
          "recordIndex": {
            "description": "Position is a record index.",
            "format": "int64",
            "type": "string"
          },
          "shufflePosition": {
            "description": "CloudPosition is a base64 encoded BatchShufflePosition (with FIXED sharding).",
            "type": "string"
          }
        },
        "type": "object"
      },
      "ConcatPosition": {
        "description": "A position that encapsulates an inner position and an index for the inner position. A ConcatPosition can be used by a reader of a source that encapsulates a set of other sources.",
        "properties": {
          "index": {
            "description": "Index of the inner source.",
            "format": "int32",
            "type": "integer"
          },
          "position": {
            "$ref": "#/$defs/Position"
          }
        },
        "type": "object"
      },
      "ApproximateReportedProgress": {
        "description": "A progress measurement of a WorkItem by a worker.",
        "properties": {
          "consumedParallelism": {
            "$ref": "#/$defs/ReportedParallelism"
          },
          "fractionConsumed": {
            "description": "Completion as fraction of the input consumed, from 0.0 (beginning, nothing consumed), to 1.0 (end of the input, entire input consumed).",
            "format": "double",
            "type": "number"
          },
          "position": {
            "$ref": "#/$defs/Position"
          },
          "remainingParallelism": {
            "$ref": "#/$defs/ReportedParallelism"
          }
        },
        "type": "object"
      },
      "ReportedParallelism": {
        "description": "Represents the level of parallelism in a WorkItem's input, reported by the worker.",
        "properties": {
          "isInfinite": {
            "description": "Specifies whether the parallelism is infinite. If true, \"value\" is ignored. Infinite parallelism means the service will assume that the work item can always be split into more non-empty work items by dynamic splitting. This is a work-around for lack of support for infinity by the current JSON-based Java RPC stack.",
            "type": "boolean"
          },
          "value": {
            "description": "Specifies the level of parallelism in case it is finite.",
            "format": "double",
            "type": "number"
          }
        },
        "type": "object"
      },
      "SourceFork": {
        "description": "DEPRECATED in favor of DynamicSourceSplit.",
        "properties": {
          "primary": {
            "$ref": "#/$defs/SourceSplitShard"
          },
          "primarySource": {
            "$ref": "#/$defs/DerivedSource"
          },
          "residual": {
            "$ref": "#/$defs/SourceSplitShard"
          },
          "residualSource": {
            "$ref": "#/$defs/DerivedSource"
          }
        },
        "type": "object"
      },
      "SourceSplitShard": {
        "description": "DEPRECATED in favor of DerivedSource.",
        "properties": {
          "derivationMode": {
            "description": "DEPRECATED",
            "enum": [
              "SOURCE_DERIVATION_MODE_UNKNOWN",
              "SOURCE_DERIVATION_MODE_INDEPENDENT",
              "SOURCE_DERIVATION_MODE_CHILD_OF_CURRENT",
              "SOURCE_DERIVATION_MODE_SIBLING_OF_CURRENT"
            ],
            "type": "string"
          },
          "source": {
            "$ref": "#/$defs/Source"
          }
        },
        "type": "object"
      },
      "SourceOperationResponse": {
        "description": "The result of a SourceOperationRequest, specified in ReportWorkItemStatusRequest.source_operation when the work item is completed.",
        "properties": {
          "getMetadata": {
            "$ref": "#/$defs/SourceGetMetadataResponse"
          },
          "split": {
            "$ref": "#/$defs/SourceSplitResponse"
          }
        },
        "type": "object"
      },
      "SourceGetMetadataResponse": {
        "description": "The result of a SourceGetMetadataOperation.",
        "properties": {
          "metadata": {
            "$ref": "#/$defs/SourceMetadata"
          }
        },
        "type": "object"
      },
      "SourceSplitResponse": {
        "description": "The response to a SourceSplitRequest.",
        "properties": {
          "bundles": {
            "description": "If outcome is SPLITTING_HAPPENED, then this is a list of bundles into which the source was split. Otherwise this field is ignored. This list can be empty, which means the source represents an empty input.",
            "items": {
              "$ref": "#/$defs/DerivedSource"
            },
            "type": "array"
          },
          "outcome": {
            "description": "Indicates whether splitting happened and produced a list of bundles. If this is USE_CURRENT_SOURCE_AS_IS, the current source should be processed \"as is\" without splitting. \"bundles\" is ignored in this case. If this is SPLITTING_HAPPENED, then \"bundles\" contains a list of bundles into which the source was split.",
            "enum": [
              "SOURCE_SPLIT_OUTCOME_UNKNOWN",
              "SOURCE_SPLIT_OUTCOME_USE_CURRENT",
              "SOURCE_SPLIT_OUTCOME_SPLITTING_HAPPENED"
            ],
            "type": "string"
          },
          "shards": {
            "deprecated": true,
            "description": "DEPRECATED in favor of bundles.",
            "items": {
              "$ref": "#/$defs/SourceSplitShard"
            },
            "type": "array"
          }
        },
        "type": "object"
      }
    }
  },
  "handler": "http",
  "request": {
    "method": "POST",
    "url": {
      "$uri": "https://dataflow.googleapis.com//v1b3/projects/{projectId}/jobs/{jobId}/workItems:reportStatus{?$.xgafv,access_token,alt,callback,fields,key,oauth_token,prettyPrint,quotaUser,upload_protocol,uploadType}"
    },
    "body": {
      "$": "body",
      "encode": "json"
    }
  },
  "responses": {
    "200": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "Response from a request to report the status of WorkItems.",
        "**Key properties:**",
        {
          "$ul": [
            "**unifiedWorkerResponse**: Untranslated bag-of-bytes WorkProgressUpdateResponse for UnifiedWorker.",
            "**workItemServiceStates**: A set of messages indicating the service-side state for each WorkItem whose status was reported, in the same order as the WorkItemStatus messages in the ReportWorkItemStatusRequest which resulting in this response."
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    }
  }
}
