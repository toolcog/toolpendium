{
  "name": "dataflow_projects_locations_workerMessages",
  "description": "Send a worker_message to the service.",
  "parameters": {
    "type": "object",
    "properties": {
      "projectId": {
        "type": "string",
        "description": "The project to send the WorkerMessages to."
      },
      "location": {
        "type": "string",
        "description": "The [regional endpoint] (https://cloud.google.com/dataflow/docs/concepts/regional-endpoints) that contains the job."
      },
      "$.xgafv": {
        "enum": [
          "1",
          "2"
        ],
        "type": "string",
        "description": "V1 error format."
      },
      "access_token": {
        "type": "string",
        "description": "OAuth access token."
      },
      "alt": {
        "enum": [
          "json",
          "media",
          "proto"
        ],
        "type": "string",
        "description": "Data format for response."
      },
      "callback": {
        "type": "string",
        "description": "JSONP"
      },
      "fields": {
        "type": "string",
        "description": "Selector specifying which fields to include in a partial response."
      },
      "key": {
        "type": "string",
        "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
      },
      "oauth_token": {
        "type": "string",
        "description": "OAuth 2.0 token for the current user."
      },
      "prettyPrint": {
        "type": "boolean",
        "description": "Returns response with indentations and line breaks."
      },
      "quotaUser": {
        "type": "string",
        "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
      },
      "upload_protocol": {
        "type": "string",
        "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
      },
      "uploadType": {
        "type": "string",
        "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
      },
      "body": {
        "$ref": "#/$defs/SendWorkerMessagesRequest"
      }
    },
    "required": [
      "projectId",
      "location"
    ],
    "$defs": {
      "SendWorkerMessagesRequest": {
        "description": "A request for sending worker messages to the service.",
        "properties": {
          "location": {
            "description": "The [regional endpoint] (https://cloud.google.com/dataflow/docs/concepts/regional-endpoints) that contains the job.",
            "type": "string"
          },
          "workerMessages": {
            "description": "The WorkerMessages to send.",
            "items": {
              "$ref": "#/$defs/WorkerMessage"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "WorkerMessage": {
        "description": "WorkerMessage provides information to the backend about a worker.",
        "properties": {
          "dataSamplingReport": {
            "$ref": "#/$defs/DataSamplingReport"
          },
          "labels": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Labels are used to group WorkerMessages. For example, a worker_message about a particular container might have the labels: { \"JOB_ID\": \"2015-04-22\", \"WORKER_ID\": \"wordcount-vm-2015â€¦\" \"CONTAINER_TYPE\": \"worker\", \"CONTAINER_ID\": \"ac1234def\"} Label tags typically correspond to Label enum values. However, for ease of development other strings can be used as tags. LABEL_UNSPECIFIED should not be used here.",
            "type": "object"
          },
          "perWorkerMetrics": {
            "$ref": "#/$defs/PerWorkerMetrics"
          },
          "streamingScalingReport": {
            "$ref": "#/$defs/StreamingScalingReport"
          },
          "time": {
            "description": "The timestamp of the worker_message.",
            "format": "google-datetime",
            "type": "string"
          },
          "workerHealthReport": {
            "$ref": "#/$defs/WorkerHealthReport"
          },
          "workerLifecycleEvent": {
            "$ref": "#/$defs/WorkerLifecycleEvent"
          },
          "workerMessageCode": {
            "$ref": "#/$defs/WorkerMessageCode"
          },
          "workerMetrics": {
            "$ref": "#/$defs/ResourceUtilizationReport"
          },
          "workerShutdownNotice": {
            "$ref": "#/$defs/WorkerShutdownNotice"
          },
          "workerThreadScalingReport": {
            "$ref": "#/$defs/WorkerThreadScalingReport"
          }
        },
        "type": "object"
      },
      "DataSamplingReport": {
        "description": "Contains per-worker telemetry about the data sampling feature.",
        "properties": {
          "bytesWrittenDelta": {
            "description": "Optional. Delta of bytes written to file from previous report.",
            "format": "int64",
            "type": "string"
          },
          "elementsSampledBytes": {
            "description": "Optional. Delta of bytes sampled from previous report.",
            "format": "int64",
            "type": "string"
          },
          "elementsSampledCount": {
            "description": "Optional. Delta of number of elements sampled from previous report.",
            "format": "int64",
            "type": "string"
          },
          "exceptionsSampledCount": {
            "description": "Optional. Delta of number of samples taken from user code exceptions from previous report.",
            "format": "int64",
            "type": "string"
          },
          "pcollectionsSampledCount": {
            "description": "Optional. Delta of number of PCollections sampled from previous report.",
            "format": "int64",
            "type": "string"
          },
          "persistenceErrorsCount": {
            "description": "Optional. Delta of errors counts from persisting the samples from previous report.",
            "format": "int64",
            "type": "string"
          },
          "translationErrorsCount": {
            "description": "Optional. Delta of errors counts from retrieving, or translating the samples from previous report.",
            "format": "int64",
            "type": "string"
          }
        },
        "type": "object"
      },
      "PerWorkerMetrics": {
        "description": "Per worker metrics.",
        "properties": {
          "perStepNamespaceMetrics": {
            "description": "Optional. Metrics for a particular unfused step and namespace.",
            "items": {
              "$ref": "#/$defs/PerStepNamespaceMetrics"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "PerStepNamespaceMetrics": {
        "description": "Metrics for a particular unfused step and namespace. A metric is uniquely identified by the `metrics_namespace`, `original_step`, `metric name` and `metric_labels`.",
        "properties": {
          "metricValues": {
            "description": "Optional. Metrics that are recorded for this namespace and unfused step.",
            "items": {
              "$ref": "#/$defs/MetricValue"
            },
            "type": "array"
          },
          "metricsNamespace": {
            "description": "The namespace of these metrics on the worker.",
            "type": "string"
          },
          "originalStep": {
            "description": "The original system name of the unfused step that these metrics are reported from.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "MetricValue": {
        "description": "The value of a metric along with its name and labels.",
        "properties": {
          "metric": {
            "description": "Base name for this metric.",
            "type": "string"
          },
          "metricLabels": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Optional. Set of metric labels for this metric.",
            "type": "object"
          },
          "valueHistogram": {
            "$ref": "#/$defs/DataflowHistogramValue"
          },
          "valueInt64": {
            "description": "Integer value of this metric.",
            "format": "int64",
            "type": "string"
          }
        },
        "type": "object"
      },
      "DataflowHistogramValue": {
        "description": "Summary statistics for a population of values. HistogramValue contains a sequence of buckets and gives a count of values that fall into each bucket. Bucket boundares are defined by a formula and bucket widths are either fixed or exponentially increasing.",
        "properties": {
          "bucketCounts": {
            "description": "Optional. The number of values in each bucket of the histogram, as described in `bucket_options`. `bucket_counts` should contain N values, where N is the number of buckets specified in `bucket_options`. If `bucket_counts` has fewer than N values, the remaining values are assumed to be 0.",
            "items": {
              "format": "int64",
              "type": "string"
            },
            "type": "array"
          },
          "bucketOptions": {
            "$ref": "#/$defs/BucketOptions"
          },
          "count": {
            "description": "Number of values recorded in this histogram.",
            "format": "int64",
            "type": "string"
          },
          "outlierStats": {
            "$ref": "#/$defs/OutlierStats"
          }
        },
        "type": "object"
      },
      "BucketOptions": {
        "description": "`BucketOptions` describes the bucket boundaries used in the histogram.",
        "properties": {
          "exponential": {
            "$ref": "#/$defs/Base2Exponent"
          },
          "linear": {
            "$ref": "#/$defs/Linear"
          }
        },
        "type": "object"
      },
      "Base2Exponent": {
        "description": "Exponential buckets where the growth factor between buckets is `2**(2**-scale)`. e.g. for `scale=1` growth factor is `2**(2**(-1))=sqrt(2)`. `n` buckets will have the following boundaries. - 0th: [0, gf) - i in [1, n-1]: [gf^(i), gf^(i+1))",
        "properties": {
          "numberOfBuckets": {
            "description": "Must be greater than 0.",
            "format": "int32",
            "type": "integer"
          },
          "scale": {
            "description": "Must be between -3 and 3. This forces the growth factor of the bucket boundaries to be between `2^(1/8)` and `256`.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "Linear": {
        "description": "Linear buckets with the following boundaries for indices in 0 to n-1. - i in [0, n-1]: [start + (i)*width, start + (i+1)*width)",
        "properties": {
          "numberOfBuckets": {
            "description": "Must be greater than 0.",
            "format": "int32",
            "type": "integer"
          },
          "start": {
            "description": "Lower bound of the first bucket.",
            "format": "double",
            "type": "number"
          },
          "width": {
            "description": "Distance between bucket boundaries. Must be greater than 0.",
            "format": "double",
            "type": "number"
          }
        },
        "type": "object"
      },
      "OutlierStats": {
        "description": "Statistics for the underflow and overflow bucket.",
        "properties": {
          "overflowCount": {
            "description": "Number of values that are larger than the upper bound of the largest bucket.",
            "format": "int64",
            "type": "string"
          },
          "overflowMean": {
            "description": "Mean of values in the overflow bucket.",
            "format": "double",
            "type": "number"
          },
          "underflowCount": {
            "description": "Number of values that are smaller than the lower bound of the smallest bucket.",
            "format": "int64",
            "type": "string"
          },
          "underflowMean": {
            "description": "Mean of values in the undeflow bucket.",
            "format": "double",
            "type": "number"
          }
        },
        "type": "object"
      },
      "StreamingScalingReport": {
        "description": "Contains per-user worker telemetry used in streaming autoscaling.",
        "properties": {
          "activeBundleCount": {
            "deprecated": true,
            "format": "int32",
            "type": "integer"
          },
          "activeThreadCount": {
            "description": "Current acive thread count.",
            "format": "int32",
            "type": "integer"
          },
          "maximumBundleCount": {
            "description": "Maximum bundle count.",
            "format": "int32",
            "type": "integer"
          },
          "maximumBytes": {
            "description": "Maximum bytes.",
            "format": "int64",
            "type": "string"
          },
          "maximumBytesCount": {
            "deprecated": true,
            "format": "int32",
            "type": "integer"
          },
          "maximumThreadCount": {
            "description": "Maximum thread count limit.",
            "format": "int32",
            "type": "integer"
          },
          "outstandingBundleCount": {
            "description": "Current outstanding bundle count.",
            "format": "int32",
            "type": "integer"
          },
          "outstandingBytes": {
            "description": "Current outstanding bytes.",
            "format": "int64",
            "type": "string"
          },
          "outstandingBytesCount": {
            "deprecated": true,
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "WorkerHealthReport": {
        "description": "WorkerHealthReport contains information about the health of a worker. The VM should be identified by the labels attached to the WorkerMessage that this health ping belongs to.",
        "properties": {
          "msg": {
            "description": "Message describing any unusual health reports.",
            "type": "string"
          },
          "pods": {
            "description": "The pods running on the worker. See: http://kubernetes.io/v1.1/docs/api-reference/v1/definitions.html#_v1_pod This field is used by the worker to send the status of the indvidual containers running on each worker.",
            "items": {
              "additionalProperties": {
                "description": "Properties of the object."
              },
              "type": "object"
            },
            "type": "array"
          },
          "reportInterval": {
            "description": "The interval at which the worker is sending health reports. The default value of 0 should be interpreted as the field is not being explicitly set by the worker.",
            "format": "google-duration",
            "type": "string"
          },
          "vmBrokenCode": {
            "description": "Code to describe a specific reason, if known, that a VM has reported broken state.",
            "type": "string"
          },
          "vmIsBroken": {
            "description": "Whether the VM is in a permanently broken state. Broken VMs should be abandoned or deleted ASAP to avoid assigning or completing any work.",
            "type": "boolean"
          },
          "vmIsHealthy": {
            "description": "Whether the VM is currently healthy.",
            "type": "boolean"
          },
          "vmStartupTime": {
            "description": "The time the VM was booted.",
            "format": "google-datetime",
            "type": "string"
          }
        },
        "type": "object"
      },
      "WorkerLifecycleEvent": {
        "description": "A report of an event in a worker's lifecycle. The proto contains one event, because the worker is expected to asynchronously send each message immediately after the event. Due to this asynchrony, messages may arrive out of order (or missing), and it is up to the consumer to interpret. The timestamp of the event is in the enclosing WorkerMessage proto.",
        "properties": {
          "containerStartTime": {
            "description": "The start time of this container. All events will report this so that events can be grouped together across container/VM restarts.",
            "format": "google-datetime",
            "type": "string"
          },
          "event": {
            "description": "The event being reported.",
            "enum": [
              "UNKNOWN_EVENT",
              "OS_START",
              "CONTAINER_START",
              "NETWORK_UP",
              "STAGING_FILES_DOWNLOAD_START",
              "STAGING_FILES_DOWNLOAD_FINISH",
              "SDK_INSTALL_START",
              "SDK_INSTALL_FINISH"
            ],
            "type": "string"
          },
          "metadata": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Other stats that can accompany an event. E.g. { \"downloaded_bytes\" : \"123456\" }",
            "type": "object"
          }
        },
        "type": "object"
      },
      "WorkerMessageCode": {
        "description": "A message code is used to report status and error messages to the service. The message codes are intended to be machine readable. The service will take care of translating these into user understandable messages if necessary. Example use cases: 1. Worker processes reporting successful startup. 2. Worker processes reporting specific errors (e.g. package staging failure).",
        "properties": {
          "code": {
            "description": "The code is a string intended for consumption by a machine that identifies the type of message being sent. Examples: 1. \"HARNESS_STARTED\" might be used to indicate the worker harness has started. 2. \"GCS_DOWNLOAD_ERROR\" might be used to indicate an error downloading a Cloud Storage file as part of the boot process of one of the worker containers. This is a string and not an enum to make it easy to add new codes without waiting for an API change.",
            "type": "string"
          },
          "parameters": {
            "additionalProperties": {
              "description": "Properties of the object."
            },
            "description": "Parameters contains specific information about the code. This is a struct to allow parameters of different types. Examples: 1. For a \"HARNESS_STARTED\" message parameters might provide the name of the worker and additional data like timing information. 2. For a \"GCS_DOWNLOAD_ERROR\" parameters might contain fields listing the Cloud Storage objects being downloaded and fields containing errors. In general complex data structures should be avoided. If a worker needs to send a specific and complicated data structure then please consider defining a new proto and adding it to the data oneof in WorkerMessageResponse. Conventions: Parameters should only be used for information that isn't typically passed as a label. hostname and other worker identifiers should almost always be passed as labels since they will be included on most messages.",
            "type": "object"
          }
        },
        "type": "object"
      },
      "ResourceUtilizationReport": {
        "description": "Worker metrics exported from workers. This contains resource utilization metrics accumulated from a variety of sources. For more information, see go/df-resource-signals.",
        "properties": {
          "containers": {
            "additionalProperties": {
              "$ref": "#/$defs/ResourceUtilizationReport"
            },
            "description": "Per container information. Key: container name.",
            "type": "object"
          },
          "cpuTime": {
            "description": "CPU utilization samples.",
            "items": {
              "$ref": "#/$defs/CPUTime"
            },
            "type": "array"
          },
          "memoryInfo": {
            "description": "Memory utilization samples.",
            "items": {
              "$ref": "#/$defs/MemInfo"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "CPUTime": {
        "description": "Modeled after information exposed by /proc/stat.",
        "properties": {
          "rate": {
            "description": "Average CPU utilization rate (% non-idle cpu / second) since previous sample.",
            "format": "double",
            "type": "number"
          },
          "timestamp": {
            "description": "Timestamp of the measurement.",
            "format": "google-datetime",
            "type": "string"
          },
          "totalMs": {
            "description": "Total active CPU time across all cores (ie., non-idle) in milliseconds since start-up.",
            "format": "uint64",
            "type": "string"
          }
        },
        "type": "object"
      },
      "MemInfo": {
        "description": "Information about the memory usage of a worker or a container within a worker.",
        "properties": {
          "currentLimitBytes": {
            "description": "Instantenous memory limit in bytes.",
            "format": "uint64",
            "type": "string"
          },
          "currentOoms": {
            "description": "Number of Out of Memory (OOM) events recorded since the previous measurement.",
            "format": "int64",
            "type": "string"
          },
          "currentRssBytes": {
            "description": "Instantenous memory (RSS) size in bytes.",
            "format": "uint64",
            "type": "string"
          },
          "timestamp": {
            "description": "Timestamp of the measurement.",
            "format": "google-datetime",
            "type": "string"
          },
          "totalGbMs": {
            "description": "Total memory (RSS) usage since start up in GB * ms.",
            "format": "uint64",
            "type": "string"
          }
        },
        "type": "object"
      },
      "WorkerShutdownNotice": {
        "description": "Shutdown notification from workers. This is to be sent by the shutdown script of the worker VM so that the backend knows that the VM is being shut down.",
        "properties": {
          "reason": {
            "description": "The reason for the worker shutdown. Current possible values are: \"UNKNOWN\": shutdown reason is unknown. \"PREEMPTION\": shutdown reason is preemption. Other possible reasons may be added in the future.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "WorkerThreadScalingReport": {
        "description": "Contains information about the thread scaling information of a worker.",
        "properties": {
          "currentThreadCount": {
            "description": "Current number of active threads in a worker.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      }
    }
  },
  "handler": "http",
  "request": {
    "method": "POST",
    "url": {
      "$uri": "https://dataflow.googleapis.com//v1b3/projects/{projectId}/locations/{location}/WorkerMessages{?$.xgafv,access_token,alt,callback,fields,key,oauth_token,prettyPrint,quotaUser,upload_protocol,uploadType}"
    },
    "body": {
      "$": "body",
      "encode": "json"
    }
  },
  "responses": {
    "200": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "The response to the worker messages.",
        "**Key properties:**",
        {
          "$ul": [
            "**workerMessageResponses**: The servers response to the worker messages."
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    }
  }
}
