{
  "name": "firestore_projects_databases_documents_partitionQuery",
  "description": "Partitions a query by returning partition cursors that can be used to run the query in parallel. The returned partition cursors are split points that can be used by RunQuery as starting/end points for the query results.",
  "parameters": {
    "type": "object",
    "properties": {
      "parent": {
        "type": "string",
        "description": "Required. The parent resource name. In the format: `projects/{project_id}/databases/{database_id}/documents`. Document resource names are not supported; only database resource names can be specified."
      },
      "$.xgafv": {
        "enum": [
          "1",
          "2"
        ],
        "type": "string",
        "description": "V1 error format."
      },
      "access_token": {
        "type": "string",
        "description": "OAuth access token."
      },
      "alt": {
        "enum": [
          "json",
          "media",
          "proto"
        ],
        "type": "string",
        "description": "Data format for response."
      },
      "callback": {
        "type": "string",
        "description": "JSONP"
      },
      "fields": {
        "type": "string",
        "description": "Selector specifying which fields to include in a partial response."
      },
      "key": {
        "type": "string",
        "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
      },
      "oauth_token": {
        "type": "string",
        "description": "OAuth 2.0 token for the current user."
      },
      "prettyPrint": {
        "type": "boolean",
        "description": "Returns response with indentations and line breaks."
      },
      "quotaUser": {
        "type": "string",
        "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
      },
      "upload_protocol": {
        "type": "string",
        "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
      },
      "uploadType": {
        "type": "string",
        "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
      },
      "body": {
        "$ref": "#/$defs/PartitionQueryRequest"
      }
    },
    "required": [
      "parent"
    ],
    "$defs": {
      "PartitionQueryRequest": {
        "description": "The request for Firestore.PartitionQuery.",
        "properties": {
          "pageSize": {
            "description": "The maximum number of partitions to return in this call, subject to `partition_count`. For example, if `partition_count` = 10 and `page_size` = 8, the first call to PartitionQuery will return up to 8 partitions and a `next_page_token` if more results exist. A second call to PartitionQuery will return up to 2 partitions, to complete the total of 10 specified in `partition_count`.",
            "format": "int32",
            "type": "integer"
          },
          "pageToken": {
            "description": "The `next_page_token` value returned from a previous call to PartitionQuery that may be used to get an additional set of results. There are no ordering guarantees between sets of results. Thus, using multiple sets of results will require merging the different result sets. For example, two subsequent calls using a page_token may return: * cursor B, cursor M, cursor Q * cursor A, cursor U, cursor W To obtain a complete result set ordered with respect to the results of the query supplied to PartitionQuery, the results sets should be merged: cursor A, cursor B, cursor M, cursor Q, cursor U, cursor W",
            "type": "string"
          },
          "partitionCount": {
            "description": "The desired maximum number of partition points. The partitions may be returned across multiple pages of results. The number must be positive. The actual number of partitions returned may be fewer. For example, this may be set to one fewer than the number of parallel queries to be run, or in running a data pipeline job, one fewer than the number of workers or compute instances available.",
            "format": "int64",
            "type": "string"
          },
          "readTime": {
            "description": "Reads documents as they were at the given time. This must be a microsecond precision timestamp within the past one hour, or if Point-in-Time Recovery is enabled, can additionally be a whole minute timestamp within the past 7 days.",
            "format": "google-datetime",
            "type": "string"
          },
          "structuredQuery": {
            "$ref": "#/$defs/StructuredQuery"
          }
        },
        "type": "object"
      },
      "StructuredQuery": {
        "description": "A Firestore query. The query stages are executed in the following order: 1. from 2. where 3. select 4. order_by + start_at + end_at 5. offset 6. limit",
        "properties": {
          "endAt": {
            "$ref": "#/$defs/Cursor"
          },
          "from": {
            "description": "The collections to query.",
            "items": {
              "$ref": "#/$defs/CollectionSelector"
            },
            "type": "array"
          },
          "limit": {
            "description": "The maximum number of results to return. Applies after all other constraints. Requires: * The value must be greater than or equal to zero if specified.",
            "format": "int32",
            "type": "integer"
          },
          "offset": {
            "description": "The number of documents to skip before returning the first result. This applies after the constraints specified by the `WHERE`, `START AT`, & `END AT` but before the `LIMIT` clause. Requires: * The value must be greater than or equal to zero if specified.",
            "format": "int32",
            "type": "integer"
          },
          "orderBy": {
            "description": "The order to apply to the query results. Firestore allows callers to provide a full ordering, a partial ordering, or no ordering at all. In all cases, Firestore guarantees a stable ordering through the following rules: * The `order_by` is required to reference all fields used with an inequality filter. * All fields that are required to be in the `order_by` but are not already present are appended in lexicographical ordering of the field name. * If an order on `__name__` is not specified, it is appended by default. Fields are appended with the same sort direction as the last order specified, or 'ASCENDING' if no order was specified. For example: * `ORDER BY a` becomes `ORDER BY a ASC, __name__ ASC` * `ORDER BY a DESC` becomes `ORDER BY a DESC, __name__ DESC` * `WHERE a > 1` becomes `WHERE a > 1 ORDER BY a ASC, __name__ ASC` * `WHERE __name__ > ... AND a > 1` becomes `WHERE __name__ > ... AND a > 1 ORDER BY a ASC, __name__ ASC`",
            "items": {
              "$ref": "#/$defs/Order"
            },
            "type": "array"
          },
          "select": {
            "$ref": "#/$defs/Projection"
          },
          "startAt": {
            "$ref": "#/$defs/Cursor"
          },
          "where": {
            "$ref": "#/$defs/Filter"
          }
        },
        "type": "object"
      },
      "Cursor": {
        "description": "A position in a query result set.",
        "properties": {
          "before": {
            "description": "If the position is just before or just after the given values, relative to the sort order defined by the query.",
            "type": "boolean"
          },
          "values": {
            "description": "The values that represent a position, in the order they appear in the order by clause of a query. Can contain fewer values than specified in the order by clause.",
            "items": {
              "$ref": "#/$defs/Value"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "Value": {
        "description": "A message that can hold any of the supported value types.",
        "properties": {
          "arrayValue": {
            "$ref": "#/$defs/ArrayValue"
          },
          "booleanValue": {
            "description": "A boolean value.",
            "type": "boolean"
          },
          "bytesValue": {
            "description": "A bytes value. Must not exceed 1 MiB - 89 bytes. Only the first 1,500 bytes are considered by queries.",
            "format": "byte",
            "type": "string"
          },
          "doubleValue": {
            "description": "A double value.",
            "format": "double",
            "type": "number"
          },
          "geoPointValue": {
            "$ref": "#/$defs/LatLng"
          },
          "integerValue": {
            "description": "An integer value.",
            "format": "int64",
            "type": "string"
          },
          "mapValue": {
            "$ref": "#/$defs/MapValue"
          },
          "nullValue": {
            "description": "A null value.",
            "enum": [
              "NULL_VALUE"
            ],
            "type": "string"
          },
          "referenceValue": {
            "description": "A reference to a document. For example: `projects/{project_id}/databases/{database_id}/documents/{document_path}`.",
            "type": "string"
          },
          "stringValue": {
            "description": "A string value. The string, represented as UTF-8, must not exceed 1 MiB - 89 bytes. Only the first 1,500 bytes of the UTF-8 representation are considered by queries.",
            "type": "string"
          },
          "timestampValue": {
            "description": "A timestamp value. Precise only to microseconds. When stored, any additional precision is rounded down.",
            "format": "google-datetime",
            "type": "string"
          }
        },
        "type": "object"
      },
      "ArrayValue": {
        "description": "An array value.",
        "properties": {
          "values": {
            "description": "Values in the array.",
            "items": {
              "$ref": "#/$defs/Value"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "LatLng": {
        "description": "An object that represents a latitude/longitude pair. This is expressed as a pair of doubles to represent degrees latitude and degrees longitude. Unless specified otherwise, this object must conform to the WGS84 standard. Values must be within normalized ranges.",
        "properties": {
          "latitude": {
            "description": "The latitude in degrees. It must be in the range [-90.0, +90.0].",
            "format": "double",
            "type": "number"
          },
          "longitude": {
            "description": "The longitude in degrees. It must be in the range [-180.0, +180.0].",
            "format": "double",
            "type": "number"
          }
        },
        "type": "object"
      },
      "MapValue": {
        "description": "A map value.",
        "properties": {
          "fields": {
            "additionalProperties": {
              "$ref": "#/$defs/Value"
            },
            "description": "The map's fields. The map keys represent field names. Field names matching the regular expression `__.*__` are reserved. Reserved field names are forbidden except in certain documented contexts. The map keys, represented as UTF-8, must not exceed 1,500 bytes and cannot be empty.",
            "type": "object"
          }
        },
        "type": "object"
      },
      "CollectionSelector": {
        "description": "A selection of a collection, such as `messages as m1`.",
        "properties": {
          "allDescendants": {
            "description": "When false, selects only collections that are immediate children of the `parent` specified in the containing `RunQueryRequest`. When true, selects all descendant collections.",
            "type": "boolean"
          },
          "collectionId": {
            "description": "The collection ID. When set, selects only collections with this ID.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "Order": {
        "description": "An order on a field.",
        "properties": {
          "direction": {
            "description": "The direction to order by. Defaults to `ASCENDING`.",
            "enum": [
              "DIRECTION_UNSPECIFIED",
              "ASCENDING",
              "DESCENDING"
            ],
            "type": "string"
          },
          "field": {
            "$ref": "#/$defs/FieldReference"
          }
        },
        "type": "object"
      },
      "FieldReference": {
        "description": "A reference to a field in a document, ex: `stats.operations`.",
        "properties": {
          "fieldPath": {
            "description": "A reference to a field in a document. Requires: * MUST be a dot-delimited (`.`) string of segments, where each segment conforms to document field name limitations.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "Projection": {
        "description": "The projection of document's fields to return.",
        "properties": {
          "fields": {
            "description": "The fields to return. If empty, all fields are returned. To only return the name of the document, use `['__name__']`.",
            "items": {
              "$ref": "#/$defs/FieldReference"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "Filter": {
        "description": "A filter.",
        "properties": {
          "compositeFilter": {
            "$ref": "#/$defs/CompositeFilter"
          },
          "fieldFilter": {
            "$ref": "#/$defs/FieldFilter"
          },
          "unaryFilter": {
            "$ref": "#/$defs/UnaryFilter"
          }
        },
        "type": "object"
      },
      "CompositeFilter": {
        "description": "A filter that merges multiple other filters using the given operator.",
        "properties": {
          "filters": {
            "description": "The list of filters to combine. Requires: * At least one filter is present.",
            "items": {
              "$ref": "#/$defs/Filter"
            },
            "type": "array"
          },
          "op": {
            "description": "The operator for combining multiple filters.",
            "enum": [
              "OPERATOR_UNSPECIFIED",
              "AND",
              "OR"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "FieldFilter": {
        "description": "A filter on a specific field.",
        "properties": {
          "field": {
            "$ref": "#/$defs/FieldReference"
          },
          "op": {
            "description": "The operator to filter by.",
            "enum": [
              "OPERATOR_UNSPECIFIED",
              "LESS_THAN",
              "LESS_THAN_OR_EQUAL",
              "GREATER_THAN",
              "GREATER_THAN_OR_EQUAL",
              "EQUAL",
              "NOT_EQUAL",
              "ARRAY_CONTAINS",
              "IN",
              "ARRAY_CONTAINS_ANY",
              "NOT_IN"
            ],
            "type": "string"
          },
          "value": {
            "$ref": "#/$defs/Value"
          }
        },
        "type": "object"
      },
      "UnaryFilter": {
        "description": "A filter with a single operand.",
        "properties": {
          "field": {
            "$ref": "#/$defs/FieldReference"
          },
          "op": {
            "description": "The unary operator to apply.",
            "enum": [
              "OPERATOR_UNSPECIFIED",
              "IS_NAN",
              "IS_NULL",
              "IS_NOT_NAN",
              "IS_NOT_NULL"
            ],
            "type": "string"
          }
        },
        "type": "object"
      }
    }
  },
  "handler": "http",
  "request": {
    "method": "POST",
    "url": {
      "$uri": "https://firestore.googleapis.com//v1beta1/{parent}:partitionQuery{?$.xgafv,access_token,alt,callback,fields,key,oauth_token,prettyPrint,quotaUser,upload_protocol,uploadType}"
    },
    "body": {
      "$": "body",
      "encode": "json"
    }
  },
  "responses": {
    "200": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "The response for Firestore.PartitionQuery.",
        "**Key properties:**",
        {
          "$ul": [
            "**nextPageToken**: A page token that may be used to request an additional set of results, up to the number specified by `partition_count` in the PartitionQuery request. If blank, there are no more results.",
            "**partitions**: Partition results. Each partition is a split point that can be used by RunQuery as a starting or end point for the query results. The RunQuery requests must be made with the same query supplied to this PartitionQuery request. The partition cursors will be ordered according to same ordering as the results of the query supplied to PartitionQuery. For example, if a PartitionQuery request returns partition cursors A and B, running the following three queries will return the entire result set of the original query: * query, end_at A * query, start_at A, end_at B * query, start_at B An empty result may indicate that the query has too few results to be partitioned, or that the query is not yet supported for partitioning."
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    }
  }
}
