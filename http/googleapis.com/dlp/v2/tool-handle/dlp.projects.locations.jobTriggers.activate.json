{
  "name": "dlp_projects_locations_jobTriggers_activate",
  "description": "Activate a job trigger. Causes the immediate execute of a trigger instead of waiting on the trigger event to occur.",
  "parameters": {
    "type": "object",
    "properties": {
      "name": {
        "type": "string",
        "description": "Required. Resource name of the trigger to activate, for example `projects/dlp-test-project/jobTriggers/53234423`."
      },
      "$.xgafv": {
        "enum": [
          "1",
          "2"
        ],
        "type": "string",
        "description": "V1 error format."
      },
      "access_token": {
        "type": "string",
        "description": "OAuth access token."
      },
      "alt": {
        "enum": [
          "json",
          "media",
          "proto"
        ],
        "type": "string",
        "description": "Data format for response."
      },
      "callback": {
        "type": "string",
        "description": "JSONP"
      },
      "fields": {
        "type": "string",
        "description": "Selector specifying which fields to include in a partial response."
      },
      "key": {
        "type": "string",
        "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
      },
      "oauth_token": {
        "type": "string",
        "description": "OAuth 2.0 token for the current user."
      },
      "prettyPrint": {
        "type": "boolean",
        "description": "Returns response with indentations and line breaks."
      },
      "quotaUser": {
        "type": "string",
        "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
      },
      "upload_protocol": {
        "type": "string",
        "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
      },
      "uploadType": {
        "type": "string",
        "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
      },
      "body": {
        "$ref": "#/$defs/GooglePrivacyDlpV2ActivateJobTriggerRequest"
      }
    },
    "required": [
      "name"
    ],
    "$defs": {
      "GooglePrivacyDlpV2ActivateJobTriggerRequest": {
        "description": "Request message for ActivateJobTrigger.",
        "properties": {},
        "type": "object"
      }
    }
  },
  "handler": "http",
  "request": {
    "method": "POST",
    "url": {
      "$uri": "https://dlp.googleapis.com//v2/{name}:activate{?$.xgafv,access_token,alt,callback,fields,key,oauth_token,prettyPrint,quotaUser,upload_protocol,uploadType}"
    },
    "body": {
      "$": "body",
      "encode": "json"
    }
  },
  "responses": {
    "200": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "Combines all of the information about a DLP job.",
        "**Key properties:**",
        {
          "$ul": [
            "**actionDetails**: Events that should occur after the job has completed.",
            "**createTime**: Time when the job was created.",
            "**endTime**: Time when the job finished.",
            "**errors**: A stream of errors encountered running the job.",
            [
              "**inspectDetails**: The results of an inspect DataSource job.",
              {
                "$ul": [
                  [
                    "**requestedOptions**: Snapshot of the inspection configuration.",
                    {
                      "$ul": [
                        [
                          "**jobConfig**: Controls what and how to inspect for findings.",
                          {
                            "$ul": [
                              "**actions**: Actions to execute at the completion of the job.",
                              [
                                "**inspectConfig**: Configuration description of the scanning process. When used with redactContent only info_types and min_likelihood are currently used.",
                                {
                                  "$ul": [
                                    "**contentOptions**: Deprecated and unused.",
                                    "**customInfoTypes**: CustomInfoTypes provided by the user. See https://cloud.google.com/sensitive-data-protection/docs/creating-custom-infotypes to learn more.",
                                    "**excludeInfoTypes**: When true, excludes type information of the findings. This is not used for data profiling.",
                                    "**includeQuote**: When true, a contextual quote from the data that triggered a finding is included in the response; see Finding.quote. This is not used for data profiling.",
                                    "**infoTypes**: Restricts what info_types to look for. The values must correspond to InfoType values returned by ListInfoTypes or listed at https://cloud.google.com/sensitive-data-protection/docs/infotypes-reference. When no InfoTypes or CustomInfoTypes are specified in a request, the system may automatically choose a default list of detectors to run, which may change over time. If you need precise control and predictability as to what detectors are run you should specify specific InfoTypes listed in the reference, otherwise a default list will be used, which may change over time.",
                                    [
                                      "**limits**: Configuration to control the number of findings returned for inspection. This is not used for de-identification or data profiling. When redacting sensitive data from images, finding limits don't apply. They can cause unexpected or inconsistent results, where only some data is redacted. Don't include finding limits in RedactImage requests. Otherwise, Cloud DLP returns an error.",
                                      {
                                        "$ul": [
                                          "**maxFindingsPerInfoType**: Configuration of findings limit given for specified infoTypes.",
                                          "**maxFindingsPerItem**: Max number of findings that are returned for each item scanned. When set within an InspectContentRequest, this field is ignored. This value isn't a hard limit. If the number of findings for an item reaches this limit, the inspection of that item ends gradually, not abruptly. Therefore, the actual number of findings that Cloud DLP returns for the item can be multiple times higher than this value.",
                                          "**maxFindingsPerRequest**: Max number of findings that are returned per request or job. If you set this field in an InspectContentRequest, the resulting maximum value is the value that you set or 3,000, whichever is lower. This value isn't a hard limit. If an inspection reaches this limit, the inspection ends gradually, not abruptly. Therefore, the actual number of findings that Cloud DLP returns can be multiple times higher than this value."
                                        ]
                                      }
                                    ],
                                    "**minLikelihood**: Only returns findings equal to or above this threshold. The default is POSSIBLE. In general, the highest likelihood setting yields the fewest findings in results and the lowest chance of a false positive. For more information, see [Match likelihood](https://cloud.google.com/sensitive-data-protection/docs/likelihood).",
                                    "**minLikelihoodPerInfoType**: Minimum likelihood per infotype. For each infotype, a user can specify a minimum likelihood. The system only returns a finding if its likelihood is above this threshold. If this field is not set, the system uses the InspectConfig min_likelihood.",
                                    "**ruleSet**: Set of rules to apply to the findings for this InspectConfig. Exclusion rules, contained in the set are executed in the end, other rules are executed in the order they are specified for each info type."
                                  ]
                                }
                              ],
                              "**inspectTemplateName**: If provided, will be used as the default for all values in InspectConfig. `inspect_config` will be merged into the values persisted as part of the template.",
                              [
                                "**storageConfig**: Shared message indicating Cloud storage type.",
                                {
                                  "$ul": [
                                    [
                                      "**bigQueryOptions**: Options defining BigQuery table and row identifiers.",
                                      {
                                        "$ul": [
                                          "**excludedFields**: References to fields excluded from scanning. This allows you to skip inspection of entire columns which you know have no findings. When inspecting a table, we recommend that you inspect all columns. Otherwise, findings might be affected because hints from excluded columns will not be used.",
                                          "**identifyingFields**: Table fields that may uniquely identify a row within the table. When `actions.saveFindings.outputConfig.table` is specified, the values of columns specified here are available in the output table under `location.content_locations.record_location.record_key.id_values`. Nested fields such as `person.birthdate.year` are allowed.",
                                          "**includedFields**: Limit scanning only to these fields. When inspecting a table, we recommend that you inspect all columns. Otherwise, findings might be affected because hints from excluded columns will not be used.",
                                          "**rowsLimit**: Max number of rows to scan. If the table has more rows than this value, the rest of the rows are omitted. If not set, or if set to 0, all rows will be scanned. Only one of rows_limit and rows_limit_percent can be specified. Cannot be used in conjunction with TimespanConfig.",
                                          "**rowsLimitPercent**: Max percentage of rows to scan. The rest are omitted. The number of rows scanned is rounded down. Must be between 0 and 100, inclusively. Both 0 and 100 means no limit. Defaults to 0. Only one of rows_limit and rows_limit_percent can be specified. Cannot be used in conjunction with TimespanConfig. Caution: A [known issue](https://cloud.google.com/sensitive-data-protection/docs/known-issues#bq-sampling) is causing the `rowsLimitPercent` field to behave unexpectedly. We recommend using `rowsLimit` instead.",
                                          "**sampleMethod**: How to sample the data.",
                                          [
                                            "**tableReference**: Message defining the location of a BigQuery table. A table is uniquely identified by its project_id, dataset_id, and table_name. Within a query a table is often referenced with a string in the format of: `:.` or `..`.",
                                            {
                                              "$ul": [
                                                "**datasetId**: Dataset ID of the table.",
                                                "**projectId**: The Google Cloud Platform project ID of the project containing the table. If omitted, project ID is inferred from the API call.",
                                                "**tableId**: Name of the table."
                                              ]
                                            }
                                          ]
                                        ]
                                      }
                                    ],
                                    [
                                      "**cloudStorageOptions**: Options defining a file or a set of files within a Cloud Storage bucket.",
                                      {
                                        "$ul": [
                                          "**bytesLimitPerFile**: Max number of bytes to scan from a file. If a scanned file's size is bigger than this value then the rest of the bytes are omitted. Only one of `bytes_limit_per_file` and `bytes_limit_per_file_percent` can be specified. This field can't be set if de-identification is requested. For certain file types, setting this field has no effect. For more information, see [Limits on bytes scanned per file](https://cloud.google.com/sensitive-data-protection/docs/supported-file-types#max-byte-size-per-file).",
                                          "**bytesLimitPerFilePercent**: Max percentage of bytes to scan from a file. The rest are omitted. The number of bytes scanned is rounded down. Must be between 0 and 100, inclusively. Both 0 and 100 means no limit. Defaults to 0. Only one of bytes_limit_per_file and bytes_limit_per_file_percent can be specified. This field can't be set if de-identification is requested. For certain file types, setting this field has no effect. For more information, see [Limits on bytes scanned per file](https://cloud.google.com/sensitive-data-protection/docs/supported-file-types#max-byte-size-per-file).",
                                          [
                                            "**fileSet**: Set of files to scan.",
                                            {
                                              "$ul": [
                                                [
                                                  "**regexFileSet**: Message representing a set of files in a Cloud Storage bucket. Regular expressions are used to allow fine-grained control over which files in the bucket to include. Included files are those that match at least one item in `include_regex` and do not match any items in `exclude_regex`. Note that a file that matches items from both lists will _not_ be included. For a match to occur, the entire file path (i.e., everything in the url after the bucket name) must match the regular expression. For example, given the input `{bucket_name: \"mybucket\", include_regex: [\"directory1/.*\"], exclude_regex: [\"directory1/excluded.*\"]}`: * `gs://mybucket/directory1/myfile` will be included * `gs://mybucket/directory1/directory2/myfile` will be included (`.*` matches across `/`) * `gs://mybucket/directory0/directory1/myfile` will _not_ be included (the full path doesn't match any items in `include_regex`) * `gs://mybucket/directory1/excludedfile` will _not_ be included (the path matches an item in `exclude_regex`) If `include_regex` is left empty, it will match all files by default (this is equivalent to setting `include_regex: [\".*\"]`). Some other common use cases: * `{bucket_name: \"mybucket\", exclude_regex: [\".*\\.pdf\"]}` will include all files in `mybucket` except for .pdf files * `{bucket_name: \"mybucket\", include_regex: [\"directory/[^/]+\"]}` will include all files directly under `gs://mybucket/directory/`, without matching across `/`",
                                                  {
                                                    "$ul": [
                                                      "**bucketName**: The name of a Cloud Storage bucket. Required.",
                                                      "**excludeRegex**: A list of regular expressions matching file paths to exclude. All files in the bucket that match at least one of these regular expressions will be excluded from the scan. Regular expressions use RE2 [syntax](https://github.com/google/re2/wiki/Syntax); a guide can be found under the google/re2 repository on GitHub.",
                                                      "**includeRegex**: A list of regular expressions matching file paths to include. All files in the bucket that match at least one of these regular expressions will be included in the set of files, except for those that also match an item in `exclude_regex`. Leaving this field empty will match all files by default (this is equivalent to including `.*` in the list). Regular expressions use RE2 [syntax](https://github.com/google/re2/wiki/Syntax); a guide can be found under the google/re2 repository on GitHub."
                                                    ]
                                                  }
                                                ],
                                                "**url**: The Cloud Storage url of the file(s) to scan, in the format `gs:///`. Trailing wildcard in the path is allowed. If the url ends in a trailing slash, the bucket or directory represented by the url will be scanned non-recursively (content in sub-directories will not be scanned). This means that `gs://mybucket/` is equivalent to `gs://mybucket/*`, and `gs://mybucket/directory/` is equivalent to `gs://mybucket/directory/*`. Exactly one of `url` or `regex_file_set` must be set."
                                              ]
                                            }
                                          ],
                                          "**fileTypes**: List of file type groups to include in the scan. If empty, all files are scanned and available data format processors are applied. In addition, the binary content of the selected files is always scanned as well. Images are scanned only as binary if the specified region does not support image inspection and no file_types were specified. Image inspection is restricted to 'global', 'us', 'asia', and 'europe'.",
                                          "**filesLimitPercent**: Limits the number of files to scan to this percentage of the input FileSet. Number of files scanned is rounded down. Must be between 0 and 100, inclusively. Both 0 and 100 means no limit. Defaults to 0.",
                                          "**sampleMethod**: How to sample the data."
                                        ]
                                      }
                                    ],
                                    [
                                      "**datastoreOptions**: Options defining a data set within Google Cloud Datastore.",
                                      {
                                        "$ul": [
                                          [
                                            "**kind**: A representation of a Datastore kind.",
                                            {
                                              "$ul": [
                                                "**name**: The name of the kind."
                                              ]
                                            }
                                          ],
                                          [
                                            "**partitionId**: Datastore partition ID. A partition ID identifies a grouping of entities. The grouping is always by project and namespace, however the namespace ID may be empty. A partition ID contains several dimensions: project ID and namespace ID.",
                                            {
                                              "$ul": [
                                                "**namespaceId**: If not empty, the ID of the namespace to which the entities belong.",
                                                "**projectId**: The ID of the project to which the entities belong."
                                              ]
                                            }
                                          ]
                                        ]
                                      }
                                    ],
                                    [
                                      "**hybridOptions**: Configuration to control jobs where the content being inspected is outside of Google Cloud Platform.",
                                      {
                                        "$ul": [
                                          "**description**: A short description of where the data is coming from. Will be stored once in the job. 256 max length.",
                                          "**labels**: To organize findings, these labels will be added to each finding. Label keys must be between 1 and 63 characters long and must conform to the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`. Label values must be between 0 and 63 characters long and must conform to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`. No more than 10 labels can be associated with a given finding. Examples: * `\"environment\" : \"production\"` * `\"pipeline\" : \"etl\"`",
                                          "**requiredFindingLabelKeys**: These are labels that each inspection request must include within their 'finding_labels' map. Request may contain others, but any missing one of these will be rejected. Label keys must be between 1 and 63 characters long and must conform to the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`. No more than 10 keys can be required.",
                                          [
                                            "**tableOptions**: Instructions regarding the table content being inspected.",
                                            {
                                              "$ul": [
                                                "**identifyingFields**: The columns that are the primary keys for table objects included in ContentItem. A copy of this cell's value will stored alongside alongside each finding so that the finding can be traced to the specific row it came from. No more than 3 may be provided."
                                              ]
                                            }
                                          ]
                                        ]
                                      }
                                    ],
                                    [
                                      "**timespanConfig**: Configuration of the timespan of the items to include in scanning. Currently only supported when inspecting Cloud Storage and BigQuery.",
                                      {
                                        "$ul": [
                                          "**enableAutoPopulationOfTimespanConfig**: When the job is started by a JobTrigger we will automatically figure out a valid start_time to avoid scanning files that have not been modified since the last time the JobTrigger executed. This will be based on the time of the execution of the last run of the JobTrigger or the timespan end_time used in the last run of the JobTrigger.",
                                          "**endTime**: Exclude files, tables, or rows newer than this value. If not set, no upper time limit is applied.",
                                          "**startTime**: Exclude files, tables, or rows older than this value. If not set, no lower time limit is applied.",
                                          [
                                            "**timestampField**: General identifier of a data field in a storage service.",
                                            {
                                              "$ul": [
                                                "**name**: Name describing the field."
                                              ]
                                            }
                                          ]
                                        ]
                                      }
                                    ]
                                  ]
                                }
                              ]
                            ]
                          }
                        ],
                        [
                          "**snapshotInspectTemplate**: The inspectTemplate contains a configuration (set of types of sensitive data to be detected) to be used anywhere you otherwise would normally specify InspectConfig. See https://cloud.google.com/sensitive-data-protection/docs/concepts-templates to learn more.",
                          {
                            "$ul": [
                              "**createTime**: Output only. The creation timestamp of an inspectTemplate.",
                              "**description**: Short description (max 256 chars).",
                              "**displayName**: Display name (max 256 chars).",
                              [
                                "**inspectConfig**: Configuration description of the scanning process. When used with redactContent only info_types and min_likelihood are currently used.",
                                {
                                  "$ul": [
                                    "**contentOptions**: Deprecated and unused.",
                                    "**customInfoTypes**: CustomInfoTypes provided by the user. See https://cloud.google.com/sensitive-data-protection/docs/creating-custom-infotypes to learn more.",
                                    "**excludeInfoTypes**: When true, excludes type information of the findings. This is not used for data profiling.",
                                    "**includeQuote**: When true, a contextual quote from the data that triggered a finding is included in the response; see Finding.quote. This is not used for data profiling.",
                                    "**infoTypes**: Restricts what info_types to look for. The values must correspond to InfoType values returned by ListInfoTypes or listed at https://cloud.google.com/sensitive-data-protection/docs/infotypes-reference. When no InfoTypes or CustomInfoTypes are specified in a request, the system may automatically choose a default list of detectors to run, which may change over time. If you need precise control and predictability as to what detectors are run you should specify specific InfoTypes listed in the reference, otherwise a default list will be used, which may change over time.",
                                    [
                                      "**limits**: Configuration to control the number of findings returned for inspection. This is not used for de-identification or data profiling. When redacting sensitive data from images, finding limits don't apply. They can cause unexpected or inconsistent results, where only some data is redacted. Don't include finding limits in RedactImage requests. Otherwise, Cloud DLP returns an error.",
                                      {
                                        "$ul": [
                                          "**maxFindingsPerInfoType**: Configuration of findings limit given for specified infoTypes.",
                                          "**maxFindingsPerItem**: Max number of findings that are returned for each item scanned. When set within an InspectContentRequest, this field is ignored. This value isn't a hard limit. If the number of findings for an item reaches this limit, the inspection of that item ends gradually, not abruptly. Therefore, the actual number of findings that Cloud DLP returns for the item can be multiple times higher than this value.",
                                          "**maxFindingsPerRequest**: Max number of findings that are returned per request or job. If you set this field in an InspectContentRequest, the resulting maximum value is the value that you set or 3,000, whichever is lower. This value isn't a hard limit. If an inspection reaches this limit, the inspection ends gradually, not abruptly. Therefore, the actual number of findings that Cloud DLP returns can be multiple times higher than this value."
                                        ]
                                      }
                                    ],
                                    "**minLikelihood**: Only returns findings equal to or above this threshold. The default is POSSIBLE. In general, the highest likelihood setting yields the fewest findings in results and the lowest chance of a false positive. For more information, see [Match likelihood](https://cloud.google.com/sensitive-data-protection/docs/likelihood).",
                                    "**minLikelihoodPerInfoType**: Minimum likelihood per infotype. For each infotype, a user can specify a minimum likelihood. The system only returns a finding if its likelihood is above this threshold. If this field is not set, the system uses the InspectConfig min_likelihood.",
                                    "**ruleSet**: Set of rules to apply to the findings for this InspectConfig. Exclusion rules, contained in the set are executed in the end, other rules are executed in the order they are specified for each info type."
                                  ]
                                }
                              ],
                              "**name**: Output only. The template name. The template will have one of the following formats: `projects/PROJECT_ID/inspectTemplates/TEMPLATE_ID` OR `organizations/ORGANIZATION_ID/inspectTemplates/TEMPLATE_ID`;",
                              "**updateTime**: Output only. The last update timestamp of an inspectTemplate."
                            ]
                          }
                        ]
                      ]
                    }
                  ],
                  [
                    "**result**: All result fields mentioned below are updated while the job is processing.",
                    {
                      "$ul": [
                        [
                          "**hybridStats**: Statistics related to processing hybrid inspect requests.",
                          {
                            "$ul": [
                              "**abortedCount**: The number of hybrid inspection requests aborted because the job ran out of quota or was ended before they could be processed.",
                              "**pendingCount**: The number of hybrid requests currently being processed. Only populated when called via method `getDlpJob`. A burst of traffic may cause hybrid inspect requests to be enqueued. Processing will take place as quickly as possible, but resource limitations may impact how long a request is enqueued for.",
                              "**processedCount**: The number of hybrid inspection requests processed within this job."
                            ]
                          }
                        ],
                        "**infoTypeStats**: Statistics of how many instances of each info type were found during inspect job.",
                        "**processedBytes**: Total size in bytes that were processed.",
                        "**totalEstimatedBytes**: Estimate of the number of bytes to process."
                      ]
                    }
                  ]
                ]
              }
            ],
            "**jobTriggerName**: If created by a job trigger, the resource name of the trigger that instantiated the job.",
            "**lastModified**: Time when the job was last modified by the system.",
            "**name**: The server-assigned name.",
            [
              "**riskDetails**: Result of a risk analysis operation request.",
              {
                "$ul": [
                  [
                    "**categoricalStatsResult**: Result of the categorical stats computation.",
                    {
                      "$ul": [
                        "**valueFrequencyHistogramBuckets**: Histogram of value frequencies in the column."
                      ]
                    }
                  ],
                  [
                    "**deltaPresenceEstimationResult**: Result of the δ-presence computation. Note that these results are an estimation, not exact values.",
                    {
                      "$ul": [
                        "**deltaPresenceEstimationHistogram**: The intervals [min_probability, max_probability) do not overlap. If a value doesn't correspond to any such interval, the associated frequency is zero. For example, the following records: {min_probability: 0, max_probability: 0.1, frequency: 17} {min_probability: 0.2, max_probability: 0.3, frequency: 42} {min_probability: 0.3, max_probability: 0.4, frequency: 99} mean that there are no record with an estimated probability in [0.1, 0.2) nor larger or equal to 0.4."
                      ]
                    }
                  ],
                  [
                    "**kAnonymityResult**: Result of the k-anonymity computation.",
                    {
                      "$ul": [
                        "**equivalenceClassHistogramBuckets**: Histogram of k-anonymity equivalence classes."
                      ]
                    }
                  ],
                  [
                    "**kMapEstimationResult**: Result of the reidentifiability analysis. Note that these results are an estimation, not exact values.",
                    {
                      "$ul": [
                        "**kMapEstimationHistogram**: The intervals [min_anonymity, max_anonymity] do not overlap. If a value doesn't correspond to any such interval, the associated frequency is zero. For example, the following records: {min_anonymity: 1, max_anonymity: 1, frequency: 17} {min_anonymity: 2, max_anonymity: 3, frequency: 42} {min_anonymity: 5, max_anonymity: 10, frequency: 99} mean that there are no record with an estimated anonymity of 4, 5, or larger than 10."
                      ]
                    }
                  ],
                  [
                    "**lDiversityResult**: Result of the l-diversity computation.",
                    {
                      "$ul": [
                        "**sensitiveValueFrequencyHistogramBuckets**: Histogram of l-diversity equivalence class sensitive value frequencies."
                      ]
                    }
                  ],
                  [
                    "**numericalStatsResult**: Result of the numerical stats computation.",
                    {
                      "$ul": [
                        [
                          "**maxValue**: Set of primitive values supported by the system. Note that for the purposes of inspection or transformation, the number of bytes considered to comprise a 'Value' is based on its representation as a UTF-8 encoded string. For example, if 'integer_value' is set to 123456789, the number of bytes would be counted as 9, even though an int64 only holds up to 8 bytes of data.",
                          {
                            "$ul": [
                              "**booleanValue**: boolean",
                              [
                                "**dateValue**: Represents a whole or partial calendar date, such as a birthday. The time of day and time zone are either specified elsewhere or are insignificant. The date is relative to the Gregorian Calendar. This can represent one of the following: * A full date, with non-zero year, month, and day values. * A month and day, with a zero year (for example, an anniversary). * A year on its own, with a zero month and a zero day. * A year and month, with a zero day (for example, a credit card expiration date). Related types: * google.type.TimeOfDay * google.type.DateTime * google.protobuf.Timestamp",
                                {
                                  "$ul": [
                                    "**day**: Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.",
                                    "**month**: Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.",
                                    "**year**: Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."
                                  ]
                                }
                              ],
                              "**dayOfWeekValue**: day of week",
                              "**floatValue**: float",
                              "**integerValue**: integer",
                              "**stringValue**: string",
                              [
                                "**timeValue**: Represents a time of day. The date and time zone are either not significant or are specified elsewhere. An API may choose to allow leap seconds. Related types are google.type.Date and `google.protobuf.Timestamp`.",
                                {
                                  "$ul": [
                                    "**hours**: Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value \"24:00:00\" for scenarios like business closing time.",
                                    "**minutes**: Minutes of hour of day. Must be from 0 to 59.",
                                    "**nanos**: Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.",
                                    "**seconds**: Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds."
                                  ]
                                }
                              ],
                              "**timestampValue**: timestamp"
                            ]
                          }
                        ],
                        [
                          "**minValue**: Set of primitive values supported by the system. Note that for the purposes of inspection or transformation, the number of bytes considered to comprise a 'Value' is based on its representation as a UTF-8 encoded string. For example, if 'integer_value' is set to 123456789, the number of bytes would be counted as 9, even though an int64 only holds up to 8 bytes of data.",
                          {
                            "$ul": [
                              "**booleanValue**: boolean",
                              [
                                "**dateValue**: Represents a whole or partial calendar date, such as a birthday. The time of day and time zone are either specified elsewhere or are insignificant. The date is relative to the Gregorian Calendar. This can represent one of the following: * A full date, with non-zero year, month, and day values. * A month and day, with a zero year (for example, an anniversary). * A year on its own, with a zero month and a zero day. * A year and month, with a zero day (for example, a credit card expiration date). Related types: * google.type.TimeOfDay * google.type.DateTime * google.protobuf.Timestamp",
                                {
                                  "$ul": [
                                    "**day**: Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.",
                                    "**month**: Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.",
                                    "**year**: Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."
                                  ]
                                }
                              ],
                              "**dayOfWeekValue**: day of week",
                              "**floatValue**: float",
                              "**integerValue**: integer",
                              "**stringValue**: string",
                              [
                                "**timeValue**: Represents a time of day. The date and time zone are either not significant or are specified elsewhere. An API may choose to allow leap seconds. Related types are google.type.Date and `google.protobuf.Timestamp`.",
                                {
                                  "$ul": [
                                    "**hours**: Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value \"24:00:00\" for scenarios like business closing time.",
                                    "**minutes**: Minutes of hour of day. Must be from 0 to 59.",
                                    "**nanos**: Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.",
                                    "**seconds**: Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds."
                                  ]
                                }
                              ],
                              "**timestampValue**: timestamp"
                            ]
                          }
                        ],
                        "**quantileValues**: List of 99 values that partition the set of field values into 100 equal sized buckets."
                      ]
                    }
                  ],
                  [
                    "**requestedOptions**: Risk analysis options.",
                    {
                      "$ul": [
                        [
                          "**jobConfig**: Configuration for a risk analysis job. See https://cloud.google.com/sensitive-data-protection/docs/concepts-risk-analysis to learn more.",
                          {
                            "$ul": [
                              "**actions**: Actions to execute at the completion of the job. Are executed in the order provided.",
                              [
                                "**privacyMetric**: Privacy metric to compute for reidentification risk analysis.",
                                {
                                  "$ul": [
                                    [
                                      "**categoricalStatsConfig**: Compute numerical stats over an individual column, including number of distinct values and value count distribution.",
                                      {
                                        "$ul": [
                                          [
                                            "**field**: General identifier of a data field in a storage service.",
                                            {
                                              "$ul": [
                                                "**name**: Name describing the field."
                                              ]
                                            }
                                          ]
                                        ]
                                      }
                                    ],
                                    [
                                      "**deltaPresenceEstimationConfig**: δ-presence metric, used to estimate how likely it is for an attacker to figure out that one given individual appears in a de-identified dataset. Similarly to the k-map metric, we cannot compute δ-presence exactly without knowing the attack dataset, so we use a statistical model instead.",
                                      {
                                        "$ul": [
                                          "**auxiliaryTables**: Several auxiliary tables can be used in the analysis. Each custom_tag used to tag a quasi-identifiers field must appear in exactly one field of one auxiliary table.",
                                          "**quasiIds**: Required. Fields considered to be quasi-identifiers. No two fields can have the same tag.",
                                          "**regionCode**: ISO 3166-1 alpha-2 region code to use in the statistical modeling. Set if no column is tagged with a region-specific InfoType (like US_ZIP_5) or a region code."
                                        ]
                                      }
                                    ],
                                    [
                                      "**kAnonymityConfig**: k-anonymity metric, used for analysis of reidentification risk.",
                                      {
                                        "$ul": [
                                          [
                                            "**entityId**: An entity in a dataset is a field or set of fields that correspond to a single person. For example, in medical records the `EntityId` might be a patient identifier, or for financial records it might be an account identifier. This message is used when generalizations or analysis must take into account that multiple rows correspond to the same entity.",
                                            {
                                              "$ul": [
                                                [
                                                  "**field**: General identifier of a data field in a storage service.",
                                                  {
                                                    "$ul": [
                                                      "**name**: Name describing the field."
                                                    ]
                                                  }
                                                ]
                                              ]
                                            }
                                          ],
                                          "**quasiIds**: Set of fields to compute k-anonymity over. When multiple fields are specified, they are considered a single composite key. Structs and repeated data types are not supported; however, nested fields are supported so long as they are not structs themselves or nested within a repeated field."
                                        ]
                                      }
                                    ],
                                    [
                                      "**kMapEstimationConfig**: Reidentifiability metric. This corresponds to a risk model similar to what is called \"journalist risk\" in the literature, except the attack dataset is statistically modeled instead of being perfectly known. This can be done using publicly available data (like the US Census), or using a custom statistical model (indicated as one or several BigQuery tables), or by extrapolating from the distribution of values in the input dataset.",
                                      {
                                        "$ul": [
                                          "**auxiliaryTables**: Several auxiliary tables can be used in the analysis. Each custom_tag used to tag a quasi-identifiers column must appear in exactly one column of one auxiliary table.",
                                          "**quasiIds**: Required. Fields considered to be quasi-identifiers. No two columns can have the same tag.",
                                          "**regionCode**: ISO 3166-1 alpha-2 region code to use in the statistical modeling. Set if no column is tagged with a region-specific InfoType (like US_ZIP_5) or a region code."
                                        ]
                                      }
                                    ],
                                    [
                                      "**lDiversityConfig**: l-diversity metric, used for analysis of reidentification risk.",
                                      {
                                        "$ul": [
                                          "**quasiIds**: Set of quasi-identifiers indicating how equivalence classes are defined for the l-diversity computation. When multiple fields are specified, they are considered a single composite key.",
                                          [
                                            "**sensitiveAttribute**: General identifier of a data field in a storage service.",
                                            {
                                              "$ul": [
                                                "**name**: Name describing the field."
                                              ]
                                            }
                                          ]
                                        ]
                                      }
                                    ],
                                    [
                                      "**numericalStatsConfig**: Compute numerical stats over an individual column, including min, max, and quantiles.",
                                      {
                                        "$ul": [
                                          [
                                            "**field**: General identifier of a data field in a storage service.",
                                            {
                                              "$ul": [
                                                "**name**: Name describing the field."
                                              ]
                                            }
                                          ]
                                        ]
                                      }
                                    ]
                                  ]
                                }
                              ],
                              [
                                "**sourceTable**: Message defining the location of a BigQuery table. A table is uniquely identified by its project_id, dataset_id, and table_name. Within a query a table is often referenced with a string in the format of: `:.` or `..`.",
                                {
                                  "$ul": [
                                    "**datasetId**: Dataset ID of the table.",
                                    "**projectId**: The Google Cloud Platform project ID of the project containing the table. If omitted, project ID is inferred from the API call.",
                                    "**tableId**: Name of the table."
                                  ]
                                }
                              ]
                            ]
                          }
                        ]
                      ]
                    }
                  ],
                  [
                    "**requestedPrivacyMetric**: Privacy metric to compute for reidentification risk analysis.",
                    {
                      "$ul": [
                        [
                          "**categoricalStatsConfig**: Compute numerical stats over an individual column, including number of distinct values and value count distribution.",
                          {
                            "$ul": [
                              [
                                "**field**: General identifier of a data field in a storage service.",
                                {
                                  "$ul": [
                                    "**name**: Name describing the field."
                                  ]
                                }
                              ]
                            ]
                          }
                        ],
                        [
                          "**deltaPresenceEstimationConfig**: δ-presence metric, used to estimate how likely it is for an attacker to figure out that one given individual appears in a de-identified dataset. Similarly to the k-map metric, we cannot compute δ-presence exactly without knowing the attack dataset, so we use a statistical model instead.",
                          {
                            "$ul": [
                              "**auxiliaryTables**: Several auxiliary tables can be used in the analysis. Each custom_tag used to tag a quasi-identifiers field must appear in exactly one field of one auxiliary table.",
                              "**quasiIds**: Required. Fields considered to be quasi-identifiers. No two fields can have the same tag.",
                              "**regionCode**: ISO 3166-1 alpha-2 region code to use in the statistical modeling. Set if no column is tagged with a region-specific InfoType (like US_ZIP_5) or a region code."
                            ]
                          }
                        ],
                        [
                          "**kAnonymityConfig**: k-anonymity metric, used for analysis of reidentification risk.",
                          {
                            "$ul": [
                              [
                                "**entityId**: An entity in a dataset is a field or set of fields that correspond to a single person. For example, in medical records the `EntityId` might be a patient identifier, or for financial records it might be an account identifier. This message is used when generalizations or analysis must take into account that multiple rows correspond to the same entity.",
                                {
                                  "$ul": [
                                    [
                                      "**field**: General identifier of a data field in a storage service.",
                                      {
                                        "$ul": [
                                          "**name**: Name describing the field."
                                        ]
                                      }
                                    ]
                                  ]
                                }
                              ],
                              "**quasiIds**: Set of fields to compute k-anonymity over. When multiple fields are specified, they are considered a single composite key. Structs and repeated data types are not supported; however, nested fields are supported so long as they are not structs themselves or nested within a repeated field."
                            ]
                          }
                        ],
                        [
                          "**kMapEstimationConfig**: Reidentifiability metric. This corresponds to a risk model similar to what is called \"journalist risk\" in the literature, except the attack dataset is statistically modeled instead of being perfectly known. This can be done using publicly available data (like the US Census), or using a custom statistical model (indicated as one or several BigQuery tables), or by extrapolating from the distribution of values in the input dataset.",
                          {
                            "$ul": [
                              "**auxiliaryTables**: Several auxiliary tables can be used in the analysis. Each custom_tag used to tag a quasi-identifiers column must appear in exactly one column of one auxiliary table.",
                              "**quasiIds**: Required. Fields considered to be quasi-identifiers. No two columns can have the same tag.",
                              "**regionCode**: ISO 3166-1 alpha-2 region code to use in the statistical modeling. Set if no column is tagged with a region-specific InfoType (like US_ZIP_5) or a region code."
                            ]
                          }
                        ],
                        [
                          "**lDiversityConfig**: l-diversity metric, used for analysis of reidentification risk.",
                          {
                            "$ul": [
                              "**quasiIds**: Set of quasi-identifiers indicating how equivalence classes are defined for the l-diversity computation. When multiple fields are specified, they are considered a single composite key.",
                              [
                                "**sensitiveAttribute**: General identifier of a data field in a storage service.",
                                {
                                  "$ul": [
                                    "**name**: Name describing the field."
                                  ]
                                }
                              ]
                            ]
                          }
                        ],
                        [
                          "**numericalStatsConfig**: Compute numerical stats over an individual column, including min, max, and quantiles.",
                          {
                            "$ul": [
                              [
                                "**field**: General identifier of a data field in a storage service.",
                                {
                                  "$ul": [
                                    "**name**: Name describing the field."
                                  ]
                                }
                              ]
                            ]
                          }
                        ]
                      ]
                    }
                  ],
                  [
                    "**requestedSourceTable**: Message defining the location of a BigQuery table. A table is uniquely identified by its project_id, dataset_id, and table_name. Within a query a table is often referenced with a string in the format of: `:.` or `..`.",
                    {
                      "$ul": [
                        "**datasetId**: Dataset ID of the table.",
                        "**projectId**: The Google Cloud Platform project ID of the project containing the table. If omitted, project ID is inferred from the API call.",
                        "**tableId**: Name of the table."
                      ]
                    }
                  ]
                ]
              }
            ],
            "**startTime**: Time when the job started.",
            "**state**: State of a job.",
            "**type**: The type of job."
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    }
  }
}
