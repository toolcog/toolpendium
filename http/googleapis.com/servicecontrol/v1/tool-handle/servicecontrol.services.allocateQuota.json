{
  "name": "servicecontrol_services_allocateQuota",
  "description": "Attempts to allocate quota for the specified consumer. It should be called before the operation is executed. This method requires the `servicemanagement.services.quota` permission on the specified service. For more information, see [Cloud IAM](https://cloud.google.com/iam). **NOTE:** The client **must** fail-open on server errors `INTERNAL`, `UNKNOWN`, `DEADLINE_EXCEEDED`, and `UNAVAILABLE`. To ensure system reliability, the server may inject these errors to prohibit any hard dependency on the quota functionality.",
  "parameters": {
    "type": "object",
    "properties": {
      "serviceName": {
        "type": "string",
        "description": "Name of the service as specified in the service configuration. For example, `\"pubsub.googleapis.com\"`. See google.api.Service for the definition of a service name."
      },
      "$.xgafv": {
        "enum": [
          "1",
          "2"
        ],
        "type": "string",
        "description": "V1 error format."
      },
      "access_token": {
        "type": "string",
        "description": "OAuth access token."
      },
      "alt": {
        "enum": [
          "json",
          "media",
          "proto"
        ],
        "type": "string",
        "description": "Data format for response."
      },
      "callback": {
        "type": "string",
        "description": "JSONP"
      },
      "fields": {
        "type": "string",
        "description": "Selector specifying which fields to include in a partial response."
      },
      "key": {
        "type": "string",
        "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
      },
      "oauth_token": {
        "type": "string",
        "description": "OAuth 2.0 token for the current user."
      },
      "prettyPrint": {
        "type": "boolean",
        "description": "Returns response with indentations and line breaks."
      },
      "quotaUser": {
        "type": "string",
        "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
      },
      "upload_protocol": {
        "type": "string",
        "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
      },
      "uploadType": {
        "type": "string",
        "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
      },
      "body": {
        "$ref": "#/$defs/AllocateQuotaRequest"
      }
    },
    "required": [
      "serviceName"
    ],
    "$defs": {
      "AllocateQuotaRequest": {
        "description": "Request message for the AllocateQuota method.",
        "properties": {
          "allocateOperation": {
            "$ref": "#/$defs/QuotaOperation"
          },
          "serviceConfigId": {
            "description": "Specifies which version of service configuration should be used to process the request. If unspecified or no matching version can be found, the latest one will be used.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "QuotaOperation": {
        "description": "Represents information regarding a quota operation.",
        "properties": {
          "consumerId": {
            "description": "Identity of the consumer for whom this quota operation is being performed. This can be in one of the following formats: project:, project_number:, api_key:.",
            "type": "string"
          },
          "labels": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Labels describing the operation.",
            "type": "object"
          },
          "methodName": {
            "description": "Fully qualified name of the API method for which this quota operation is requested. This name is used for matching quota rules or metric rules and billing status rules defined in service configuration. This field should not be set if any of the following is true: (1) the quota operation is performed on non-API resources. (2) quota_metrics is set because the caller is doing quota override. Example of an RPC method name: google.example.library.v1.LibraryService.CreateShelf",
            "type": "string"
          },
          "operationId": {
            "description": "Identity of the operation. For Allocation Quota, this is expected to be unique within the scope of the service that generated the operation, and guarantees idempotency in case of retries. In order to ensure best performance and latency in the Quota backends, operation_ids are optimally associated with time, so that related operations can be accessed fast in storage. For this reason, the recommended token for services that intend to operate at a high QPS is Unix time in nanos + UUID",
            "type": "string"
          },
          "quotaMetrics": {
            "description": "Represents information about this operation. Each MetricValueSet corresponds to a metric defined in the service configuration. The data type used in the MetricValueSet must agree with the data type specified in the metric definition. Within a single operation, it is not allowed to have more than one MetricValue instances that have the same metric names and identical label value combinations. If a request has such duplicated MetricValue instances, the entire request is rejected with an invalid argument error. This field is mutually exclusive with method_name.",
            "items": {
              "$ref": "#/$defs/MetricValueSet"
            },
            "type": "array"
          },
          "quotaMode": {
            "description": "Quota mode for this operation.",
            "enum": [
              "UNSPECIFIED",
              "NORMAL",
              "BEST_EFFORT",
              "CHECK_ONLY",
              "ADJUST_ONLY"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "MetricValueSet": {
        "description": "Represents a set of metric values in the same metric. Each metric value in the set should have a unique combination of start time, end time, and label values.",
        "properties": {
          "metricName": {
            "description": "The metric name defined in the service configuration.",
            "type": "string"
          },
          "metricValues": {
            "description": "The values in this metric.",
            "items": {
              "$ref": "#/$defs/MetricValue"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "MetricValue": {
        "description": "Represents a single metric value.",
        "properties": {
          "boolValue": {
            "description": "A boolean value.",
            "type": "boolean"
          },
          "distributionValue": {
            "$ref": "#/$defs/Distribution"
          },
          "doubleValue": {
            "description": "A double precision floating point value.",
            "format": "double",
            "type": "number"
          },
          "endTime": {
            "description": "The end of the time period over which this metric value's measurement applies. If not specified, google.api.servicecontrol.v1.Operation.end_time will be used.",
            "format": "google-datetime",
            "type": "string"
          },
          "int64Value": {
            "description": "A signed 64-bit integer value.",
            "format": "int64",
            "type": "string"
          },
          "labels": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "The labels describing the metric value. See comments on google.api.servicecontrol.v1.Operation.labels for the overriding relationship. Note that this map must not contain monitored resource labels.",
            "type": "object"
          },
          "moneyValue": {
            "$ref": "#/$defs/Money"
          },
          "startTime": {
            "description": "The start of the time period over which this metric value's measurement applies. The time period has different semantics for different metric types (cumulative, delta, and gauge). See the metric definition documentation in the service configuration for details. If not specified, google.api.servicecontrol.v1.Operation.start_time will be used.",
            "format": "google-datetime",
            "type": "string"
          },
          "stringValue": {
            "description": "A text string value.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "Distribution": {
        "description": "Distribution represents a frequency distribution of double-valued sample points. It contains the size of the population of sample points plus additional optional information: * the arithmetic mean of the samples * the minimum and maximum of the samples * the sum-squared-deviation of the samples, used to compute variance * a histogram of the values of the sample points",
        "properties": {
          "bucketCounts": {
            "description": "The number of samples in each histogram bucket. `bucket_counts` are optional. If present, they must sum to the `count` value. The buckets are defined below in `bucket_option`. There are N buckets. `bucket_counts[0]` is the number of samples in the underflow bucket. `bucket_counts[1]` to `bucket_counts[N-1]` are the numbers of samples in each of the finite buckets. And `bucket_counts[N] is the number of samples in the overflow bucket. See the comments of `bucket_option` below for more details. Any suffix of trailing zeros may be omitted.",
            "items": {
              "format": "int64",
              "type": "string"
            },
            "type": "array"
          },
          "count": {
            "description": "The total number of samples in the distribution. Must be >= 0.",
            "format": "int64",
            "type": "string"
          },
          "exemplars": {
            "description": "Example points. Must be in increasing order of `value` field.",
            "items": {
              "$ref": "#/$defs/Exemplar"
            },
            "type": "array"
          },
          "explicitBuckets": {
            "$ref": "#/$defs/ExplicitBuckets"
          },
          "exponentialBuckets": {
            "$ref": "#/$defs/ExponentialBuckets"
          },
          "linearBuckets": {
            "$ref": "#/$defs/LinearBuckets"
          },
          "maximum": {
            "description": "The maximum of the population of values. Ignored if `count` is zero.",
            "format": "double",
            "type": "number"
          },
          "mean": {
            "description": "The arithmetic mean of the samples in the distribution. If `count` is zero then this field must be zero.",
            "format": "double",
            "type": "number"
          },
          "minimum": {
            "description": "The minimum of the population of values. Ignored if `count` is zero.",
            "format": "double",
            "type": "number"
          },
          "sumOfSquaredDeviation": {
            "description": "The sum of squared deviations from the mean: Sum[i=1..count]((x_i - mean)^2) where each x_i is a sample values. If `count` is zero then this field must be zero, otherwise validation of the request fails.",
            "format": "double",
            "type": "number"
          }
        },
        "type": "object"
      },
      "Exemplar": {
        "description": "Exemplars are example points that may be used to annotate aggregated distribution values. They are metadata that gives information about a particular value added to a Distribution bucket, such as a trace ID that was active when a value was added. They may contain further information, such as a example values and timestamps, origin, etc.",
        "properties": {
          "attachments": {
            "description": "Contextual information about the example value. Examples are: Trace: type.googleapis.com/google.monitoring.v3.SpanContext Literal string: type.googleapis.com/google.protobuf.StringValue Labels dropped during aggregation: type.googleapis.com/google.monitoring.v3.DroppedLabels There may be only a single attachment of any given message type in a single exemplar, and this is enforced by the system.",
            "items": {
              "additionalProperties": {
                "description": "Properties of the object. Contains field @type with type URL."
              },
              "type": "object"
            },
            "type": "array"
          },
          "timestamp": {
            "description": "The observation (sampling) time of the above value.",
            "format": "google-datetime",
            "type": "string"
          },
          "value": {
            "description": "Value of the exemplar point. This value determines to which bucket the exemplar belongs.",
            "format": "double",
            "type": "number"
          }
        },
        "type": "object"
      },
      "ExplicitBuckets": {
        "description": "Describing buckets with arbitrary user-provided width.",
        "properties": {
          "bounds": {
            "description": "'bound' is a list of strictly increasing boundaries between buckets. Note that a list of length N-1 defines N buckets because of fenceposting. See comments on `bucket_options` for details. The i'th finite bucket covers the interval [bound[i-1], bound[i]) where i ranges from 1 to bound_size() - 1. Note that there are no finite buckets at all if 'bound' only contains a single element; in that special case the single bound defines the boundary between the underflow and overflow buckets. bucket number lower bound upper bound i == 0 (underflow) -inf bound[i] 0 < i < bound_size() bound[i-1] bound[i] i == bound_size() (overflow) bound[i-1] +inf",
            "items": {
              "format": "double",
              "type": "number"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "ExponentialBuckets": {
        "description": "Describing buckets with exponentially growing width.",
        "properties": {
          "growthFactor": {
            "description": "The i'th exponential bucket covers the interval [scale * growth_factor^(i-1), scale * growth_factor^i) where i ranges from 1 to num_finite_buckets inclusive. Must be larger than 1.0.",
            "format": "double",
            "type": "number"
          },
          "numFiniteBuckets": {
            "description": "The number of finite buckets. With the underflow and overflow buckets, the total number of buckets is `num_finite_buckets` + 2. See comments on `bucket_options` for details.",
            "format": "int32",
            "type": "integer"
          },
          "scale": {
            "description": "The i'th exponential bucket covers the interval [scale * growth_factor^(i-1), scale * growth_factor^i) where i ranges from 1 to num_finite_buckets inclusive. Must be > 0.",
            "format": "double",
            "type": "number"
          }
        },
        "type": "object"
      },
      "LinearBuckets": {
        "description": "Describing buckets with constant width.",
        "properties": {
          "numFiniteBuckets": {
            "description": "The number of finite buckets. With the underflow and overflow buckets, the total number of buckets is `num_finite_buckets` + 2. See comments on `bucket_options` for details.",
            "format": "int32",
            "type": "integer"
          },
          "offset": {
            "description": "The i'th linear bucket covers the interval [offset + (i-1) * width, offset + i * width) where i ranges from 1 to num_finite_buckets, inclusive.",
            "format": "double",
            "type": "number"
          },
          "width": {
            "description": "The i'th linear bucket covers the interval [offset + (i-1) * width, offset + i * width) where i ranges from 1 to num_finite_buckets, inclusive. Must be strictly positive.",
            "format": "double",
            "type": "number"
          }
        },
        "type": "object"
      },
      "Money": {
        "description": "Represents an amount of money with its currency type.",
        "properties": {
          "currencyCode": {
            "description": "The three-letter currency code defined in ISO 4217.",
            "type": "string"
          },
          "nanos": {
            "description": "Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.",
            "format": "int32",
            "type": "integer"
          },
          "units": {
            "description": "The whole units of the amount. For example if `currencyCode` is `\"USD\"`, then 1 unit is one US dollar.",
            "format": "int64",
            "type": "string"
          }
        },
        "type": "object"
      }
    }
  },
  "handler": "http",
  "request": {
    "method": "POST",
    "url": {
      "$uri": "https://servicecontrol.googleapis.com//v1/services/{serviceName}:allocateQuota{?$.xgafv,access_token,alt,callback,fields,key,oauth_token,prettyPrint,quotaUser,upload_protocol,uploadType}"
    },
    "body": {
      "$": "body",
      "encode": "json"
    }
  },
  "responses": {
    "200": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "Response message for the AllocateQuota method.",
        "**Key properties:**",
        {
          "$ul": [
            "**allocateErrors**: Indicates the decision of the allocate.",
            [
              "**allocateInfo**",
              {
                "$ul": [
                  "**unusedArguments**: A list of label keys that were unused by the server in processing the request. Thus, for similar requests repeated in a certain future time window, the caller can choose to ignore these labels in the requests to achieve better client-side cache hits and quota aggregation for rate quota. This field is not populated for allocation quota checks."
                ]
              }
            ],
            "**operationId**: The same operation_id value used in the AllocateQuotaRequest. Used for logging and diagnostics purposes.",
            "**quotaMetrics**: Quota metrics to indicate the result of allocation. Depending on the request, one or more of the following metrics will be included: 1. Per quota group or per quota metric incremental usage will be specified using the following delta metric : \"serviceruntime.googleapis.com/api/consumer/quota_used_count\" 2. The quota limit reached condition will be specified using the following boolean metric : \"serviceruntime.googleapis.com/quota/exceeded\"",
            "**serviceConfigId**: ID of the actual config used to process the request."
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    }
  }
}
