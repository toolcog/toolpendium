{
  "name": "spanner_projects_instances_databases_sessions_batchWrite",
  "description": "Batches the supplied mutation groups in a collection of efficient transactions. All mutations in a group are committed atomically. However, mutations across groups can be committed non-atomically in an unspecified order and thus, they must be independent of each other. Partial failure is possible, i.e., some groups may have been committed successfully, while some may have failed. The results of individual batches are streamed into the response as the batches are applied. BatchWrite requests are not replay protected, meaning that each mutation group may be applied more than once. Replays of non-idempotent mutations may have undesirable effects. For example, replays of an insert mutation may produce an already exists error or if you use generated or commit timestamp-based keys, it may result in additional rows being added to the mutation's table. We recommend structuring your mutation groups to be idempotent to avoid this issue.",
  "parameters": {
    "type": "object",
    "properties": {
      "session": {
        "type": "string",
        "description": "Required. The session in which the batch request is to be run."
      },
      "$.xgafv": {
        "enum": [
          "1",
          "2"
        ],
        "type": "string",
        "description": "V1 error format."
      },
      "access_token": {
        "type": "string",
        "description": "OAuth access token."
      },
      "alt": {
        "enum": [
          "json",
          "media",
          "proto"
        ],
        "type": "string",
        "description": "Data format for response."
      },
      "callback": {
        "type": "string",
        "description": "JSONP"
      },
      "fields": {
        "type": "string",
        "description": "Selector specifying which fields to include in a partial response."
      },
      "key": {
        "type": "string",
        "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
      },
      "oauth_token": {
        "type": "string",
        "description": "OAuth 2.0 token for the current user."
      },
      "prettyPrint": {
        "type": "boolean",
        "description": "Returns response with indentations and line breaks."
      },
      "quotaUser": {
        "type": "string",
        "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
      },
      "upload_protocol": {
        "type": "string",
        "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
      },
      "uploadType": {
        "type": "string",
        "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
      },
      "body": {
        "$ref": "#/$defs/BatchWriteRequest"
      }
    },
    "required": [
      "session"
    ],
    "$defs": {
      "BatchWriteRequest": {
        "description": "The request for BatchWrite.",
        "properties": {
          "mutationGroups": {
            "description": "Required. The groups of mutations to be applied.",
            "items": {
              "$ref": "#/$defs/MutationGroup"
            },
            "type": "array"
          },
          "requestOptions": {
            "$ref": "#/$defs/RequestOptions"
          }
        },
        "type": "object"
      },
      "MutationGroup": {
        "description": "A group of mutations to be committed together. Related mutations should be placed in a group. For example, two mutations inserting rows with the same primary key prefix in both parent and child tables are related.",
        "properties": {
          "mutations": {
            "description": "Required. The mutations in this group.",
            "items": {
              "$ref": "#/$defs/Mutation"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "Mutation": {
        "description": "A modification to one or more Cloud Spanner rows. Mutations can be applied to a Cloud Spanner database by sending them in a Commit call.",
        "properties": {
          "delete": {
            "$ref": "#/$defs/Delete"
          },
          "insert": {
            "$ref": "#/$defs/Write"
          },
          "insertOrUpdate": {
            "$ref": "#/$defs/Write"
          },
          "replace": {
            "$ref": "#/$defs/Write"
          },
          "update": {
            "$ref": "#/$defs/Write"
          }
        },
        "type": "object"
      },
      "Delete": {
        "description": "Arguments to delete operations.",
        "properties": {
          "keySet": {
            "$ref": "#/$defs/KeySet"
          },
          "table": {
            "description": "Required. The table whose rows will be deleted.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "KeySet": {
        "description": "`KeySet` defines a collection of Cloud Spanner keys and/or key ranges. All the keys are expected to be in the same table or index. The keys need not be sorted in any particular way. If the same key is specified multiple times in the set (for example if two ranges, two keys, or a key and a range overlap), Cloud Spanner behaves as if the key were only specified once.",
        "properties": {
          "all": {
            "description": "For convenience `all` can be set to `true` to indicate that this `KeySet` matches all keys in the table or index. Note that any keys specified in `keys` or `ranges` are only yielded once.",
            "type": "boolean"
          },
          "keys": {
            "description": "A list of specific keys. Entries in `keys` should have exactly as many elements as there are columns in the primary or index key with which this `KeySet` is used. Individual key values are encoded as described here.",
            "items": {
              "items": {},
              "type": "array"
            },
            "type": "array"
          },
          "ranges": {
            "description": "A list of key ranges. See KeyRange for more information about key range specifications.",
            "items": {
              "$ref": "#/$defs/KeyRange"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "KeyRange": {
        "description": "KeyRange represents a range of rows in a table or index. A range has a start key and an end key. These keys can be open or closed, indicating if the range includes rows with that key. Keys are represented by lists, where the ith value in the list corresponds to the ith component of the table or index primary key. Individual values are encoded as described here. For example, consider the following table definition: CREATE TABLE UserEvents ( UserName STRING(MAX), EventDate STRING(10) ) PRIMARY KEY(UserName, EventDate); The following keys name rows in this table: \"Bob\", \"2014-09-23\" Since the `UserEvents` table's `PRIMARY KEY` clause names two columns, each `UserEvents` key has two elements; the first is the `UserName`, and the second is the `EventDate`. Key ranges with multiple components are interpreted lexicographically by component using the table or index key's declared sort order. For example, the following range returns all events for user `\"Bob\"` that occurred in the year 2015: \"start_closed\": [\"Bob\", \"2015-01-01\"] \"end_closed\": [\"Bob\", \"2015-12-31\"] Start and end keys can omit trailing key components. This affects the inclusion and exclusion of rows that exactly match the provided key components: if the key is closed, then rows that exactly match the provided components are included; if the key is open, then rows that exactly match are not included. For example, the following range includes all events for `\"Bob\"` that occurred during and after the year 2000: \"start_closed\": [\"Bob\", \"2000-01-01\"] \"end_closed\": [\"Bob\"] The next example retrieves all events for `\"Bob\"`: \"start_closed\": [\"Bob\"] \"end_closed\": [\"Bob\"] To retrieve events before the year 2000: \"start_closed\": [\"Bob\"] \"end_open\": [\"Bob\", \"2000-01-01\"] The following range includes all rows in the table: \"start_closed\": [] \"end_closed\": [] This range returns all users whose `UserName` begins with any character from A to C: \"start_closed\": [\"A\"] \"end_open\": [\"D\"] This range returns all users whose `UserName` begins with B: \"start_closed\": [\"B\"] \"end_open\": [\"C\"] Key ranges honor column sort order. For example, suppose a table is defined as follows: CREATE TABLE DescendingSortedTable { Key INT64, ... ) PRIMARY KEY(Key DESC); The following range retrieves all rows with key values between 1 and 100 inclusive: \"start_closed\": [\"100\"] \"end_closed\": [\"1\"] Note that 100 is passed as the start, and 1 is passed as the end, because `Key` is a descending column in the schema.",
        "properties": {
          "endClosed": {
            "description": "If the end is closed, then the range includes all rows whose first `len(end_closed)` key columns exactly match `end_closed`.",
            "items": {},
            "type": "array"
          },
          "endOpen": {
            "description": "If the end is open, then the range excludes rows whose first `len(end_open)` key columns exactly match `end_open`.",
            "items": {},
            "type": "array"
          },
          "startClosed": {
            "description": "If the start is closed, then the range includes all rows whose first `len(start_closed)` key columns exactly match `start_closed`.",
            "items": {},
            "type": "array"
          },
          "startOpen": {
            "description": "If the start is open, then the range excludes rows whose first `len(start_open)` key columns exactly match `start_open`.",
            "items": {},
            "type": "array"
          }
        },
        "type": "object"
      },
      "Write": {
        "description": "Arguments to insert, update, insert_or_update, and replace operations.",
        "properties": {
          "columns": {
            "description": "The names of the columns in table to be written. The list of columns must contain enough columns to allow Cloud Spanner to derive values for all primary key columns in the row(s) to be modified.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "table": {
            "description": "Required. The table whose rows will be written.",
            "type": "string"
          },
          "values": {
            "description": "The values to be written. `values` can contain more than one list of values. If it does, then multiple rows are written, one for each entry in `values`. Each list in `values` must have exactly as many entries as there are entries in columns above. Sending multiple lists is equivalent to sending multiple `Mutation`s, each containing one `values` entry and repeating table and columns. Individual values in each list are encoded as described here.",
            "items": {
              "items": {},
              "type": "array"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "RequestOptions": {
        "description": "Common request options for various APIs.",
        "properties": {
          "priority": {
            "description": "Priority for the request.",
            "enum": [
              "PRIORITY_UNSPECIFIED",
              "PRIORITY_LOW",
              "PRIORITY_MEDIUM",
              "PRIORITY_HIGH"
            ],
            "type": "string"
          },
          "requestTag": {
            "description": "A per-request tag which can be applied to queries or reads, used for statistics collection. Both request_tag and transaction_tag can be specified for a read or query that belongs to a transaction. This field is ignored for requests where it's not applicable (e.g. CommitRequest). Legal characters for `request_tag` values are all printable characters (ASCII 32 - 126) and the length of a request_tag is limited to 50 characters. Values that exceed this limit are truncated. Any leading underscore (_) characters will be removed from the string.",
            "type": "string"
          },
          "transactionTag": {
            "description": "A tag used for statistics collection about this transaction. Both request_tag and transaction_tag can be specified for a read or query that belongs to a transaction. The value of transaction_tag should be the same for all requests belonging to the same transaction. If this request doesn't belong to any transaction, transaction_tag will be ignored. Legal characters for `transaction_tag` values are all printable characters (ASCII 32 - 126) and the length of a transaction_tag is limited to 50 characters. Values that exceed this limit are truncated. Any leading underscore (_) characters will be removed from the string.",
            "type": "string"
          }
        },
        "type": "object"
      }
    }
  },
  "handler": "http",
  "request": {
    "method": "POST",
    "url": {
      "$uri": "https://spanner.googleapis.com//v1/{session}:batchWrite{?$.xgafv,access_token,alt,callback,fields,key,oauth_token,prettyPrint,quotaUser,upload_protocol,uploadType}"
    },
    "body": {
      "$": "body",
      "encode": "json"
    }
  },
  "responses": {
    "200": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "The result of applying a batch of mutations.",
        "**Key properties:**",
        {
          "$ul": [
            "**commitTimestamp**: The commit timestamp of the transaction that applied this batch. Present if `status` is `OK`, absent otherwise.",
            "**indexes**: The mutation groups applied in this batch. The values index into the `mutation_groups` field in the corresponding `BatchWriteRequest`.",
            [
              "**status**: The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).",
              {
                "$ul": [
                  "**code**: The status code, which should be an enum value of google.rpc.Code.",
                  "**details**: A list of messages that carry the error details. There is a common set of message types for APIs to use.",
                  "**message**: A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client."
                ]
              }
            ]
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    }
  }
}
