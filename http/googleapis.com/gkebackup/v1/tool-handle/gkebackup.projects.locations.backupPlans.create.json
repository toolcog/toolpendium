{
  "name": "gkebackup_projects_locations_backupPlans_create",
  "description": "Creates a new BackupPlan in a given location.",
  "parameters": {
    "type": "object",
    "properties": {
      "parent": {
        "type": "string",
        "description": "Required. The location within which to create the BackupPlan. Format: `projects/*/locations/*`"
      },
      "backupPlanId": {
        "type": "string",
        "description": "Required. The client-provided short name for the BackupPlan resource. This name must: - be between 1 and 63 characters long (inclusive) - consist of only lower-case ASCII letters, numbers, and dashes - start with a lower-case letter - end with a lower-case letter or number - be unique within the set of BackupPlans in this location"
      },
      "$.xgafv": {
        "enum": [
          "1",
          "2"
        ],
        "type": "string",
        "description": "V1 error format."
      },
      "access_token": {
        "type": "string",
        "description": "OAuth access token."
      },
      "alt": {
        "enum": [
          "json",
          "media",
          "proto"
        ],
        "type": "string",
        "description": "Data format for response."
      },
      "callback": {
        "type": "string",
        "description": "JSONP"
      },
      "fields": {
        "type": "string",
        "description": "Selector specifying which fields to include in a partial response."
      },
      "key": {
        "type": "string",
        "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
      },
      "oauth_token": {
        "type": "string",
        "description": "OAuth 2.0 token for the current user."
      },
      "prettyPrint": {
        "type": "boolean",
        "description": "Returns response with indentations and line breaks."
      },
      "quotaUser": {
        "type": "string",
        "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
      },
      "upload_protocol": {
        "type": "string",
        "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
      },
      "uploadType": {
        "type": "string",
        "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
      },
      "body": {
        "$ref": "#/$defs/BackupPlan"
      }
    },
    "required": [
      "parent"
    ],
    "$defs": {
      "BackupPlan": {
        "description": "Defines the configuration and scheduling for a \"line\" of Backups.",
        "properties": {
          "backupConfig": {
            "$ref": "#/$defs/BackupConfig"
          },
          "backupSchedule": {
            "$ref": "#/$defs/Schedule"
          },
          "cluster": {
            "description": "Required. Immutable. The source cluster from which Backups will be created via this BackupPlan. Valid formats: - `projects/*/locations/*/clusters/*` - `projects/*/zones/*/clusters/*`",
            "type": "string"
          },
          "createTime": {
            "description": "Output only. The timestamp when this BackupPlan resource was created.",
            "format": "google-datetime",
            "readOnly": true,
            "type": "string"
          },
          "deactivated": {
            "description": "Optional. This flag indicates whether this BackupPlan has been deactivated. Setting this field to True locks the BackupPlan such that no further updates will be allowed (except deletes), including the deactivated field itself. It also prevents any new Backups from being created via this BackupPlan (including scheduled Backups). Default: False",
            "type": "boolean"
          },
          "description": {
            "description": "Optional. User specified descriptive string for this BackupPlan.",
            "type": "string"
          },
          "etag": {
            "description": "Output only. `etag` is used for optimistic concurrency control as a way to help prevent simultaneous updates of a backup plan from overwriting each other. It is strongly suggested that systems make use of the 'etag' in the read-modify-write cycle to perform BackupPlan updates in order to avoid race conditions: An `etag` is returned in the response to `GetBackupPlan`, and systems are expected to put that etag in the request to `UpdateBackupPlan` or `DeleteBackupPlan` to ensure that their change will be applied to the same version of the resource.",
            "readOnly": true,
            "type": "string"
          },
          "labels": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Optional. A set of custom labels supplied by user.",
            "type": "object"
          },
          "name": {
            "description": "Output only. The full name of the BackupPlan resource. Format: `projects/*/locations/*/backupPlans/*`",
            "readOnly": true,
            "type": "string"
          },
          "protectedPodCount": {
            "description": "Output only. The number of Kubernetes Pods backed up in the last successful Backup created via this BackupPlan.",
            "format": "int32",
            "readOnly": true,
            "type": "integer"
          },
          "retentionPolicy": {
            "$ref": "#/$defs/RetentionPolicy"
          },
          "state": {
            "description": "Output only. State of the BackupPlan. This State field reflects the various stages a BackupPlan can be in during the Create operation. It will be set to \"DEACTIVATED\" if the BackupPlan is deactivated on an Update",
            "enum": [
              "STATE_UNSPECIFIED",
              "CLUSTER_PENDING",
              "PROVISIONING",
              "READY",
              "FAILED",
              "DEACTIVATED",
              "DELETING"
            ],
            "readOnly": true,
            "type": "string"
          },
          "stateReason": {
            "description": "Output only. Human-readable description of why BackupPlan is in the current `state`",
            "readOnly": true,
            "type": "string"
          },
          "uid": {
            "description": "Output only. Server generated global unique identifier of [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) format.",
            "readOnly": true,
            "type": "string"
          },
          "updateTime": {
            "description": "Output only. The timestamp when this BackupPlan resource was last updated.",
            "format": "google-datetime",
            "readOnly": true,
            "type": "string"
          }
        },
        "type": "object"
      },
      "BackupConfig": {
        "description": "BackupConfig defines the configuration of Backups created via this BackupPlan.",
        "properties": {
          "allNamespaces": {
            "description": "If True, include all namespaced resources",
            "type": "boolean"
          },
          "encryptionKey": {
            "$ref": "#/$defs/EncryptionKey"
          },
          "includeSecrets": {
            "description": "Optional. This flag specifies whether Kubernetes Secret resources should be included when they fall into the scope of Backups. Default: False",
            "type": "boolean"
          },
          "includeVolumeData": {
            "description": "Optional. This flag specifies whether volume data should be backed up when PVCs are included in the scope of a Backup. Default: False",
            "type": "boolean"
          },
          "selectedApplications": {
            "$ref": "#/$defs/NamespacedNames"
          },
          "selectedNamespaces": {
            "$ref": "#/$defs/Namespaces"
          }
        },
        "type": "object"
      },
      "EncryptionKey": {
        "description": "Defined a customer managed encryption key that will be used to encrypt Backup artifacts.",
        "properties": {
          "gcpKmsEncryptionKey": {
            "description": "Optional. Google Cloud KMS encryption key. Format: `projects/*/locations/*/keyRings/*/cryptoKeys/*`",
            "type": "string"
          }
        },
        "type": "object"
      },
      "NamespacedNames": {
        "description": "A list of namespaced Kubernetes resources.",
        "properties": {
          "namespacedNames": {
            "description": "Optional. A list of namespaced Kubernetes resources.",
            "items": {
              "$ref": "#/$defs/NamespacedName"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "NamespacedName": {
        "description": "A reference to a namespaced resource in Kubernetes.",
        "properties": {
          "name": {
            "description": "Optional. The name of the Kubernetes resource.",
            "type": "string"
          },
          "namespace": {
            "description": "Optional. The Namespace of the Kubernetes resource.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "Namespaces": {
        "description": "A list of Kubernetes Namespaces",
        "properties": {
          "namespaces": {
            "description": "Optional. A list of Kubernetes Namespaces",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "Schedule": {
        "description": "Defines scheduling parameters for automatically creating Backups via this BackupPlan.",
        "properties": {
          "cronSchedule": {
            "description": "Optional. A standard [cron](https://wikipedia.com/wiki/cron) string that defines a repeating schedule for creating Backups via this BackupPlan. This is mutually exclusive with the rpo_config field since at most one schedule can be defined for a BackupPlan. If this is defined, then backup_retain_days must also be defined. Default (empty): no automatic backup creation will occur.",
            "type": "string"
          },
          "paused": {
            "description": "Optional. This flag denotes whether automatic Backup creation is paused for this BackupPlan. Default: False",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "RetentionPolicy": {
        "description": "RetentionPolicy defines a Backup retention policy for a BackupPlan.",
        "properties": {
          "backupDeleteLockDays": {
            "description": "Optional. Minimum age for Backups created via this BackupPlan (in days). This field MUST be an integer value between 0-90 (inclusive). A Backup created under this BackupPlan will NOT be deletable until it reaches Backup's (create_time + backup_delete_lock_days). Updating this field of a BackupPlan does NOT affect existing Backups under it. Backups created AFTER a successful update will inherit the new value. Default: 0 (no delete blocking)",
            "format": "int32",
            "type": "integer"
          },
          "backupRetainDays": {
            "description": "Optional. The default maximum age of a Backup created via this BackupPlan. This field MUST be an integer value >= 0 and <= 365. If specified, a Backup created under this BackupPlan will be automatically deleted after its age reaches (create_time + backup_retain_days). If not specified, Backups created under this BackupPlan will NOT be subject to automatic deletion. Updating this field does NOT affect existing Backups under it. Backups created AFTER a successful update will automatically pick up the new value. NOTE: backup_retain_days must be >= backup_delete_lock_days. If cron_schedule is defined, then this must be <= 360 * the creation interval. If rpo_config is defined, then this must be <= 360 * target_rpo_minutes / (1440minutes/day). Default: 0 (no automatic deletion)",
            "format": "int32",
            "type": "integer"
          },
          "locked": {
            "description": "Optional. This flag denotes whether the retention policy of this BackupPlan is locked. If set to True, no further update is allowed on this policy, including the `locked` field itself. Default: False",
            "type": "boolean"
          }
        },
        "type": "object"
      }
    }
  },
  "handler": "http",
  "request": {
    "method": "POST",
    "url": {
      "$uri": "https://gkebackup.googleapis.com//v1/{parent}/backupPlans{?backupPlanId,$.xgafv,access_token,alt,callback,fields,key,oauth_token,prettyPrint,quotaUser,upload_protocol,uploadType}"
    },
    "body": {
      "$": "body",
      "encode": "json"
    }
  },
  "responses": {
    "200": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "This resource represents a long-running operation that is the result of a network API call.",
        "**Key properties:**",
        {
          "$ul": [
            "**done**: If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.",
            [
              "**error**: The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).",
              {
                "$ul": [
                  "**code**: The status code, which should be an enum value of google.rpc.Code.",
                  "**details**: A list of messages that carry the error details. There is a common set of message types for APIs to use.",
                  "**message**: A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client."
                ]
              }
            ],
            "**metadata**: Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.",
            "**name**: The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.",
            "**response**: The normal, successful response of the operation. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`."
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    }
  }
}
