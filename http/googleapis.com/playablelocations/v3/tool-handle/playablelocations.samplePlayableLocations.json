{
  "name": "playablelocations_samplePlayableLocations",
  "description": "Returns a set of playable locations that lie within a specified area, that satisfy optional filter criteria. Note: Identical `SamplePlayableLocations` requests can return different results as the state of the world changes over time.",
  "parameters": {
    "type": "object",
    "properties": {
      "$.xgafv": {
        "enum": [
          "1",
          "2"
        ],
        "type": "string",
        "description": "V1 error format."
      },
      "access_token": {
        "type": "string",
        "description": "OAuth access token."
      },
      "alt": {
        "enum": [
          "json",
          "media",
          "proto"
        ],
        "type": "string",
        "description": "Data format for response."
      },
      "callback": {
        "type": "string",
        "description": "JSONP"
      },
      "fields": {
        "type": "string",
        "description": "Selector specifying which fields to include in a partial response."
      },
      "key": {
        "type": "string",
        "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
      },
      "oauth_token": {
        "type": "string",
        "description": "OAuth 2.0 token for the current user."
      },
      "prettyPrint": {
        "type": "boolean",
        "description": "Returns response with indentations and line breaks."
      },
      "quotaUser": {
        "type": "string",
        "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
      },
      "upload_protocol": {
        "type": "string",
        "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
      },
      "uploadType": {
        "type": "string",
        "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
      },
      "body": {
        "$ref": "#/$defs/GoogleMapsPlayablelocationsV3SamplePlayableLocationsRequest"
      }
    },
    "$defs": {
      "GoogleMapsPlayablelocationsV3SamplePlayableLocationsRequest": {
        "description": " Life of a query: - When a game starts in a new location, your game server issues a SamplePlayableLocations request. The request specifies the S2 cell, and contains one or more \"criteria\" for filtering: - Criterion 0: i locations for long-lived bases, or level 0 monsters, or... - Criterion 1: j locations for short-lived bases, or level 1 monsters, ... - Criterion 2: k locations for random objects. - etc (up to 5 criterion may be specified). `PlayableLocationList` will then contain mutually exclusive lists of `PlayableLocation` objects that satisfy each of the criteria. Think of it as a collection of real-world locations that you can then associate with your game state. Note: These points are impermanent in nature. E.g, parks can close, and places can be removed. The response specifies how long you can expect the playable locations to last. Once they expire, you should query the `samplePlayableLocations` API again to get a fresh view of the real world.",
        "properties": {
          "areaFilter": {
            "$ref": "#/$defs/GoogleMapsPlayablelocationsV3SampleAreaFilter"
          },
          "criteria": {
            "description": "Required. Specifies one or more (up to 5) criteria for filtering the returned playable locations.",
            "items": {
              "$ref": "#/$defs/GoogleMapsPlayablelocationsV3SampleCriterion"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "GoogleMapsPlayablelocationsV3SampleAreaFilter": {
        "description": "Specifies the area to search for playable locations.",
        "properties": {
          "s2CellId": {
            "description": "Required. The S2 cell ID of the area you want. This must be between cell level 11 and 14 (inclusive). S2 cells are 64-bit integers that identify areas on the Earth. They are hierarchical, and can therefore be used for spatial indexing. The S2 geometry library is available in a number of languages: * [C++](https://github.com/google/s2geometry) * [Java](https://github.com/google/s2-geometry-library-java) * [Go](https://github.com/golang/geo) * [Python](https://github.com/google/s2geometry/tree/master/src/python)",
            "format": "uint64",
            "type": "string"
          }
        },
        "type": "object"
      },
      "GoogleMapsPlayablelocationsV3SampleCriterion": {
        "description": "Encapsulates a filter criterion for searching for a set of playable locations.",
        "properties": {
          "fieldsToReturn": {
            "description": "Specifies which `PlayableLocation` fields are returned. `name` (which is used for logging impressions), `center_point` and `place_id` (or `plus_code`) are always returned. The following fields are omitted unless you specify them here: * snapped_point * types Note: The more fields you include, the more expensive in terms of data and associated latency your query will be.",
            "format": "google-fieldmask",
            "type": "string"
          },
          "filter": {
            "$ref": "#/$defs/GoogleMapsPlayablelocationsV3SampleFilter"
          },
          "gameObjectType": {
            "description": "Required. An arbitrary, developer-defined identifier of the type of game object that the playable location is used for. This field allows you to specify criteria per game object type when searching for playable locations. You should assign a unique `game_object_type` ID across all `request_criteria` to represent a distinct type of game object. For example, 1=monster location, 2=powerup location. The response contains a map.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "GoogleMapsPlayablelocationsV3SampleFilter": {
        "description": "Specifies the filters to use when searching for playable locations.",
        "properties": {
          "includedTypes": {
            "description": "Restricts the set of playable locations to just the [types](/maps/documentation/gaming/tt/types) that you want.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "maxLocationCount": {
            "description": "Specifies the maximum number of playable locations to return. This value must not be greater than 1000. The default value is 100. Only the top-ranking playable locations are returned.",
            "format": "int32",
            "type": "integer"
          },
          "spacing": {
            "$ref": "#/$defs/GoogleMapsPlayablelocationsV3SampleSpacingOptions"
          }
        },
        "type": "object"
      },
      "GoogleMapsPlayablelocationsV3SampleSpacingOptions": {
        "description": "A set of options that specifies the separation between playable locations.",
        "properties": {
          "minSpacingMeters": {
            "description": "Required. The minimum spacing between any two playable locations, measured in meters. The minimum value is 30. The maximum value is 1000. Inputs will be rounded up to the next 10 meter interval. The default value is 200m. Set this field to remove tight clusters of playable locations. Note: The spacing is a greedy algorithm. It optimizes for selecting the highest ranking locations first, not to maximize the number of locations selected. Consider the following scenario: * Rank: A: 2, B: 1, C: 3. * Distance: A--200m--B--200m--C If spacing=250, it will pick the highest ranked location [B], not [A, C]. Note: Spacing works within the game object type itself, as well as the previous ones. Suppose three game object types, each with the following spacing: * X: 400m, Y: undefined, Z: 200m. 1. Add locations for X, within 400m of each other. 2. Add locations for Y, without any spacing. 3. Finally, add locations for Z within 200m of each other as well X and Y. The distance diagram between those locations end up as: * From->To. * X->X: 400m * Y->X, Y->Y: unspecified. * Z->X, Z->Y, Z->Z: 200m.",
            "format": "double",
            "type": "number"
          },
          "pointType": {
            "description": "Specifies whether the minimum spacing constraint applies to the center-point or to the snapped point of playable locations. The default value is `CENTER_POINT`. If a snapped point is not available for a playable location, its center-point is used instead. Set this to the point type used in your game.",
            "enum": [
              "POINT_TYPE_UNSPECIFIED",
              "CENTER_POINT",
              "SNAPPED_POINT"
            ],
            "type": "string"
          }
        },
        "type": "object"
      }
    }
  },
  "handler": "http",
  "request": {
    "method": "POST",
    "url": {
      "$uri": "https://playablelocations.googleapis.com//v3:samplePlayableLocations{?$.xgafv,access_token,alt,callback,fields,key,oauth_token,prettyPrint,quotaUser,upload_protocol,uploadType}"
    },
    "body": {
      "$": "body",
      "encode": "json"
    }
  },
  "responses": {
    "200": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        " Response for the SamplePlayableLocations method.",
        "**Key properties:**",
        {
          "$ul": [
            "**locationsPerGameObjectType**: Each PlayableLocation object corresponds to a game_object_type specified in the request.",
            "**ttl**: Required. Specifies the \"time-to-live\" for the set of playable locations. You can use this value to determine how long to cache the set of playable locations. After this length of time, your back-end game server should issue a new SamplePlayableLocations request to get a fresh set of playable locations (because for example, they might have been removed, a park might have closed for the day, a business might have closed permanently)."
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    }
  }
}
