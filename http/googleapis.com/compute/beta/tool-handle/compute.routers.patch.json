{
  "name": "compute_routers_patch",
  "description": "Patches the specified Router resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules.",
  "parameters": {
    "type": "object",
    "properties": {
      "project": {
        "type": "string",
        "description": "Project ID for this request."
      },
      "region": {
        "type": "string",
        "description": "Name of the region for this request."
      },
      "router": {
        "type": "string",
        "description": "Name of the Router resource to patch."
      },
      "requestId": {
        "type": "string",
        "description": "An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000)."
      },
      "$.xgafv": {
        "enum": [
          "1",
          "2"
        ],
        "type": "string",
        "description": "V1 error format."
      },
      "access_token": {
        "type": "string",
        "description": "OAuth access token."
      },
      "alt": {
        "enum": [
          "json",
          "media",
          "proto"
        ],
        "type": "string",
        "description": "Data format for response."
      },
      "callback": {
        "type": "string",
        "description": "JSONP"
      },
      "fields": {
        "type": "string",
        "description": "Selector specifying which fields to include in a partial response."
      },
      "key": {
        "type": "string",
        "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
      },
      "oauth_token": {
        "type": "string",
        "description": "OAuth 2.0 token for the current user."
      },
      "prettyPrint": {
        "type": "boolean",
        "description": "Returns response with indentations and line breaks."
      },
      "quotaUser": {
        "type": "string",
        "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
      },
      "upload_protocol": {
        "type": "string",
        "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
      },
      "uploadType": {
        "type": "string",
        "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
      },
      "userIp": {
        "type": "string",
        "description": "Legacy name for parameter that has been superseded by `quotaUser`."
      },
      "body": {
        "$ref": "#/$defs/Router"
      }
    },
    "required": [
      "project",
      "region",
      "router"
    ],
    "$defs": {
      "Router": {
        "description": "Represents a Cloud Router resource. For more information about Cloud Router, read the Cloud Router overview.",
        "properties": {
          "bgp": {
            "$ref": "#/$defs/RouterBgp"
          },
          "bgpPeers": {
            "description": "BGP information that must be configured into the routing stack to establish BGP peering. This information must specify the peer ASN and either the interface name, IP address, or peer IP address. Please refer to RFC4273.",
            "items": {
              "$ref": "#/$defs/RouterBgpPeer"
            },
            "type": "array"
          },
          "creationTimestamp": {
            "description": "[Output Only] Creation timestamp in RFC3339 text format.",
            "type": "string"
          },
          "description": {
            "description": "An optional description of this resource. Provide this property when you create the resource.",
            "type": "string"
          },
          "encryptedInterconnectRouter": {
            "description": "Indicates if a router is dedicated for use with encrypted VLAN attachments (interconnectAttachments).",
            "type": "boolean"
          },
          "id": {
            "description": "[Output Only] The unique identifier for the resource. This identifier is defined by the server.",
            "format": "uint64",
            "type": "string"
          },
          "interfaces": {
            "description": "Router interfaces. To create a BGP peer that uses a router interface, the interface must have one of the following fields specified: - linkedVpnTunnel - linkedInterconnectAttachment - subnetwork You can create a router interface without any of these fields specified. However, you cannot create a BGP peer that uses that interface.",
            "items": {
              "$ref": "#/$defs/RouterInterface"
            },
            "type": "array"
          },
          "kind": {
            "default": "compute#router",
            "description": "[Output Only] Type of resource. Always compute#router for routers.",
            "type": "string"
          },
          "md5AuthenticationKeys": {
            "description": "Keys used for MD5 authentication.",
            "items": {
              "$ref": "#/$defs/RouterMd5AuthenticationKey"
            },
            "type": "array"
          },
          "name": {
            "description": "Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.",
            "pattern": "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?",
            "type": "string"
          },
          "nats": {
            "description": "A list of NAT services created in this router.",
            "items": {
              "$ref": "#/$defs/RouterNat"
            },
            "type": "array"
          },
          "network": {
            "description": "URI of the network to which this router belongs.",
            "type": "string"
          },
          "region": {
            "description": "[Output Only] URI of the region where the router resides. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.",
            "type": "string"
          },
          "selfLink": {
            "description": "[Output Only] Server-defined URL for the resource.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "RouterBgp": {
        "properties": {
          "advertiseMode": {
            "description": "User-specified flag to indicate which mode to use for advertisement. The options are DEFAULT or CUSTOM.",
            "enum": [
              "CUSTOM",
              "DEFAULT"
            ],
            "type": "string"
          },
          "advertisedGroups": {
            "description": "User-specified list of prefix groups to advertise in custom mode. This field can only be populated if advertise_mode is CUSTOM and is advertised to all peers of the router. These groups will be advertised in addition to any specified prefixes. Leave this field blank to advertise no custom groups.",
            "items": {
              "enum": [
                "ALL_SUBNETS"
              ],
              "type": "string"
            },
            "type": "array"
          },
          "advertisedIpRanges": {
            "description": "User-specified list of individual IP ranges to advertise in custom mode. This field can only be populated if advertise_mode is CUSTOM and is advertised to all peers of the router. These IP ranges will be advertised in addition to any specified groups. Leave this field blank to advertise no custom IP ranges.",
            "items": {
              "$ref": "#/$defs/RouterAdvertisedIpRange"
            },
            "type": "array"
          },
          "asn": {
            "description": "Local BGP Autonomous System Number (ASN). Must be an RFC6996 private ASN, either 16-bit or 32-bit. The value will be fixed for this router resource. All VPN tunnels that link to this router will have the same local ASN.",
            "format": "uint32",
            "type": "integer"
          },
          "identifierRange": {
            "description": "Explicitly specifies a range of valid BGP Identifiers for this Router. It is provided as a link-local IPv4 range (from 169.254.0.0/16), of size at least /30, even if the BGP sessions are over IPv6. It must not overlap with any IPv4 BGP session ranges. Other vendors commonly call this \"router ID\".",
            "type": "string"
          },
          "keepaliveInterval": {
            "description": "The interval in seconds between BGP keepalive messages that are sent to the peer. Hold time is three times the interval at which keepalive messages are sent, and the hold time is the maximum number of seconds allowed to elapse between successive keepalive messages that BGP receives from a peer. BGP will use the smaller of either the local hold time value or the peer's hold time value as the hold time for the BGP connection between the two peers. If set, this value must be between 20 and 60. The default is 20.",
            "format": "uint32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "RouterAdvertisedIpRange": {
        "description": "Description-tagged IP ranges for the router to advertise.",
        "properties": {
          "description": {
            "description": "User-specified description for the IP range.",
            "type": "string"
          },
          "range": {
            "description": "The IP range to advertise. The value must be a CIDR-formatted string.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "RouterBgpPeer": {
        "properties": {
          "advertiseMode": {
            "description": "User-specified flag to indicate which mode to use for advertisement.",
            "enum": [
              "CUSTOM",
              "DEFAULT"
            ],
            "type": "string"
          },
          "advertisedGroups": {
            "description": "User-specified list of prefix groups to advertise in custom mode, which currently supports the following option: - ALL_SUBNETS: Advertises all of the router's own VPC subnets. This excludes any routes learned for subnets that use VPC Network Peering. Note that this field can only be populated if advertise_mode is CUSTOM and overrides the list defined for the router (in the \"bgp\" message). These groups are advertised in addition to any specified prefixes. Leave this field blank to advertise no custom groups.",
            "items": {
              "enum": [
                "ALL_SUBNETS"
              ],
              "type": "string"
            },
            "type": "array"
          },
          "advertisedIpRanges": {
            "description": "User-specified list of individual IP ranges to advertise in custom mode. This field can only be populated if advertise_mode is CUSTOM and overrides the list defined for the router (in the \"bgp\" message). These IP ranges are advertised in addition to any specified groups. Leave this field blank to advertise no custom IP ranges.",
            "items": {
              "$ref": "#/$defs/RouterAdvertisedIpRange"
            },
            "type": "array"
          },
          "advertisedRoutePriority": {
            "description": "The priority of routes advertised to this BGP peer. Where there is more than one matching route of maximum length, the routes with the lowest priority value win.",
            "format": "uint32",
            "type": "integer"
          },
          "bfd": {
            "$ref": "#/$defs/RouterBgpPeerBfd"
          },
          "customLearnedIpRanges": {
            "description": "A list of user-defined custom learned route IP address ranges for a BGP session.",
            "items": {
              "$ref": "#/$defs/RouterBgpPeerCustomLearnedIpRange"
            },
            "type": "array"
          },
          "customLearnedRoutePriority": {
            "description": "The user-defined custom learned route priority for a BGP session. This value is applied to all custom learned route ranges for the session. You can choose a value from `0` to `65335`. If you don't provide a value, Google Cloud assigns a priority of `100` to the ranges.",
            "format": "int32",
            "type": "integer"
          },
          "enable": {
            "description": "The status of the BGP peer connection. If set to FALSE, any active session with the peer is terminated and all associated routing information is removed. If set to TRUE, the peer connection can be established with routing information. The default is TRUE.",
            "enum": [
              "FALSE",
              "TRUE"
            ],
            "type": "string"
          },
          "enableIpv4": {
            "description": "Enable IPv4 traffic over BGP Peer. It is enabled by default if the peerIpAddress is version 4.",
            "type": "boolean"
          },
          "enableIpv6": {
            "description": "Enable IPv6 traffic over BGP Peer. If not specified, it is disabled by default.",
            "type": "boolean"
          },
          "interfaceName": {
            "description": "Name of the interface the BGP peer is associated with.",
            "type": "string"
          },
          "ipAddress": {
            "description": "IP address of the interface inside Google Cloud Platform. Only IPv4 is supported.",
            "type": "string"
          },
          "ipv4NexthopAddress": {
            "description": "IPv4 address of the interface inside Google Cloud Platform.",
            "type": "string"
          },
          "ipv6NexthopAddress": {
            "description": "IPv6 address of the interface inside Google Cloud Platform.",
            "type": "string"
          },
          "managementType": {
            "description": "[Output Only] The resource that configures and manages this BGP peer. - MANAGED_BY_USER is the default value and can be managed by you or other users - MANAGED_BY_ATTACHMENT is a BGP peer that is configured and managed by Cloud Interconnect, specifically by an InterconnectAttachment of type PARTNER. Google automatically creates, updates, and deletes this type of BGP peer when the PARTNER InterconnectAttachment is created, updated, or deleted. ",
            "enum": [
              "MANAGED_BY_ATTACHMENT",
              "MANAGED_BY_USER"
            ],
            "type": "string"
          },
          "md5AuthenticationKeyName": {
            "description": "Present if MD5 authentication is enabled for the peering. Must be the name of one of the entries in the Router.md5_authentication_keys. The field must comply with RFC1035.",
            "type": "string"
          },
          "name": {
            "description": "Name of this BGP peer. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.",
            "pattern": "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?",
            "type": "string"
          },
          "peerAsn": {
            "description": "Peer BGP Autonomous System Number (ASN). Each BGP interface may use a different value.",
            "format": "uint32",
            "type": "integer"
          },
          "peerIpAddress": {
            "description": "IP address of the BGP interface outside Google Cloud Platform. Only IPv4 is supported.",
            "type": "string"
          },
          "peerIpv4NexthopAddress": {
            "description": "IPv4 address of the BGP interface outside Google Cloud Platform.",
            "type": "string"
          },
          "peerIpv6NexthopAddress": {
            "description": "IPv6 address of the BGP interface outside Google Cloud Platform.",
            "type": "string"
          },
          "routerApplianceInstance": {
            "description": "URI of the VM instance that is used as third-party router appliances such as Next Gen Firewalls, Virtual Routers, or Router Appliances. The VM instance must be located in zones contained in the same region as this Cloud Router. The VM instance is the peer side of the BGP session.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "RouterBgpPeerBfd": {
        "properties": {
          "minReceiveInterval": {
            "description": "The minimum interval, in milliseconds, between BFD control packets received from the peer router. The actual value is negotiated between the two routers and is equal to the greater of this value and the transmit interval of the other router. If set, this value must be between 1000 and 30000. The default is 1000.",
            "format": "uint32",
            "type": "integer"
          },
          "minTransmitInterval": {
            "description": "The minimum interval, in milliseconds, between BFD control packets transmitted to the peer router. The actual value is negotiated between the two routers and is equal to the greater of this value and the corresponding receive interval of the other router. If set, this value must be between 1000 and 30000. The default is 1000.",
            "format": "uint32",
            "type": "integer"
          },
          "multiplier": {
            "description": "The number of consecutive BFD packets that must be missed before BFD declares that a peer is unavailable. If set, the value must be a value between 5 and 16. The default is 5.",
            "format": "uint32",
            "type": "integer"
          },
          "sessionInitializationMode": {
            "description": "The BFD session initialization mode for this BGP peer. If set to ACTIVE, the Cloud Router will initiate the BFD session for this BGP peer. If set to PASSIVE, the Cloud Router will wait for the peer router to initiate the BFD session for this BGP peer. If set to DISABLED, BFD is disabled for this BGP peer. The default is DISABLED.",
            "enum": [
              "ACTIVE",
              "DISABLED",
              "PASSIVE"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "RouterBgpPeerCustomLearnedIpRange": {
        "properties": {
          "range": {
            "description": "The custom learned route IP address range. Must be a valid CIDR-formatted prefix. If an IP address is provided without a subnet mask, it is interpreted as, for IPv4, a `/32` singular IP address range, and, for IPv6, `/128`.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "RouterInterface": {
        "properties": {
          "ipRange": {
            "description": "IP address and range of the interface. The IP range must be in the RFC3927 link-local IP address space. The value must be a CIDR-formatted string, for example: 169.254.0.1/30. NOTE: Do not truncate the address as it represents the IP address of the interface.",
            "type": "string"
          },
          "ipVersion": {
            "description": "IP version of this interface.",
            "enum": [
              "IPV4",
              "IPV6"
            ],
            "type": "string"
          },
          "linkedInterconnectAttachment": {
            "description": "URI of the linked Interconnect attachment. It must be in the same region as the router. Each interface can have one linked resource, which can be a VPN tunnel, an Interconnect attachment, or a subnetwork.",
            "type": "string"
          },
          "linkedVpnTunnel": {
            "description": "URI of the linked VPN tunnel, which must be in the same region as the router. Each interface can have one linked resource, which can be a VPN tunnel, an Interconnect attachment, or a subnetwork.",
            "type": "string"
          },
          "managementType": {
            "description": "[Output Only] The resource that configures and manages this interface. - MANAGED_BY_USER is the default value and can be managed directly by users. - MANAGED_BY_ATTACHMENT is an interface that is configured and managed by Cloud Interconnect, specifically, by an InterconnectAttachment of type PARTNER. Google automatically creates, updates, and deletes this type of interface when the PARTNER InterconnectAttachment is created, updated, or deleted. ",
            "enum": [
              "MANAGED_BY_ATTACHMENT",
              "MANAGED_BY_USER"
            ],
            "type": "string"
          },
          "name": {
            "description": "Name of this interface entry. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.",
            "pattern": "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?",
            "type": "string"
          },
          "privateIpAddress": {
            "description": "The regional private internal IP address that is used to establish BGP sessions to a VM instance acting as a third-party Router Appliance, such as a Next Gen Firewall, a Virtual Router, or an SD-WAN VM.",
            "type": "string"
          },
          "redundantInterface": {
            "description": "Name of the interface that will be redundant with the current interface you are creating. The redundantInterface must belong to the same Cloud Router as the interface here. To establish the BGP session to a Router Appliance VM, you must create two BGP peers. The two BGP peers must be attached to two separate interfaces that are redundant with each other. The redundant_interface must be 1-63 characters long, and comply with RFC1035. Specifically, the redundant_interface must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.",
            "pattern": "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?",
            "type": "string"
          },
          "subnetwork": {
            "description": "The URI of the subnetwork resource that this interface belongs to, which must be in the same region as the Cloud Router. When you establish a BGP session to a VM instance using this interface, the VM instance must belong to the same subnetwork as the subnetwork specified here.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "RouterMd5AuthenticationKey": {
        "properties": {
          "key": {
            "description": "[Input only] Value of the key. For patch and update calls, it can be skipped to copy the value from the previous configuration. This is allowed if the key with the same name existed before the operation. Maximum length is 80 characters. Can only contain printable ASCII characters.",
            "type": "string"
          },
          "name": {
            "description": "Name used to identify the key. Must be unique within a router. Must be referenced by exactly one bgpPeer. Must comply with RFC1035.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "RouterNat": {
        "description": "Represents a Nat resource. It enables the VMs within the specified subnetworks to access Internet without external IP addresses. It specifies a list of subnetworks (and the ranges within) that want to use NAT. Customers can also provide the external IPs that would be used for NAT. GCP would auto-allocate ephemeral IPs if no external IPs are provided.",
        "properties": {
          "autoNetworkTier": {
            "description": "The network tier to use when automatically reserving NAT IP addresses. Must be one of: PREMIUM, STANDARD. If not specified, then the current project-level default tier is used.",
            "enum": [
              "FIXED_STANDARD",
              "PREMIUM",
              "STANDARD",
              "STANDARD_OVERRIDES_FIXED_STANDARD"
            ],
            "type": "string"
          },
          "drainNatIps": {
            "description": "A list of URLs of the IP resources to be drained. These IPs must be valid static external IPs that have been assigned to the NAT. These IPs should be used for updating/patching a NAT only.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "enableDynamicPortAllocation": {
            "description": "Enable Dynamic Port Allocation. If not specified, it is disabled by default. If set to true, - Dynamic Port Allocation will be enabled on this NAT config. - enableEndpointIndependentMapping cannot be set to true. - If minPorts is set, minPortsPerVm must be set to a power of two greater than or equal to 32. If minPortsPerVm is not set, a minimum of 32 ports will be allocated to a VM from this NAT config. ",
            "type": "boolean"
          },
          "enableEndpointIndependentMapping": {
            "type": "boolean"
          },
          "endpointTypes": {
            "description": "List of NAT-ted endpoint types supported by the Nat Gateway. If the list is empty, then it will be equivalent to include ENDPOINT_TYPE_VM",
            "items": {
              "enum": [
                "ENDPOINT_TYPE_MANAGED_PROXY_LB",
                "ENDPOINT_TYPE_SWG",
                "ENDPOINT_TYPE_VM"
              ],
              "type": "string"
            },
            "type": "array"
          },
          "icmpIdleTimeoutSec": {
            "description": "Timeout (in seconds) for ICMP connections. Defaults to 30s if not set.",
            "format": "int32",
            "type": "integer"
          },
          "logConfig": {
            "$ref": "#/$defs/RouterNatLogConfig"
          },
          "maxPortsPerVm": {
            "description": "Maximum number of ports allocated to a VM from this NAT config when Dynamic Port Allocation is enabled. If Dynamic Port Allocation is not enabled, this field has no effect. If Dynamic Port Allocation is enabled, and this field is set, it must be set to a power of two greater than minPortsPerVm, or 64 if minPortsPerVm is not set. If Dynamic Port Allocation is enabled and this field is not set, a maximum of 65536 ports will be allocated to a VM from this NAT config.",
            "format": "int32",
            "type": "integer"
          },
          "minPortsPerVm": {
            "description": "Minimum number of ports allocated to a VM from this NAT config. If not set, a default number of ports is allocated to a VM. This is rounded up to the nearest power of 2. For example, if the value of this field is 50, at least 64 ports are allocated to a VM.",
            "format": "int32",
            "type": "integer"
          },
          "name": {
            "description": "Unique name of this Nat service. The name must be 1-63 characters long and comply with RFC1035.",
            "pattern": "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?",
            "type": "string"
          },
          "natIpAllocateOption": {
            "description": "Specify the NatIpAllocateOption, which can take one of the following values: - MANUAL_ONLY: Uses only Nat IP addresses provided by customers. When there are not enough specified Nat IPs, the Nat service fails for new VMs. - AUTO_ONLY: Nat IPs are allocated by Google Cloud Platform; customers can't specify any Nat IPs. When choosing AUTO_ONLY, then nat_ip should be empty. ",
            "enum": [
              "AUTO_ONLY",
              "MANUAL_ONLY"
            ],
            "type": "string"
          },
          "natIps": {
            "description": "A list of URLs of the IP resources used for this Nat service. These IP addresses must be valid static external IP addresses assigned to the project.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "rules": {
            "description": "A list of rules associated with this NAT.",
            "items": {
              "$ref": "#/$defs/RouterNatRule"
            },
            "type": "array"
          },
          "sourceSubnetworkIpRangesToNat": {
            "description": "Specify the Nat option, which can take one of the following values: - ALL_SUBNETWORKS_ALL_IP_RANGES: All of the IP ranges in every Subnetwork are allowed to Nat. - ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES: All of the primary IP ranges in every Subnetwork are allowed to Nat. - LIST_OF_SUBNETWORKS: A list of Subnetworks are allowed to Nat (specified in the field subnetwork below) The default is SUBNETWORK_IP_RANGE_TO_NAT_OPTION_UNSPECIFIED. Note that if this field contains ALL_SUBNETWORKS_ALL_IP_RANGES then there should not be any other Router.Nat section in any Router for this network in this region.",
            "enum": [
              "ALL_SUBNETWORKS_ALL_IP_RANGES",
              "ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES",
              "LIST_OF_SUBNETWORKS"
            ],
            "type": "string"
          },
          "subnetworks": {
            "description": "A list of Subnetwork resources whose traffic should be translated by NAT Gateway. It is used only when LIST_OF_SUBNETWORKS is selected for the SubnetworkIpRangeToNatOption above.",
            "items": {
              "$ref": "#/$defs/RouterNatSubnetworkToNat"
            },
            "type": "array"
          },
          "tcpEstablishedIdleTimeoutSec": {
            "description": "Timeout (in seconds) for TCP established connections. Defaults to 1200s if not set.",
            "format": "int32",
            "type": "integer"
          },
          "tcpTimeWaitTimeoutSec": {
            "description": "Timeout (in seconds) for TCP connections that are in TIME_WAIT state. Defaults to 120s if not set.",
            "format": "int32",
            "type": "integer"
          },
          "tcpTransitoryIdleTimeoutSec": {
            "description": "Timeout (in seconds) for TCP transitory connections. Defaults to 30s if not set.",
            "format": "int32",
            "type": "integer"
          },
          "type": {
            "description": "Indicates whether this NAT is used for public or private IP translation. If unspecified, it defaults to PUBLIC.",
            "enum": [
              "PRIVATE",
              "PUBLIC"
            ],
            "type": "string"
          },
          "udpIdleTimeoutSec": {
            "description": "Timeout (in seconds) for UDP connections. Defaults to 30s if not set.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "RouterNatLogConfig": {
        "description": "Configuration of logging on a NAT.",
        "properties": {
          "enable": {
            "description": "Indicates whether or not to export logs. This is false by default.",
            "type": "boolean"
          },
          "filter": {
            "description": "Specify the desired filtering of logs on this NAT. If unspecified, logs are exported for all connections handled by this NAT. This option can take one of the following values: - ERRORS_ONLY: Export logs only for connection failures. - TRANSLATIONS_ONLY: Export logs only for successful connections. - ALL: Export logs for all connections, successful and unsuccessful. ",
            "enum": [
              "ALL",
              "ERRORS_ONLY",
              "TRANSLATIONS_ONLY"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "RouterNatRule": {
        "properties": {
          "action": {
            "$ref": "#/$defs/RouterNatRuleAction"
          },
          "description": {
            "description": "An optional description of this rule.",
            "type": "string"
          },
          "match": {
            "description": "CEL expression that specifies the match condition that egress traffic from a VM is evaluated against. If it evaluates to true, the corresponding `action` is enforced. The following examples are valid match expressions for public NAT: \"inIpRange(destination.ip, '1.1.0.0/16') || inIpRange(destination.ip, '2.2.0.0/16')\" \"destination.ip == '1.1.0.1' || destination.ip == '8.8.8.8'\" The following example is a valid match expression for private NAT: \"nexthop.hub == '//networkconnectivity.googleapis.com/projects/my-project/locations/global/hubs/hub-1'\"",
            "type": "string"
          },
          "ruleNumber": {
            "description": "An integer uniquely identifying a rule in the list. The rule number must be a positive value between 0 and 65000, and must be unique among rules within a NAT.",
            "format": "uint32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "RouterNatRuleAction": {
        "properties": {
          "sourceNatActiveIps": {
            "description": "A list of URLs of the IP resources used for this NAT rule. These IP addresses must be valid static external IP addresses assigned to the project. This field is used for public NAT.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "sourceNatActiveRanges": {
            "description": "A list of URLs of the subnetworks used as source ranges for this NAT Rule. These subnetworks must have purpose set to PRIVATE_NAT. This field is used for private NAT.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "sourceNatDrainIps": {
            "description": "A list of URLs of the IP resources to be drained. These IPs must be valid static external IPs that have been assigned to the NAT. These IPs should be used for updating/patching a NAT rule only. This field is used for public NAT.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "sourceNatDrainRanges": {
            "description": "A list of URLs of subnetworks representing source ranges to be drained. This is only supported on patch/update, and these subnetworks must have previously been used as active ranges in this NAT Rule. This field is used for private NAT.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "RouterNatSubnetworkToNat": {
        "description": "Defines the IP ranges that want to use NAT for a subnetwork.",
        "properties": {
          "name": {
            "description": "URL for the subnetwork resource that will use NAT.",
            "type": "string"
          },
          "secondaryIpRangeNames": {
            "description": "A list of the secondary ranges of the Subnetwork that are allowed to use NAT. This can be populated only if \"LIST_OF_SECONDARY_IP_RANGES\" is one of the values in source_ip_ranges_to_nat.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "sourceIpRangesToNat": {
            "description": "Specify the options for NAT ranges in the Subnetwork. All options of a single value are valid except NAT_IP_RANGE_OPTION_UNSPECIFIED. The only valid option with multiple values is: [\"PRIMARY_IP_RANGE\", \"LIST_OF_SECONDARY_IP_RANGES\"] Default: [ALL_IP_RANGES]",
            "items": {
              "enum": [
                "ALL_IP_RANGES",
                "LIST_OF_SECONDARY_IP_RANGES",
                "PRIMARY_IP_RANGE"
              ],
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      }
    }
  },
  "handler": "http",
  "request": {
    "method": "PATCH",
    "url": {
      "$uri": "https://compute.googleapis.com/compute/beta/projects/{project}/regions/{region}/routers/{router}{?requestId,$.xgafv,access_token,alt,callback,fields,key,oauth_token,prettyPrint,quotaUser,upload_protocol,uploadType,userIp}"
    },
    "body": {
      "$": "body",
      "encode": "json"
    }
  },
  "responses": {
    "200": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "Represents an Operation resource. Google Compute Engine has three Operation resources: * [Global](/compute/docs/reference/rest/beta/globalOperations) * [Regional](/compute/docs/reference/rest/beta/regionOperations) * [Zonal](/compute/docs/reference/rest/beta/zoneOperations) You can use an operation resource to manage asynchronous API requests. For more information, read Handling API responses. Operations can be global, regional or zonal. - For global operations, use the `globalOperations` resource. - For regional operations, use the `regionOperations` resource. - For zonal operations, use the `zoneOperations` resource. For more information, read Global, Regional, and Zonal Resources. Note that completed Operation resources have a limited retention period.",
        "**Key properties:**",
        {
          "$ul": [
            "**clientOperationId**: [Output Only] The value of `requestId` if you provided it in the request. Not present otherwise.",
            "**creationTimestamp**: [Deprecated] This field is deprecated.",
            "**description**: [Output Only] A textual description of the operation, which is set when the operation is created.",
            "**endTime**: [Output Only] The time that this operation was completed. This value is in RFC3339 text format.",
            [
              "**error**: [Output Only] If errors are generated during processing of the operation, this field will be populated.",
              {
                "$ul": [
                  "**errors**: [Output Only] The array of errors encountered while processing this operation."
                ]
              }
            ],
            "**httpErrorMessage**: [Output Only] If the operation fails, this field contains the HTTP error message that was returned, such as `NOT FOUND`.",
            "**httpErrorStatusCode**: [Output Only] If the operation fails, this field contains the HTTP error status code that was returned. For example, a `404` means the resource was not found.",
            "**id**: [Output Only] The unique identifier for the operation. This identifier is defined by the server.",
            "**insertTime**: [Output Only] The time that this operation was requested. This value is in RFC3339 text format.",
            [
              "**instancesBulkInsertOperationMetadata**",
              {
                "$ul": [
                  "**perLocationStatus**: Status information per location (location name is key). Example key: zones/us-central1-a"
                ]
              }
            ],
            "**kind**: [Output Only] Type of the resource. Always `compute#operation` for Operation resources. (default: compute#operation)",
            "**name**: [Output Only] Name of the operation.",
            "**operationGroupId**: [Output Only] An ID that represents a group of operations, such as when a group of operations results from a `bulkInsert` API request.",
            "**operationType**: [Output Only] The type of operation, such as `insert`, `update`, or `delete`, and so on.",
            "**progress**: [Output Only] An optional progress indicator that ranges from 0 to 100. There is no requirement that this be linear or support any granularity of operations. This should not be used to guess when the operation will be complete. This number should monotonically increase as the operation progresses.",
            "**region**: [Output Only] The URL of the region where the operation resides. Only applicable when performing regional operations.",
            "**selfLink**: [Output Only] Server-defined URL for the resource.",
            [
              "**setCommonInstanceMetadataOperationMetadata**",
              {
                "$ul": [
                  "**clientOperationId**: [Output Only] The client operation id.",
                  "**perLocationOperations**: [Output Only] Status information per location (location name is key). Example key: zones/us-central1-a"
                ]
              }
            ],
            "**startTime**: [Output Only] The time that this operation was started by the server. This value is in RFC3339 text format.",
            "**status**: [Output Only] The status of the operation, which can be one of the following: `PENDING`, `RUNNING`, or `DONE`.",
            "**statusMessage**: [Output Only] An optional textual description of the current status of the operation.",
            "**targetId**: [Output Only] The unique target ID, which identifies a specific incarnation of the target resource.",
            "**targetLink**: [Output Only] The URL of the resource that the operation modifies. For operations related to creating a snapshot, this points to the persistent disk that the snapshot was created from.",
            "**user**: [Output Only] User who requested the operation, for example: `user@example.com` or `alice_smith_identifier (global/workforcePools/example-com-us-employees)`.",
            "**warnings**: [Output Only] If warning messages are generated during processing of the operation, this field will be populated.",
            "**zone**: [Output Only] The URL of the zone where the operation resides. Only applicable when performing per-zone operations."
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    }
  }
}
