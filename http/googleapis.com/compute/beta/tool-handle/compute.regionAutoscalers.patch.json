{
  "name": "compute_regionAutoscalers_patch",
  "description": "Updates an autoscaler in the specified project using the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.",
  "parameters": {
    "type": "object",
    "properties": {
      "project": {
        "type": "string",
        "description": "Project ID for this request."
      },
      "region": {
        "type": "string",
        "description": "Name of the region scoping this request."
      },
      "autoscaler": {
        "type": "string",
        "description": "Name of the autoscaler to patch."
      },
      "requestId": {
        "type": "string",
        "description": "An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000)."
      },
      "$.xgafv": {
        "enum": [
          "1",
          "2"
        ],
        "type": "string",
        "description": "V1 error format."
      },
      "access_token": {
        "type": "string",
        "description": "OAuth access token."
      },
      "alt": {
        "enum": [
          "json",
          "media",
          "proto"
        ],
        "type": "string",
        "description": "Data format for response."
      },
      "callback": {
        "type": "string",
        "description": "JSONP"
      },
      "fields": {
        "type": "string",
        "description": "Selector specifying which fields to include in a partial response."
      },
      "key": {
        "type": "string",
        "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
      },
      "oauth_token": {
        "type": "string",
        "description": "OAuth 2.0 token for the current user."
      },
      "prettyPrint": {
        "type": "boolean",
        "description": "Returns response with indentations and line breaks."
      },
      "quotaUser": {
        "type": "string",
        "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
      },
      "upload_protocol": {
        "type": "string",
        "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
      },
      "uploadType": {
        "type": "string",
        "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
      },
      "userIp": {
        "type": "string",
        "description": "Legacy name for parameter that has been superseded by `quotaUser`."
      },
      "body": {
        "$ref": "#/$defs/Autoscaler"
      }
    },
    "required": [
      "project",
      "region"
    ],
    "$defs": {
      "Autoscaler": {
        "description": "Represents an Autoscaler resource. Google Compute Engine has two Autoscaler resources: * [Zonal](/compute/docs/reference/rest/beta/autoscalers) * [Regional](/compute/docs/reference/rest/beta/regionAutoscalers) Use autoscalers to automatically add or delete instances from a managed instance group according to your defined autoscaling policy. For more information, read Autoscaling Groups of Instances. For zonal managed instance groups resource, use the autoscaler resource. For regional managed instance groups, use the regionAutoscalers resource.",
        "properties": {
          "autoscalingPolicy": {
            "$ref": "#/$defs/AutoscalingPolicy"
          },
          "creationTimestamp": {
            "description": "[Output Only] Creation timestamp in RFC3339 text format.",
            "type": "string"
          },
          "description": {
            "description": "An optional description of this resource. Provide this property when you create the resource.",
            "type": "string"
          },
          "id": {
            "description": "[Output Only] The unique identifier for the resource. This identifier is defined by the server.",
            "format": "uint64",
            "type": "string"
          },
          "kind": {
            "default": "compute#autoscaler",
            "description": "[Output Only] Type of the resource. Always compute#autoscaler for autoscalers.",
            "type": "string"
          },
          "name": {
            "description": "Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.",
            "pattern": "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?",
            "type": "string"
          },
          "recommendedSize": {
            "description": "[Output Only] Target recommended MIG size (number of instances) computed by autoscaler. Autoscaler calculates the recommended MIG size even when the autoscaling policy mode is different from ON. This field is empty when autoscaler is not connected to an existing managed instance group or autoscaler did not generate its prediction.",
            "format": "int32",
            "type": "integer"
          },
          "region": {
            "description": "[Output Only] URL of the region where the instance group resides (for autoscalers living in regional scope).",
            "type": "string"
          },
          "scalingScheduleStatus": {
            "additionalProperties": {
              "$ref": "#/$defs/ScalingScheduleStatus"
            },
            "description": "[Output Only] Status information of existing scaling schedules.",
            "type": "object"
          },
          "selfLink": {
            "description": "[Output Only] Server-defined URL for the resource.",
            "type": "string"
          },
          "status": {
            "description": "[Output Only] The status of the autoscaler configuration. Current set of possible values: - PENDING: Autoscaler backend hasn't read new/updated configuration. - DELETING: Configuration is being deleted. - ACTIVE: Configuration is acknowledged to be effective. Some warnings might be present in the statusDetails field. - ERROR: Configuration has errors. Actionable for users. Details are present in the statusDetails field. New values might be added in the future.",
            "enum": [
              "ACTIVE",
              "DELETING",
              "ERROR",
              "PENDING"
            ],
            "type": "string"
          },
          "statusDetails": {
            "description": "[Output Only] Human-readable details about the current state of the autoscaler. Read the documentation for Commonly returned status messages for examples of status messages you might encounter.",
            "items": {
              "$ref": "#/$defs/AutoscalerStatusDetails"
            },
            "type": "array"
          },
          "target": {
            "description": "URL of the managed instance group that this autoscaler will scale. This field is required when creating an autoscaler.",
            "type": "string"
          },
          "zone": {
            "description": "[Output Only] URL of the zone where the instance group resides (for autoscalers living in zonal scope).",
            "type": "string"
          }
        },
        "type": "object"
      },
      "AutoscalingPolicy": {
        "description": "Cloud Autoscaler policy.",
        "properties": {
          "coolDownPeriodSec": {
            "description": "The number of seconds that your application takes to initialize on a VM instance. This is referred to as the [initialization period](/compute/docs/autoscaler#cool_down_period). Specifying an accurate initialization period improves autoscaler decisions. For example, when scaling out, the autoscaler ignores data from VMs that are still initializing because those VMs might not yet represent normal usage of your application. The default initialization period is 60 seconds. Initialization periods might vary because of numerous factors. We recommend that you test how long your application takes to initialize. To do this, create a VM and time your application's startup process.",
            "format": "int32",
            "type": "integer"
          },
          "cpuUtilization": {
            "$ref": "#/$defs/AutoscalingPolicyCpuUtilization"
          },
          "customMetricUtilizations": {
            "description": "Configuration parameters of autoscaling based on a custom metric.",
            "items": {
              "$ref": "#/$defs/AutoscalingPolicyCustomMetricUtilization"
            },
            "type": "array"
          },
          "loadBalancingUtilization": {
            "$ref": "#/$defs/AutoscalingPolicyLoadBalancingUtilization"
          },
          "maxNumReplicas": {
            "description": "The maximum number of instances that the autoscaler can scale out to. This is required when creating or updating an autoscaler. The maximum number of replicas must not be lower than minimal number of replicas.",
            "format": "int32",
            "type": "integer"
          },
          "minNumReplicas": {
            "description": "The minimum number of replicas that the autoscaler can scale in to. This cannot be less than 0. If not provided, autoscaler chooses a default value depending on maximum number of instances allowed.",
            "format": "int32",
            "type": "integer"
          },
          "mode": {
            "description": "Defines the operating mode for this policy. The following modes are available: - OFF: Disables the autoscaler but maintains its configuration. - ONLY_SCALE_OUT: Restricts the autoscaler to add VM instances only. - ON: Enables all autoscaler activities according to its policy. For more information, see \"Turning off or restricting an autoscaler\"",
            "enum": [
              "OFF",
              "ON",
              "ONLY_SCALE_OUT",
              "ONLY_UP"
            ],
            "type": "string"
          },
          "scaleDownControl": {
            "$ref": "#/$defs/AutoscalingPolicyScaleDownControl"
          },
          "scaleInControl": {
            "$ref": "#/$defs/AutoscalingPolicyScaleInControl"
          },
          "scalingSchedules": {
            "additionalProperties": {
              "$ref": "#/$defs/AutoscalingPolicyScalingSchedule"
            },
            "description": "Scaling schedules defined for an autoscaler. Multiple schedules can be set on an autoscaler, and they can overlap. During overlapping periods the greatest min_required_replicas of all scaling schedules is applied. Up to 128 scaling schedules are allowed.",
            "type": "object"
          }
        },
        "type": "object"
      },
      "AutoscalingPolicyCpuUtilization": {
        "description": "CPU utilization policy.",
        "properties": {
          "predictiveMethod": {
            "description": "Indicates whether predictive autoscaling based on CPU metric is enabled. Valid values are: * NONE (default). No predictive method is used. The autoscaler scales the group to meet current demand based on real-time metrics. * OPTIMIZE_AVAILABILITY. Predictive autoscaling improves availability by monitoring daily and weekly load patterns and scaling out ahead of anticipated demand.",
            "enum": [
              "NONE",
              "OPTIMIZE_AVAILABILITY",
              "PREDICTIVE_METHOD_UNSPECIFIED"
            ],
            "type": "string"
          },
          "utilizationTarget": {
            "description": "The target CPU utilization that the autoscaler maintains. Must be a float value in the range (0, 1]. If not specified, the default is 0.6. If the CPU level is below the target utilization, the autoscaler scales in the number of instances until it reaches the minimum number of instances you specified or until the average CPU of your instances reaches the target utilization. If the average CPU is above the target utilization, the autoscaler scales out until it reaches the maximum number of instances you specified or until the average utilization reaches the target utilization.",
            "format": "double",
            "type": "number"
          }
        },
        "type": "object"
      },
      "AutoscalingPolicyCustomMetricUtilization": {
        "description": "Custom utilization metric policy.",
        "properties": {
          "filter": {
            "description": "A filter string, compatible with a Stackdriver Monitoring filter string for TimeSeries.list API call. This filter is used to select a specific TimeSeries for the purpose of autoscaling and to determine whether the metric is exporting per-instance or per-group data. For the filter to be valid for autoscaling purposes, the following rules apply: - You can only use the AND operator for joining selectors. - You can only use direct equality comparison operator (=) without any functions for each selector. - You can specify the metric in both the filter string and in the metric field. However, if specified in both places, the metric must be identical. - The monitored resource type determines what kind of values are expected for the metric. If it is a gce_instance, the autoscaler expects the metric to include a separate TimeSeries for each instance in a group. In such a case, you cannot filter on resource labels. If the resource type is any other value, the autoscaler expects this metric to contain values that apply to the entire autoscaled instance group and resource label filtering can be performed to point autoscaler at the correct TimeSeries to scale upon. This is called a *per-group metric* for the purpose of autoscaling. If not specified, the type defaults to gce_instance. Try to provide a filter that is selective enough to pick just one TimeSeries for the autoscaled group or for each of the instances (if you are using gce_instance resource type). If multiple TimeSeries are returned upon the query execution, the autoscaler will sum their respective values to obtain its scaling value.",
            "type": "string"
          },
          "metric": {
            "description": "The identifier (type) of the Stackdriver Monitoring metric. The metric cannot have negative values. The metric must have a value type of INT64 or DOUBLE.",
            "type": "string"
          },
          "singleInstanceAssignment": {
            "description": "If scaling is based on a per-group metric value that represents the total amount of work to be done or resource usage, set this value to an amount assigned for a single instance of the scaled group. Autoscaler keeps the number of instances proportional to the value of this metric. The metric itself does not change value due to group resizing. A good metric to use with the target is for example pubsub.googleapis.com/subscription/num_undelivered_messages or a custom metric exporting the total number of requests coming to your instances. A bad example would be a metric exporting an average or median latency, since this value can't include a chunk assignable to a single instance, it could be better used with utilization_target instead.",
            "format": "double",
            "type": "number"
          },
          "utilizationTarget": {
            "description": "The target value of the metric that autoscaler maintains. This must be a positive value. A utilization metric scales number of virtual machines handling requests to increase or decrease proportionally to the metric. For example, a good metric to use as a utilization_target is https://www.googleapis.com/compute/v1/instance/network/received_bytes_count. The autoscaler works to keep this value constant for each of the instances.",
            "format": "double",
            "type": "number"
          },
          "utilizationTargetType": {
            "description": "Defines how target utilization value is expressed for a Stackdriver Monitoring metric. Either GAUGE, DELTA_PER_SECOND, or DELTA_PER_MINUTE.",
            "enum": [
              "DELTA_PER_MINUTE",
              "DELTA_PER_SECOND",
              "GAUGE"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "AutoscalingPolicyLoadBalancingUtilization": {
        "description": "Configuration parameters of autoscaling based on load balancing.",
        "properties": {
          "utilizationTarget": {
            "description": "Fraction of backend capacity utilization (set in HTTP(S) load balancing configuration) that the autoscaler maintains. Must be a positive float value. If not defined, the default is 0.8.",
            "format": "double",
            "type": "number"
          }
        },
        "type": "object"
      },
      "AutoscalingPolicyScaleDownControl": {
        "description": "Configuration that allows for slower scale in so that even if Autoscaler recommends an abrupt scale in of a MIG, it will be throttled as specified by the parameters below.",
        "properties": {
          "maxScaledDownReplicas": {
            "$ref": "#/$defs/FixedOrPercent"
          },
          "timeWindowSec": {
            "description": "How far back autoscaling looks when computing recommendations to include directives regarding slower scale in, as described above.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "FixedOrPercent": {
        "description": "Encapsulates numeric value that can be either absolute or relative.",
        "properties": {
          "calculated": {
            "description": "[Output Only] Absolute value of VM instances calculated based on the specific mode. - If the value is fixed, then the calculated value is equal to the fixed value. - If the value is a percent, then the calculated value is percent/100 * targetSize. For example, the calculated value of a 80% of a managed instance group with 150 instances would be (80/100 * 150) = 120 VM instances. If there is a remainder, the number is rounded. ",
            "format": "int32",
            "type": "integer"
          },
          "fixed": {
            "description": "Specifies a fixed number of VM instances. This must be a positive integer.",
            "format": "int32",
            "type": "integer"
          },
          "percent": {
            "description": "Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "AutoscalingPolicyScaleInControl": {
        "description": "Configuration that allows for slower scale in so that even if Autoscaler recommends an abrupt scale in of a MIG, it will be throttled as specified by the parameters below.",
        "properties": {
          "maxScaledInReplicas": {
            "$ref": "#/$defs/FixedOrPercent"
          },
          "timeWindowSec": {
            "description": "How far back autoscaling looks when computing recommendations to include directives regarding slower scale in, as described above.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "AutoscalingPolicyScalingSchedule": {
        "description": "Scaling based on user-defined schedule. The message describes a single scaling schedule. A scaling schedule changes the minimum number of VM instances an autoscaler can recommend, which can trigger scaling out.",
        "properties": {
          "description": {
            "description": "A description of a scaling schedule.",
            "type": "string"
          },
          "disabled": {
            "description": "A boolean value that specifies whether a scaling schedule can influence autoscaler recommendations. If set to true, then a scaling schedule has no effect. This field is optional, and its value is false by default.",
            "type": "boolean"
          },
          "durationSec": {
            "description": "The duration of time intervals, in seconds, for which this scaling schedule is to run. The minimum allowed value is 300. This field is required.",
            "format": "int32",
            "type": "integer"
          },
          "minRequiredReplicas": {
            "description": "The minimum number of VM instances that the autoscaler will recommend in time intervals starting according to schedule. This field is required.",
            "format": "int32",
            "type": "integer"
          },
          "schedule": {
            "description": "The start timestamps of time intervals when this scaling schedule is to provide a scaling signal. This field uses the extended cron format (with an optional year field). The expression can describe a single timestamp if the optional year is set, in which case the scaling schedule runs once. The schedule is interpreted with respect to time_zone. This field is required. Note: These timestamps only describe when autoscaler starts providing the scaling signal. The VMs need additional time to become serving.",
            "type": "string"
          },
          "timeZone": {
            "description": "The time zone to use when interpreting the schedule. The value of this field must be a time zone name from the tz database: https://en.wikipedia.org/wiki/Tz_database. This field is assigned a default value of \"UTC\" if left empty.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "ScalingScheduleStatus": {
        "properties": {
          "lastStartTime": {
            "description": "[Output Only] The last time the scaling schedule became active. Note: this is a timestamp when a schedule actually became active, not when it was planned to do so. The timestamp is in RFC3339 text format.",
            "type": "string"
          },
          "nextStartTime": {
            "description": "[Output Only] The next time the scaling schedule is to become active. Note: this is a timestamp when a schedule is planned to run, but the actual time might be slightly different. The timestamp is in RFC3339 text format.",
            "type": "string"
          },
          "state": {
            "description": "[Output Only] The current state of a scaling schedule.",
            "enum": [
              "ACTIVE",
              "DISABLED",
              "OBSOLETE",
              "READY"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "AutoscalerStatusDetails": {
        "properties": {
          "message": {
            "description": "The status message.",
            "type": "string"
          },
          "type": {
            "description": "The type of error, warning, or notice returned. Current set of possible values: - ALL_INSTANCES_UNHEALTHY (WARNING): All instances in the instance group are unhealthy (not in RUNNING state). - BACKEND_SERVICE_DOES_NOT_EXIST (ERROR): There is no backend service attached to the instance group. - CAPPED_AT_MAX_NUM_REPLICAS (WARNING): Autoscaler recommends a size greater than maxNumReplicas. - CUSTOM_METRIC_DATA_POINTS_TOO_SPARSE (WARNING): The custom metric samples are not exported often enough to be a credible base for autoscaling. - CUSTOM_METRIC_INVALID (ERROR): The custom metric that was specified does not exist or does not have the necessary labels. - MIN_EQUALS_MAX (WARNING): The minNumReplicas is equal to maxNumReplicas. This means the autoscaler cannot add or remove instances from the instance group. - MISSING_CUSTOM_METRIC_DATA_POINTS (WARNING): The autoscaler did not receive any data from the custom metric configured for autoscaling. - MISSING_LOAD_BALANCING_DATA_POINTS (WARNING): The autoscaler is configured to scale based on a load balancing signal but the instance group has not received any requests from the load balancer. - MODE_OFF (WARNING): Autoscaling is turned off. The number of instances in the group won't change automatically. The autoscaling configuration is preserved. - MODE_ONLY_UP (WARNING): Autoscaling is in the \"Autoscale only out\" mode. The autoscaler can add instances but not remove any. - MORE_THAN_ONE_BACKEND_SERVICE (ERROR): The instance group cannot be autoscaled because it has more than one backend service attached to it. - NOT_ENOUGH_QUOTA_AVAILABLE (ERROR): There is insufficient quota for the necessary resources, such as CPU or number of instances. - REGION_RESOURCE_STOCKOUT (ERROR): Shown only for regional autoscalers: there is a resource stockout in the chosen region. - SCALING_TARGET_DOES_NOT_EXIST (ERROR): The target to be scaled does not exist. - UNSUPPORTED_MAX_RATE_LOAD_BALANCING_CONFIGURATION (ERROR): Autoscaling does not work with an HTTP/S load balancer that has been configured for maxRate. - ZONE_RESOURCE_STOCKOUT (ERROR): For zonal autoscalers: there is a resource stockout in the chosen zone. For regional autoscalers: in at least one of the zones you're using there is a resource stockout. New values might be added in the future. Some of the values might not be available in all API versions.",
            "enum": [
              "ALL_INSTANCES_UNHEALTHY",
              "BACKEND_SERVICE_DOES_NOT_EXIST",
              "CAPPED_AT_MAX_NUM_REPLICAS",
              "CUSTOM_METRIC_DATA_POINTS_TOO_SPARSE",
              "CUSTOM_METRIC_INVALID",
              "MIN_EQUALS_MAX",
              "MISSING_CUSTOM_METRIC_DATA_POINTS",
              "MISSING_LOAD_BALANCING_DATA_POINTS",
              "MODE_OFF",
              "MODE_ONLY_SCALE_OUT",
              "MODE_ONLY_UP",
              "MORE_THAN_ONE_BACKEND_SERVICE",
              "NOT_ENOUGH_QUOTA_AVAILABLE",
              "REGION_RESOURCE_STOCKOUT",
              "SCALING_TARGET_DOES_NOT_EXIST",
              "SCHEDULED_INSTANCES_GREATER_THAN_AUTOSCALER_MAX",
              "SCHEDULED_INSTANCES_LESS_THAN_AUTOSCALER_MIN",
              "UNKNOWN",
              "UNSUPPORTED_MAX_RATE_LOAD_BALANCING_CONFIGURATION",
              "ZONE_RESOURCE_STOCKOUT"
            ],
            "type": "string"
          }
        },
        "type": "object"
      }
    }
  },
  "handler": "http",
  "request": {
    "method": "PATCH",
    "url": {
      "$uri": "https://compute.googleapis.com/compute/beta/projects/{project}/regions/{region}/autoscalers{?autoscaler,requestId,$.xgafv,access_token,alt,callback,fields,key,oauth_token,prettyPrint,quotaUser,upload_protocol,uploadType,userIp}"
    },
    "body": {
      "$": "body",
      "encode": "json"
    }
  },
  "responses": {
    "200": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "Represents an Operation resource. Google Compute Engine has three Operation resources: * [Global](/compute/docs/reference/rest/beta/globalOperations) * [Regional](/compute/docs/reference/rest/beta/regionOperations) * [Zonal](/compute/docs/reference/rest/beta/zoneOperations) You can use an operation resource to manage asynchronous API requests. For more information, read Handling API responses. Operations can be global, regional or zonal. - For global operations, use the `globalOperations` resource. - For regional operations, use the `regionOperations` resource. - For zonal operations, use the `zoneOperations` resource. For more information, read Global, Regional, and Zonal Resources. Note that completed Operation resources have a limited retention period.",
        "**Key properties:**",
        {
          "$ul": [
            "**clientOperationId**: [Output Only] The value of `requestId` if you provided it in the request. Not present otherwise.",
            "**creationTimestamp**: [Deprecated] This field is deprecated.",
            "**description**: [Output Only] A textual description of the operation, which is set when the operation is created.",
            "**endTime**: [Output Only] The time that this operation was completed. This value is in RFC3339 text format.",
            [
              "**error**: [Output Only] If errors are generated during processing of the operation, this field will be populated.",
              {
                "$ul": [
                  "**errors**: [Output Only] The array of errors encountered while processing this operation."
                ]
              }
            ],
            "**httpErrorMessage**: [Output Only] If the operation fails, this field contains the HTTP error message that was returned, such as `NOT FOUND`.",
            "**httpErrorStatusCode**: [Output Only] If the operation fails, this field contains the HTTP error status code that was returned. For example, a `404` means the resource was not found.",
            "**id**: [Output Only] The unique identifier for the operation. This identifier is defined by the server.",
            "**insertTime**: [Output Only] The time that this operation was requested. This value is in RFC3339 text format.",
            [
              "**instancesBulkInsertOperationMetadata**",
              {
                "$ul": [
                  "**perLocationStatus**: Status information per location (location name is key). Example key: zones/us-central1-a"
                ]
              }
            ],
            "**kind**: [Output Only] Type of the resource. Always `compute#operation` for Operation resources. (default: compute#operation)",
            "**name**: [Output Only] Name of the operation.",
            "**operationGroupId**: [Output Only] An ID that represents a group of operations, such as when a group of operations results from a `bulkInsert` API request.",
            "**operationType**: [Output Only] The type of operation, such as `insert`, `update`, or `delete`, and so on.",
            "**progress**: [Output Only] An optional progress indicator that ranges from 0 to 100. There is no requirement that this be linear or support any granularity of operations. This should not be used to guess when the operation will be complete. This number should monotonically increase as the operation progresses.",
            "**region**: [Output Only] The URL of the region where the operation resides. Only applicable when performing regional operations.",
            "**selfLink**: [Output Only] Server-defined URL for the resource.",
            [
              "**setCommonInstanceMetadataOperationMetadata**",
              {
                "$ul": [
                  "**clientOperationId**: [Output Only] The client operation id.",
                  "**perLocationOperations**: [Output Only] Status information per location (location name is key). Example key: zones/us-central1-a"
                ]
              }
            ],
            "**startTime**: [Output Only] The time that this operation was started by the server. This value is in RFC3339 text format.",
            "**status**: [Output Only] The status of the operation, which can be one of the following: `PENDING`, `RUNNING`, or `DONE`.",
            "**statusMessage**: [Output Only] An optional textual description of the current status of the operation.",
            "**targetId**: [Output Only] The unique target ID, which identifies a specific incarnation of the target resource.",
            "**targetLink**: [Output Only] The URL of the resource that the operation modifies. For operations related to creating a snapshot, this points to the persistent disk that the snapshot was created from.",
            "**user**: [Output Only] User who requested the operation, for example: `user@example.com` or `alice_smith_identifier (global/workforcePools/example-com-us-employees)`.",
            "**warnings**: [Output Only] If warning messages are generated during processing of the operation, this field will be populated.",
            "**zone**: [Output Only] The URL of the zone where the operation resides. Only applicable when performing per-zone operations."
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    }
  }
}
