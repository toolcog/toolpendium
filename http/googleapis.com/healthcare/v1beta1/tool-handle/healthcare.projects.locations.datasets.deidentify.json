{
  "name": "healthcare_projects_locations_datasets_deidentify",
  "description": "Creates a new dataset containing de-identified data from the source dataset. The metadata field type is OperationMetadata. If the request is successful, the response field type is DeidentifySummary. The LRO result may still be successful if de-identification fails for some resources. The new de-identified dataset will not contain these failed resources. The number of resources processed are tracked in Operation.metadata. Error details are logged to Cloud Logging. For more information, see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging).",
  "parameters": {
    "type": "object",
    "properties": {
      "sourceDataset": {
        "type": "string",
        "description": "Required. Source dataset resource name. For example, `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}`."
      },
      "$.xgafv": {
        "enum": [
          "1",
          "2"
        ],
        "type": "string",
        "description": "V1 error format."
      },
      "access_token": {
        "type": "string",
        "description": "OAuth access token."
      },
      "alt": {
        "enum": [
          "json",
          "media",
          "proto"
        ],
        "type": "string",
        "description": "Data format for response."
      },
      "callback": {
        "type": "string",
        "description": "JSONP"
      },
      "fields": {
        "type": "string",
        "description": "Selector specifying which fields to include in a partial response."
      },
      "key": {
        "type": "string",
        "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
      },
      "oauth_token": {
        "type": "string",
        "description": "OAuth 2.0 token for the current user."
      },
      "prettyPrint": {
        "type": "boolean",
        "description": "Returns response with indentations and line breaks."
      },
      "quotaUser": {
        "type": "string",
        "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
      },
      "upload_protocol": {
        "type": "string",
        "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
      },
      "uploadType": {
        "type": "string",
        "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
      },
      "body": {
        "$ref": "#/$defs/DeidentifyDatasetRequest"
      }
    },
    "required": [
      "sourceDataset"
    ],
    "$defs": {
      "DeidentifyDatasetRequest": {
        "description": "Redacts identifying information from the specified dataset.",
        "properties": {
          "config": {
            "$ref": "#/$defs/DeidentifyConfig"
          },
          "destinationDataset": {
            "description": "Required. The name of the dataset resource to create and write the redacted data to. * The destination dataset must not exist. * The destination dataset must be in the same location as the source dataset. De-identifying data across multiple locations is not supported.",
            "type": "string"
          },
          "gcsConfigUri": {
            "description": "Cloud Storage location to read the JSON cloud.healthcare.deidentify.DeidentifyConfig from, overriding the default config. Must be of the form `gs://{bucket_id}/path/to/object`. The Cloud Storage location must grant the Cloud IAM role `roles/storage.objectViewer` to the project's Cloud Healthcare Service Agent service account. Only one of `config` and `gcs_config_uri` can be specified.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "DeidentifyConfig": {
        "description": "Configures de-id options specific to different types of content. Each submessage customizes the handling of an https://tools.ietf.org/html/rfc6838 media type or subtype. Configs are applied in a nested manner at runtime.",
        "properties": {
          "annotation": {
            "$ref": "#/$defs/AnnotationConfig"
          },
          "dicom": {
            "$ref": "#/$defs/DicomConfig"
          },
          "dicomTagConfig": {
            "$ref": "#/$defs/DicomTagConfig"
          },
          "fhir": {
            "$ref": "#/$defs/FhirConfig"
          },
          "fhirFieldConfig": {
            "$ref": "#/$defs/FhirFieldConfig"
          },
          "image": {
            "$ref": "#/$defs/ImageConfig"
          },
          "operationMetadata": {
            "$ref": "#/$defs/DeidentifyOperationMetadata"
          },
          "text": {
            "$ref": "#/$defs/TextConfig"
          },
          "useRegionalDataProcessing": {
            "description": "Ensures in-flight data remains in the region of origin during de-identification. Using this option results in a significant reduction of throughput, and is not compatible with `LOCATION` or `ORGANIZATION_NAME` infoTypes. If the deprecated DicomConfig or FhirConfig are used, then `LOCATION` must be excluded within TextConfig, and must also be excluded within ImageConfig if image redaction is required.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "AnnotationConfig": {
        "description": "Specifies how to store annotations during de-identification operation.",
        "properties": {
          "annotationStoreName": {
            "description": "The name of the annotation store, in the form `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/annotationStores/{annotation_store_id}`). * The destination annotation store must be in the same project as the source data. De-identifying data across multiple projects is not supported. * The destination annotation store must exist when using DeidentifyDicomStore or DeidentifyFhirStore. DeidentifyDataset automatically creates the destination annotation store.",
            "type": "string"
          },
          "storeQuote": {
            "description": "If set to true, the sensitive texts are included in SensitiveTextAnnotation of Annotation.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "DicomConfig": {
        "description": "Specifies the parameters needed for de-identification of DICOM stores.",
        "properties": {
          "filterProfile": {
            "description": "Tag filtering profile that determines which tags to keep/remove.",
            "enum": [
              "TAG_FILTER_PROFILE_UNSPECIFIED",
              "MINIMAL_KEEP_LIST_PROFILE",
              "ATTRIBUTE_CONFIDENTIALITY_BASIC_PROFILE",
              "KEEP_ALL_PROFILE",
              "DEIDENTIFY_TAG_CONTENTS"
            ],
            "type": "string"
          },
          "keepList": {
            "$ref": "#/$defs/TagFilterList"
          },
          "removeList": {
            "$ref": "#/$defs/TagFilterList"
          },
          "skipIdRedaction": {
            "description": "If true, skip replacing StudyInstanceUID, SeriesInstanceUID, SOPInstanceUID, and MediaStorageSOPInstanceUID and leave them untouched. The Cloud Healthcare API regenerates these UIDs by default based on the DICOM Standard's reasoning: \"Whilst these UIDs cannot be mapped directly to an individual out of context, given access to the original images, or to a database of the original images containing the UIDs, it would be possible to recover the individual's identity.\" http://dicom.nema.org/medical/dicom/current/output/chtml/part15/sect_E.3.9.html",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "TagFilterList": {
        "description": "List of tags to be filtered.",
        "properties": {
          "tags": {
            "description": "Tags to be filtered. Tags must be DICOM Data Elements, File Meta Elements, or Directory Structuring Elements, as defined at: http://dicom.nema.org/medical/dicom/current/output/html/part06.html#table_6-1,. They may be provided by \"Keyword\" or \"Tag\". For example, \"PatientID\", \"00100010\".",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "DicomTagConfig": {
        "description": "Specifies the parameters needed for the de-identification of DICOM stores.",
        "properties": {
          "actions": {
            "description": "Specifies custom tag selections and `Actions` to apply to them. Overrides `options` and `profile`. Conflicting `Actions` are applied in the order given.",
            "items": {
              "$ref": "#/$defs/Action"
            },
            "type": "array"
          },
          "options": {
            "$ref": "#/$defs/Options"
          },
          "profileType": {
            "description": "Base profile type for handling DICOM tags.",
            "enum": [
              "PROFILE_TYPE_UNSPECIFIED",
              "MINIMAL_KEEP_LIST_PROFILE",
              "ATTRIBUTE_CONFIDENTIALITY_BASIC_PROFILE",
              "KEEP_ALL_PROFILE",
              "DEIDENTIFY_TAG_CONTENTS"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "Action": {
        "description": "Specifies a selection of tags and an `Action` to apply to each one.",
        "properties": {
          "cleanImageTag": {
            "$ref": "#/$defs/ImageConfig"
          },
          "cleanTextTag": {
            "$ref": "#/$defs/CleanTextTag"
          },
          "deleteTag": {
            "$ref": "#/$defs/DeleteTag"
          },
          "keepTag": {
            "$ref": "#/$defs/KeepTag"
          },
          "queries": {
            "description": "Select all tags with the listed tag IDs, names, or Value Representations (VRs). Examples: ID: \"00100010\" Keyword: \"PatientName\" VR: \"PN\"",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "recurseTag": {
            "$ref": "#/$defs/RecurseTag"
          },
          "regenUidTag": {
            "$ref": "#/$defs/RegenUidTag"
          },
          "removeTag": {
            "$ref": "#/$defs/RemoveTag"
          },
          "resetTag": {
            "$ref": "#/$defs/ResetTag"
          }
        },
        "type": "object"
      },
      "ImageConfig": {
        "description": "Specifies how to handle de-identification of image pixels.",
        "properties": {
          "additionalInfoTypes": {
            "description": "Additional InfoTypes to redact in the images in addition to those used by `text_redaction_mode`. Can only be used when `text_redaction_mode` is set to `REDACT_SENSITIVE_TEXT`, `REDACT_SENSITIVE_TEXT_CLEAN_DESCRIPTORS` or `TEXT_REDACTION_MODE_UNSPECIFIED`.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "excludeInfoTypes": {
            "description": "InfoTypes to skip redacting, overriding those used by `text_redaction_mode`. Can only be used when `text_redaction_mode` is set to `REDACT_SENSITIVE_TEXT` or `REDACT_SENSITIVE_TEXT_CLEAN_DESCRIPTORS`.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "textRedactionMode": {
            "description": "Determines how to redact text from image.",
            "enum": [
              "TEXT_REDACTION_MODE_UNSPECIFIED",
              "REDACT_ALL_TEXT",
              "REDACT_SENSITIVE_TEXT",
              "REDACT_NO_TEXT",
              "REDACT_SENSITIVE_TEXT_CLEAN_DESCRIPTORS"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "CleanTextTag": {
        "description": "Inspect text and transform sensitive text. Configurable using TextConfig. Supported [Value Representations] (http://dicom.nema.org/medical/dicom/2018e/output/chtml/part05/sect_6.2.html#table_6.2-1): AE, LO, LT, PN, SH, ST, UC, UT, DA, DT, AS",
        "properties": {},
        "type": "object"
      },
      "DeleteTag": {
        "description": "Delete tag.",
        "properties": {},
        "type": "object"
      },
      "KeepTag": {
        "description": "Keep tag unchanged.",
        "properties": {},
        "type": "object"
      },
      "RecurseTag": {
        "description": "Recursively apply DICOM de-id to tags nested in a sequence. Supported [Value Representation] (http://dicom.nema.org/medical/dicom/2018e/output/chtml/part05/sect_6.2.html#table_6.2-1): SQ",
        "properties": {},
        "type": "object"
      },
      "RegenUidTag": {
        "description": "Replace UID with a new generated UID. Supported [Value Representation] (http://dicom.nema.org/medical/dicom/2018e/output/chtml/part05/sect_6.2.html#table_6.2-1): UI",
        "properties": {},
        "type": "object"
      },
      "RemoveTag": {
        "description": "Replace with empty tag.",
        "properties": {},
        "type": "object"
      },
      "ResetTag": {
        "description": "Reset tag to a placeholder value.",
        "properties": {},
        "type": "object"
      },
      "Options": {
        "description": "Specifies additional options to apply to the base profile.",
        "properties": {
          "cleanDescriptors": {
            "$ref": "#/$defs/CleanDescriptorsOption"
          },
          "cleanImage": {
            "$ref": "#/$defs/ImageConfig"
          },
          "primaryIds": {
            "description": "Set `Action` for [`StudyInstanceUID`, `SeriesInstanceUID`, `SOPInstanceUID`, and `MediaStorageSOPInstanceUID`](http://dicom.nema.org/medical/dicom/2018e/output/chtml/part06/chapter_6.html).",
            "enum": [
              "PRIMARY_IDS_OPTION_UNSPECIFIED",
              "KEEP",
              "REGEN"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "CleanDescriptorsOption": {
        "description": "This option is based on the DICOM Standard's [Clean Descriptors Option](http://dicom.nema.org/medical/dicom/2018e/output/chtml/part15/sect_E.3.5.html), and the `CleanText` `Action` is applied to all the specified fields. When cleaning text, the process attempts to transform phrases matching any of the tags marked for removal (action codes D, Z, X, and U) in the [Basic Profile](http://dicom.nema.org/medical/dicom/2018e/output/chtml/part15/chapter_E.html). These contextual phrases are replaced with the token \"[CTX]\". This option uses an additional infoType during inspection.",
        "properties": {},
        "type": "object"
      },
      "FhirConfig": {
        "description": "Specifies how to handle de-identification of a FHIR store.",
        "properties": {
          "defaultKeepExtensions": {
            "description": "The behaviour for handling FHIR extensions that aren't otherwise specified for de-identification. If true, all extensions are preserved during de-identification by default. If false or unspecified, all extensions are removed during de-identification by default.",
            "type": "boolean"
          },
          "fieldMetadataList": {
            "description": "Specifies FHIR paths to match and how to transform them. Any field that is not matched by a FieldMetadata is passed through to the output dataset unmodified. All extensions will be processed according to `default_keep_extensions`. If a field can be matched by more than one FieldMetadata, the first FieldMetadata.Action is applied.",
            "items": {
              "$ref": "#/$defs/FieldMetadata"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "FieldMetadata": {
        "description": "Specifies FHIR paths to match, and how to handle de-identification of matching fields.",
        "properties": {
          "action": {
            "description": "Deidentify action for one field.",
            "enum": [
              "ACTION_UNSPECIFIED",
              "TRANSFORM",
              "INSPECT_AND_TRANSFORM",
              "DO_NOT_TRANSFORM"
            ],
            "type": "string"
          },
          "paths": {
            "description": "List of paths to FHIR fields to redact. Each path is a period-separated list where each component is either a field name or FHIR type name. All types begin with an upper case letter. For example, the resource field \"Patient.Address.city\", which uses a string type, can be matched by \"Patient.Address.String\". Path also supports partial matching. For example, \"Patient.Address.city\" can be matched by \"Address.city\" (Patient omitted). Partial matching and type matching can be combined. For example, \"Patient.Address.city\" can be matched by \"Address.String\". For \"choice\" types (those defined in the FHIR spec with the form: field[x]), use two separate components. For example, \"deceasedAge.unit\" is matched by \"Deceased.Age.unit\". Supported types are: AdministrativeGenderCode, Base64Binary, Boolean, Code, Date, DateTime, Decimal, HumanName, Id, Instant, Integer, LanguageCode, Markdown, Oid, PositiveInt, String, UnsignedInt, Uri, Uuid, Xhtml. The sub-type for HumanName(for example HumanName.given, HumanName.family) can be omitted.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "FhirFieldConfig": {
        "description": "Specifies how to handle the de-identification of a FHIR store.",
        "properties": {
          "fieldMetadataList": {
            "description": "Specifies FHIR paths to match and how to transform them. Any field that is not matched by a FieldMetadata `action` is passed through to the output dataset unmodified. All extensions will be processed according to keep_extensions. If a field can be matched by more than one FieldMetadata `action`, the first `action` option is applied. Overrides options and the union field `profile` in FhirFieldConfig.",
            "items": {
              "$ref": "#/$defs/GoogleCloudHealthcareV1beta1DeidentifyFieldMetadata"
            },
            "type": "array"
          },
          "options": {
            "$ref": "#/$defs/GoogleCloudHealthcareV1beta1DeidentifyOptions"
          },
          "profileType": {
            "description": "Base profile type for handling FHIR fields.",
            "enum": [
              "PROFILE_TYPE_UNSPECIFIED",
              "KEEP_ALL",
              "BASIC",
              "CLEAN_ALL"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "GoogleCloudHealthcareV1beta1DeidentifyFieldMetadata": {
        "description": "Specifies the FHIR paths to match and how to handle the de-identification of matching fields.",
        "properties": {
          "characterMaskField": {
            "$ref": "#/$defs/CharacterMaskField"
          },
          "cleanTextField": {
            "$ref": "#/$defs/CleanTextField"
          },
          "cryptoHashField": {
            "$ref": "#/$defs/CryptoHashField"
          },
          "dateShiftField": {
            "$ref": "#/$defs/DateShiftField"
          },
          "keepField": {
            "$ref": "#/$defs/KeepField"
          },
          "paths": {
            "description": "List of paths to FHIR fields to redact. Each path is a period-separated list where each component is either a field name or FHIR [type](https://www.hl7.org/fhir/datatypes.html) name. All types begin with an upper case letter. For example, the resource field `Patient.Address.city`, which uses a [string](https://www.hl7.org/fhir/datatypes-definitions.html#Address.city) type, can be matched by `Patient.Address.String`. Partial matching is supported. For example, `Patient.Address.city` can be matched by `Address.city` (with `Patient` omitted). Partial matching and type matching can be combined, for example `Patient.Address.city` can be matched by `Address.String`. For \"choice\" types (those defined in the FHIR spec with the format `field[x]`), use two separate components. For example, `deceasedAge.unit` is matched by `Deceased.Age.unit`. The following types are supported: AdministrativeGenderCode, Base64Binary, Boolean, Code, Date, DateTime, Decimal, HumanName, Id, Instant, Integer, LanguageCode, Markdown, Oid, PositiveInt, String, UnsignedInt, Uri, Uuid, Xhtml. The sub-type for HumanName (for example `HumanName.given`, `HumanName.family`) can be omitted.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "removeField": {
            "$ref": "#/$defs/RemoveField"
          }
        },
        "type": "object"
      },
      "CharacterMaskField": {
        "description": "Replace field value with masking character. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml.",
        "properties": {},
        "type": "object"
      },
      "CleanTextField": {
        "description": "Inspect text and transform sensitive text. Configure using TextConfig. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Date, DateTime, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml.",
        "properties": {},
        "type": "object"
      },
      "CryptoHashField": {
        "description": "Replace field value with a hash of that value. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml.",
        "properties": {},
        "type": "object"
      },
      "DateShiftField": {
        "description": "Shift the date by a randomized number of days. See [date shifting](https://cloud.google.com/dlp/docs/concepts-date-shifting) for more information. Supported [types](https://www.hl7.org/fhir/datatypes.html): Date, DateTime.",
        "properties": {},
        "type": "object"
      },
      "KeepField": {
        "description": "Keep field unchanged.",
        "properties": {},
        "type": "object"
      },
      "RemoveField": {
        "description": "Remove field.",
        "properties": {},
        "type": "object"
      },
      "GoogleCloudHealthcareV1beta1DeidentifyOptions": {
        "description": "Specifies additional options to apply to the base ProfileType.",
        "properties": {
          "characterMaskConfig": {
            "$ref": "#/$defs/CharacterMaskConfig"
          },
          "contextualDeid": {
            "$ref": "#/$defs/ContextualDeidConfig"
          },
          "cryptoHashConfig": {
            "$ref": "#/$defs/CryptoHashConfig"
          },
          "dateShiftConfig": {
            "$ref": "#/$defs/DateShiftConfig"
          },
          "keepExtensions": {
            "$ref": "#/$defs/KeepExtensionsConfig"
          }
        },
        "type": "object"
      },
      "CharacterMaskConfig": {
        "description": "Mask a string by replacing its characters with a fixed character.",
        "properties": {
          "maskingCharacter": {
            "description": "Character to mask the sensitive values. If not supplied, defaults to \"*\".",
            "type": "string"
          }
        },
        "type": "object"
      },
      "ContextualDeidConfig": {
        "description": "Fields that don't match a KeepField or CleanTextField `action` in the BASIC profile are collected into a contextual phrase list. For fields that match a CleanTextField `action` in FieldMetadata or ProfileType, the process attempts to transform phrases matching these contextual entries. These contextual phrases are replaced with the token \"[CTX]\". This feature uses an additional InfoType during inspection.",
        "properties": {},
        "type": "object"
      },
      "CryptoHashConfig": {
        "description": "Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. Outputs a base64-encoded representation of the hashed output. For example, `L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=`.",
        "properties": {
          "cryptoKey": {
            "description": "An AES 128/192/256 bit key. Causes the hash to be computed based on this key. A default key is generated for each Deidentify operation and is used when neither crypto_key nor kms_wrapped is specified. Must not be set if kms_wrapped is set.",
            "format": "byte",
            "type": "string"
          },
          "kmsWrapped": {
            "$ref": "#/$defs/KmsWrappedCryptoKey"
          }
        },
        "type": "object"
      },
      "KmsWrappedCryptoKey": {
        "description": "Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. The key must grant the Cloud IAM permission `cloudkms.cryptoKeyVersions.useToDecrypt` to the project's Cloud Healthcare Service Agent service account. For more information, see [Creating a wrapped key] (https://cloud.google.com/dlp/docs/create-wrapped-key).",
        "properties": {
          "cryptoKey": {
            "description": "Required. The resource name of the KMS CryptoKey to use for unwrapping. For example, `projects/{project_id}/locations/{location_id}/keyRings/{keyring}/cryptoKeys/{key}`.",
            "type": "string"
          },
          "wrappedKey": {
            "description": "Required. The wrapped data crypto key.",
            "format": "byte",
            "type": "string"
          }
        },
        "type": "object"
      },
      "DateShiftConfig": {
        "description": "Shift a date forward or backward in time by a random amount which is consistent for a given patient and crypto key combination.",
        "properties": {
          "cryptoKey": {
            "description": "An AES 128/192/256 bit key. The date shift is computed based on this key and the patient ID. If the patient ID is empty for a DICOM resource, the date shift is computed based on this key and the study instance UID. If crypto_key is not set, then kms_wrapped is used to calculate the date shift. If neither is set, a default key is generated for each de-identify operation. Must not be set if kms_wrapped is set.",
            "format": "byte",
            "type": "string"
          },
          "kmsWrapped": {
            "$ref": "#/$defs/KmsWrappedCryptoKey"
          }
        },
        "type": "object"
      },
      "KeepExtensionsConfig": {
        "description": "The behavior for handling FHIR extensions that aren't otherwise specified for de-identification. If provided, all extensions are preserved during de-identification by default. If unspecified, all extensions are removed during de-identification by default.",
        "properties": {},
        "type": "object"
      },
      "DeidentifyOperationMetadata": {
        "description": "Details about the work the de-identify operation performed.",
        "properties": {
          "fhirOutput": {
            "$ref": "#/$defs/FhirOutput"
          }
        },
        "type": "object"
      },
      "FhirOutput": {
        "description": "Details about the FHIR store to write the output to.",
        "properties": {
          "fhirStore": {
            "description": "Name of the output FHIR store, which must already exist. You must grant the healthcare.fhirResources.update permission on the destination store to your project's **Cloud Healthcare Service Agent** [service account](https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#the_cloud_healthcare_service_agent). The destination store must set enableUpdateCreate to true. The destination store must use FHIR version R4. Writing these resources will consume FHIR operations quota from the project containing the source data. De-identify operation metadata is only generated for DICOM de-identification operations.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "TextConfig": {
        "description": "Configures how to transform sensitive text `InfoTypes`.",
        "properties": {
          "additionalTransformations": {
            "description": "Additional transformations to apply to the detected data, overriding `profile`.",
            "items": {
              "$ref": "#/$defs/InfoTypeTransformation"
            },
            "type": "array"
          },
          "excludeInfoTypes": {
            "description": "InfoTypes to skip transforming, overriding `profile`.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "profileType": {
            "description": "Base profile type for text transformation.",
            "enum": [
              "PROFILE_TYPE_UNSPECIFIED",
              "EMPTY",
              "BASIC"
            ],
            "type": "string"
          },
          "transformations": {
            "deprecated": true,
            "description": "The transformations to apply to the detected data. Deprecated. Use `additional_transformations` instead.",
            "items": {
              "$ref": "#/$defs/InfoTypeTransformation"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "InfoTypeTransformation": {
        "description": "A transformation to apply to text that is identified as a specific info_type.",
        "properties": {
          "characterMaskConfig": {
            "$ref": "#/$defs/CharacterMaskConfig"
          },
          "cryptoHashConfig": {
            "$ref": "#/$defs/CryptoHashConfig"
          },
          "dateShiftConfig": {
            "$ref": "#/$defs/DateShiftConfig"
          },
          "infoTypes": {
            "description": "`InfoTypes` to apply this transformation to. If this is not specified, this transformation becomes the default transformation, and is used for any `info_type` that is not specified in another transformation.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "redactConfig": {
            "$ref": "#/$defs/RedactConfig"
          },
          "replaceWithInfoTypeConfig": {
            "$ref": "#/$defs/ReplaceWithInfoTypeConfig"
          }
        },
        "type": "object"
      },
      "RedactConfig": {
        "description": "Define how to redact sensitive values. Default behaviour is erase. For example, \"My name is Jane.\" becomes \"My name is .\"",
        "properties": {},
        "type": "object"
      },
      "ReplaceWithInfoTypeConfig": {
        "description": "When using the INSPECT_AND_TRANSFORM action, each match is replaced with the name of the info_type. For example, \"My name is Jane\" becomes \"My name is [PERSON_NAME].\" The TRANSFORM action is equivalent to redacting.",
        "properties": {},
        "type": "object"
      }
    }
  },
  "handler": "http",
  "request": {
    "method": "POST",
    "url": {
      "$uri": "https://healthcare.googleapis.com//v1beta1/{sourceDataset}:deidentify{?$.xgafv,access_token,alt,callback,fields,key,oauth_token,prettyPrint,quotaUser,upload_protocol,uploadType}"
    },
    "body": {
      "$": "body",
      "encode": "json"
    }
  },
  "responses": {
    "200": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "This resource represents a long-running operation that is the result of a network API call.",
        "**Key properties:**",
        {
          "$ul": [
            "**done**: If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.",
            [
              "**error**: The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).",
              {
                "$ul": [
                  "**code**: The status code, which should be an enum value of google.rpc.Code.",
                  "**details**: A list of messages that carry the error details. There is a common set of message types for APIs to use.",
                  "**message**: A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client."
                ]
              }
            ],
            "**metadata**: Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.",
            "**name**: The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.",
            "**response**: The normal, successful response of the operation. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`."
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    }
  }
}
