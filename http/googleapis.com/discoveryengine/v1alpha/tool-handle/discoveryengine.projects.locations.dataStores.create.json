{
  "name": "discoveryengine_projects_locations_dataStores_create",
  "description": "Creates a DataStore. DataStore is for storing Documents. To serve these documents for Search, or Recommendation use case, an Engine needs to be created separately.",
  "parameters": {
    "type": "object",
    "properties": {
      "parent": {
        "type": "string",
        "description": "Required. The parent resource name, such as `projects/{project}/locations/{location}/collections/{collection}`."
      },
      "createAdvancedSiteSearch": {
        "type": "boolean",
        "description": "A boolean flag indicating whether user want to directly create an advanced data store for site search. If the data store is not configured as site search (GENERIC vertical and PUBLIC_WEBSITE content_config), this flag will be ignored."
      },
      "dataStoreId": {
        "type": "string",
        "description": "Required. The ID to use for the DataStore, which will become the final component of the DataStore's resource name. This field must conform to [RFC-1034](https://tools.ietf.org/html/rfc1034) standard with a length limit of 63 characters. Otherwise, an INVALID_ARGUMENT error is returned."
      },
      "$.xgafv": {
        "enum": [
          "1",
          "2"
        ],
        "type": "string",
        "description": "V1 error format."
      },
      "access_token": {
        "type": "string",
        "description": "OAuth access token."
      },
      "alt": {
        "enum": [
          "json",
          "media",
          "proto"
        ],
        "type": "string",
        "description": "Data format for response."
      },
      "callback": {
        "type": "string",
        "description": "JSONP"
      },
      "fields": {
        "type": "string",
        "description": "Selector specifying which fields to include in a partial response."
      },
      "key": {
        "type": "string",
        "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
      },
      "oauth_token": {
        "type": "string",
        "description": "OAuth 2.0 token for the current user."
      },
      "prettyPrint": {
        "type": "boolean",
        "description": "Returns response with indentations and line breaks."
      },
      "quotaUser": {
        "type": "string",
        "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
      },
      "upload_protocol": {
        "type": "string",
        "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
      },
      "uploadType": {
        "type": "string",
        "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
      },
      "body": {
        "$ref": "#/$defs/GoogleCloudDiscoveryengineV1alphaDataStore"
      }
    },
    "required": [
      "parent"
    ],
    "$defs": {
      "GoogleCloudDiscoveryengineV1alphaDataStore": {
        "description": "DataStore captures global settings and configs at the DataStore level.",
        "properties": {
          "aclEnabled": {
            "description": "Immutable. Whether data in the DataStore has ACL information. If set to `true`, the source data must have ACL. ACL will be ingested when data is ingested by DocumentService.ImportDocuments methods. When ACL is enabled for the DataStore, Document can't be accessed by calling DocumentService.GetDocument or DocumentService.ListDocuments. Currently ACL is only supported in `GENERIC` industry vertical with non-`PUBLIC_WEBSITE` content config.",
            "type": "boolean"
          },
          "contentConfig": {
            "description": "Immutable. The content config of the data store. If this field is unset, the server behavior defaults to ContentConfig.NO_CONTENT.",
            "enum": [
              "CONTENT_CONFIG_UNSPECIFIED",
              "NO_CONTENT",
              "CONTENT_REQUIRED",
              "PUBLIC_WEBSITE"
            ],
            "type": "string"
          },
          "createTime": {
            "description": "Output only. Timestamp the DataStore was created at.",
            "format": "google-datetime",
            "readOnly": true,
            "type": "string"
          },
          "defaultSchemaId": {
            "description": "Output only. The id of the default Schema asscociated to this data store.",
            "readOnly": true,
            "type": "string"
          },
          "displayName": {
            "description": "Required. The data store display name. This field must be a UTF-8 encoded string with a length limit of 128 characters. Otherwise, an INVALID_ARGUMENT error is returned.",
            "type": "string"
          },
          "documentProcessingConfig": {
            "$ref": "#/$defs/GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfig"
          },
          "idpConfig": {
            "$ref": "#/$defs/GoogleCloudDiscoveryengineV1alphaIdpConfig"
          },
          "industryVertical": {
            "description": "Immutable. The industry vertical that the data store registers.",
            "enum": [
              "INDUSTRY_VERTICAL_UNSPECIFIED",
              "GENERIC",
              "MEDIA"
            ],
            "type": "string"
          },
          "name": {
            "description": "Immutable. The full resource name of the data store. Format: `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`. This field must be a UTF-8 encoded string with a length limit of 1024 characters.",
            "type": "string"
          },
          "solutionTypes": {
            "description": "The solutions that the data store enrolls. Available solutions for each industry_vertical: * `MEDIA`: `SOLUTION_TYPE_RECOMMENDATION` and `SOLUTION_TYPE_SEARCH`. * `SITE_SEARCH`: `SOLUTION_TYPE_SEARCH` is automatically enrolled. Other solutions cannot be enrolled.",
            "items": {
              "enum": [
                "SOLUTION_TYPE_UNSPECIFIED",
                "SOLUTION_TYPE_RECOMMENDATION",
                "SOLUTION_TYPE_SEARCH",
                "SOLUTION_TYPE_CHAT"
              ],
              "type": "string"
            },
            "type": "array"
          },
          "startingSchema": {
            "$ref": "#/$defs/GoogleCloudDiscoveryengineV1alphaSchema"
          }
        },
        "type": "object"
      },
      "GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfig": {
        "description": "A singleton resource of DataStore. It's empty when DataStore is created, which defaults to digital parser. The first call to DataStoreService.UpdateDocumentProcessingConfig method will initialize the config.",
        "properties": {
          "defaultParsingConfig": {
            "$ref": "#/$defs/GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfigParsingConfig"
          },
          "name": {
            "description": "The full resource name of the Document Processing Config. Format: `projects/*/locations/*/collections/*/dataStores/*/documentProcessingConfig`.",
            "type": "string"
          },
          "ocrConfig": {
            "$ref": "#/$defs/GoogleCloudDiscoveryengineV1alphaOcrConfig"
          },
          "parsingConfigOverrides": {
            "additionalProperties": {
              "$ref": "#/$defs/GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfigParsingConfig"
            },
            "description": "Map from file type to override the default parsing configuration based on the file type. Supported keys: * `pdf`: Override parsing config for PDF files, either digital parsing, ocr parsing or layout parsing is supported. * `html`: Override parsing config for HTML files, only digital parsing and or layout parsing are supported. * `docx`: Override parsing config for DOCX files, only digital parsing and or layout parsing are supported.",
            "type": "object"
          }
        },
        "type": "object"
      },
      "GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfigParsingConfig": {
        "description": "Related configurations applied to a specific type of document parser.",
        "properties": {
          "digitalParsingConfig": {
            "$ref": "#/$defs/GoogleCloudDiscoveryengineV1alphaDigitalParsingConfig"
          },
          "layoutParsingConfig": {
            "$ref": "#/$defs/GoogleCloudDiscoveryengineV1alphaLayoutParsingConfig"
          },
          "ocrParsingConfig": {
            "$ref": "#/$defs/GoogleCloudDiscoveryengineV1alphaOcrParsingConfig"
          }
        },
        "type": "object"
      },
      "GoogleCloudDiscoveryengineV1alphaDigitalParsingConfig": {
        "description": "The digital parsing configurations for documents.",
        "properties": {},
        "type": "object"
      },
      "GoogleCloudDiscoveryengineV1alphaLayoutParsingConfig": {
        "description": "The layout parsing configurations for documents.",
        "properties": {},
        "type": "object"
      },
      "GoogleCloudDiscoveryengineV1alphaOcrParsingConfig": {
        "description": "The OCR parsing configurations for documents.",
        "properties": {
          "enhancedDocumentElements": {
            "description": "Apply additional enhanced OCR processing to a list of document elements. Supported values: * `table`: advanced table parsing model.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "useNativeText": {
            "description": "If true, will use native text instead of OCR text on pages containing native text.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "GoogleCloudDiscoveryengineV1alphaOcrConfig": {
        "deprecated": true,
        "description": "The OCR options for parsing documents.",
        "properties": {
          "enabled": {
            "description": "Required. If OCR is enabled or not. OCR must be enabled for other OcrConfig options to apply. We will only perform OCR on the first 80 pages of the PDF files.",
            "type": "boolean"
          },
          "enhancedDocumentElements": {
            "description": "Apply additional enhanced OCR processing to a list of document elements. Supported values: * `table`: advanced table parsing model.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "useNativeText": {
            "description": "If true, will use native text instead of OCR text on pages containing native text.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "GoogleCloudDiscoveryengineV1alphaIdpConfig": {
        "description": "Identity Provider Config.",
        "properties": {
          "externalIdpConfig": {
            "$ref": "#/$defs/GoogleCloudDiscoveryengineV1alphaIdpConfigExternalIdpConfig"
          },
          "idpType": {
            "description": "Identity provider type configured.",
            "enum": [
              "IDP_TYPE_UNSPECIFIED",
              "GSUITE",
              "THIRD_PARTY"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "GoogleCloudDiscoveryengineV1alphaIdpConfigExternalIdpConfig": {
        "description": "Third party IDP Config.",
        "properties": {
          "workforcePoolName": {
            "description": "Workforce pool name. Example: \"locations/global/workforcePools/pool_id\"",
            "type": "string"
          }
        },
        "type": "object"
      },
      "GoogleCloudDiscoveryengineV1alphaSchema": {
        "description": "Defines the structure and layout of a type of document data.",
        "properties": {
          "fieldConfigs": {
            "description": "Output only. Configurations for fields of the schema.",
            "items": {
              "$ref": "#/$defs/GoogleCloudDiscoveryengineV1alphaFieldConfig"
            },
            "readOnly": true,
            "type": "array"
          },
          "jsonSchema": {
            "description": "The JSON representation of the schema.",
            "type": "string"
          },
          "name": {
            "description": "Immutable. The full resource name of the schema, in the format of `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/schemas/{schema}`. This field must be a UTF-8 encoded string with a length limit of 1024 characters.",
            "type": "string"
          },
          "structSchema": {
            "additionalProperties": {
              "description": "Properties of the object."
            },
            "description": "The structured representation of the schema.",
            "type": "object"
          }
        },
        "type": "object"
      },
      "GoogleCloudDiscoveryengineV1alphaFieldConfig": {
        "description": "Configurations for fields of a schema. For example, configuring a field is indexable, or searchable.",
        "properties": {
          "completableOption": {
            "description": "If completable_option is COMPLETABLE_ENABLED, field values are directly used and returned as suggestions for Autocomplete in CompletionService.CompleteQuery. If completable_option is unset, the server behavior defaults to COMPLETABLE_DISABLED for fields that support setting completable options, which are just `string` fields. For those fields that do not support setting completable options, the server will skip completable option setting, and setting completable_option for those fields will throw `INVALID_ARGUMENT` error.",
            "enum": [
              "COMPLETABLE_OPTION_UNSPECIFIED",
              "COMPLETABLE_ENABLED",
              "COMPLETABLE_DISABLED"
            ],
            "type": "string"
          },
          "dynamicFacetableOption": {
            "description": "If dynamic_facetable_option is DYNAMIC_FACETABLE_ENABLED, field values are available for dynamic facet. Could only be DYNAMIC_FACETABLE_DISABLED if FieldConfig.indexable_option is INDEXABLE_DISABLED. Otherwise, an `INVALID_ARGUMENT` error will be returned. If dynamic_facetable_option is unset, the server behavior defaults to DYNAMIC_FACETABLE_DISABLED for fields that support setting dynamic facetable options. For those fields that do not support setting dynamic facetable options, such as `object` and `boolean`, the server will skip dynamic facetable option setting, and setting dynamic_facetable_option for those fields will throw `INVALID_ARGUMENT` error.",
            "enum": [
              "DYNAMIC_FACETABLE_OPTION_UNSPECIFIED",
              "DYNAMIC_FACETABLE_ENABLED",
              "DYNAMIC_FACETABLE_DISABLED"
            ],
            "type": "string"
          },
          "fieldPath": {
            "description": "Required. Field path of the schema field. For example: `title`, `description`, `release_info.release_year`.",
            "type": "string"
          },
          "fieldType": {
            "description": "Output only. Raw type of the field.",
            "enum": [
              "FIELD_TYPE_UNSPECIFIED",
              "OBJECT",
              "STRING",
              "NUMBER",
              "INTEGER",
              "BOOLEAN",
              "GEOLOCATION",
              "DATETIME"
            ],
            "readOnly": true,
            "type": "string"
          },
          "indexableOption": {
            "description": "If indexable_option is INDEXABLE_ENABLED, field values are indexed so that it can be filtered or faceted in SearchService.Search. If indexable_option is unset, the server behavior defaults to INDEXABLE_DISABLED for fields that support setting indexable options. For those fields that do not support setting indexable options, such as `object` and `boolean` and key properties, the server will skip indexable_option setting, and setting indexable_option for those fields will throw `INVALID_ARGUMENT` error.",
            "enum": [
              "INDEXABLE_OPTION_UNSPECIFIED",
              "INDEXABLE_ENABLED",
              "INDEXABLE_DISABLED"
            ],
            "type": "string"
          },
          "keyPropertyType": {
            "description": "Output only. Type of the key property that this field is mapped to. Empty string if this is not annotated as mapped to a key property. Example types are `title`, `description`. Full list is defined by `keyPropertyMapping` in the schema field annotation. If the schema field has a `KeyPropertyMapping` annotation, `indexable_option` and `searchable_option` of this field cannot be modified.",
            "readOnly": true,
            "type": "string"
          },
          "recsFilterableOption": {
            "description": "If recs_filterable_option is FILTERABLE_ENABLED, field values are filterable by filter expression in RecommendationService.Recommend. If FILTERABLE_ENABLED but the field type is numerical, field values are not filterable by text queries in RecommendationService.Recommend. Only textual fields are supported. If recs_filterable_option is unset, the default setting is FILTERABLE_DISABLED for fields that support setting filterable options. When a field set to [FILTERABLE_DISABLED] is filtered, a warning is generated and an empty result is returned.",
            "enum": [
              "FILTERABLE_OPTION_UNSPECIFIED",
              "FILTERABLE_ENABLED",
              "FILTERABLE_DISABLED"
            ],
            "type": "string"
          },
          "retrievableOption": {
            "description": "If retrievable_option is RETRIEVABLE_ENABLED, field values are included in the search results. If retrievable_option is unset, the server behavior defaults to RETRIEVABLE_DISABLED for fields that support setting retrievable options. For those fields that do not support setting retrievable options, such as `object` and `boolean`, the server will skip retrievable option setting, and setting retrievable_option for those fields will throw `INVALID_ARGUMENT` error.",
            "enum": [
              "RETRIEVABLE_OPTION_UNSPECIFIED",
              "RETRIEVABLE_ENABLED",
              "RETRIEVABLE_DISABLED"
            ],
            "type": "string"
          },
          "searchableOption": {
            "description": "If searchable_option is SEARCHABLE_ENABLED, field values are searchable by text queries in SearchService.Search. If SEARCHABLE_ENABLED but field type is numerical, field values will not be searchable by text queries in SearchService.Search, as there are no text values associated to numerical fields. If searchable_option is unset, the server behavior defaults to SEARCHABLE_DISABLED for fields that support setting searchable options. Only `string` fields that have no key property mapping support setting searchable_option. For those fields that do not support setting searchable options, the server will skip searchable option setting, and setting searchable_option for those fields will throw `INVALID_ARGUMENT` error.",
            "enum": [
              "SEARCHABLE_OPTION_UNSPECIFIED",
              "SEARCHABLE_ENABLED",
              "SEARCHABLE_DISABLED"
            ],
            "type": "string"
          }
        },
        "type": "object"
      }
    }
  },
  "handler": "http",
  "request": {
    "method": "POST",
    "url": {
      "$uri": "https://discoveryengine.googleapis.com//v1alpha/{parent}/dataStores{?createAdvancedSiteSearch,dataStoreId,$.xgafv,access_token,alt,callback,fields,key,oauth_token,prettyPrint,quotaUser,upload_protocol,uploadType}"
    },
    "body": {
      "$": "body",
      "encode": "json"
    }
  },
  "responses": {
    "200": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "This resource represents a long-running operation that is the result of a network API call.",
        "**Key properties:**",
        {
          "$ul": [
            "**done**: If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.",
            [
              "**error**: The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).",
              {
                "$ul": [
                  "**code**: The status code, which should be an enum value of google.rpc.Code.",
                  "**details**: A list of messages that carry the error details. There is a common set of message types for APIs to use.",
                  "**message**: A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client."
                ]
              }
            ],
            "**metadata**: Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.",
            "**name**: The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.",
            "**response**: The normal, successful response of the operation. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`."
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    }
  }
}
