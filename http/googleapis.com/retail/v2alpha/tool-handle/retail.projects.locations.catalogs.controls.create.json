{
  "name": "retail_projects_locations_catalogs_controls_create",
  "description": "Creates a Control. If the Control to create already exists, an ALREADY_EXISTS error is returned.",
  "parameters": {
    "type": "object",
    "properties": {
      "parent": {
        "type": "string",
        "description": "Required. Full resource name of parent catalog. Format: `projects/{project_number}/locations/{location_id}/catalogs/{catalog_id}`"
      },
      "controlId": {
        "type": "string",
        "description": "Required. The ID to use for the Control, which will become the final component of the Control's resource name. This value should be 4-63 characters, and valid characters are /a-z-_/."
      },
      "$.xgafv": {
        "enum": [
          "1",
          "2"
        ],
        "type": "string",
        "description": "V1 error format."
      },
      "access_token": {
        "type": "string",
        "description": "OAuth access token."
      },
      "alt": {
        "enum": [
          "json",
          "media",
          "proto"
        ],
        "type": "string",
        "description": "Data format for response."
      },
      "callback": {
        "type": "string",
        "description": "JSONP"
      },
      "fields": {
        "type": "string",
        "description": "Selector specifying which fields to include in a partial response."
      },
      "key": {
        "type": "string",
        "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
      },
      "oauth_token": {
        "type": "string",
        "description": "OAuth 2.0 token for the current user."
      },
      "prettyPrint": {
        "type": "boolean",
        "description": "Returns response with indentations and line breaks."
      },
      "quotaUser": {
        "type": "string",
        "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
      },
      "upload_protocol": {
        "type": "string",
        "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
      },
      "uploadType": {
        "type": "string",
        "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
      },
      "body": {
        "$ref": "#/$defs/GoogleCloudRetailV2alphaControl"
      }
    },
    "required": [
      "parent"
    ],
    "$defs": {
      "GoogleCloudRetailV2alphaControl": {
        "description": "Configures dynamic metadata that can be linked to a ServingConfig and affect search or recommendation results at serving time.",
        "properties": {
          "associatedServingConfigIds": {
            "description": "Output only. List of serving config ids that are associated with this control in the same Catalog. Note the association is managed via the ServingConfig, this is an output only denormalized view.",
            "items": {
              "type": "string"
            },
            "readOnly": true,
            "type": "array"
          },
          "displayName": {
            "description": "Required. The human readable control display name. Used in Retail UI. This field must be a UTF-8 encoded string with a length limit of 128 characters. Otherwise, an INVALID_ARGUMENT error is thrown.",
            "type": "string"
          },
          "facetSpec": {
            "$ref": "#/$defs/GoogleCloudRetailV2alphaSearchRequestFacetSpec"
          },
          "name": {
            "description": "Immutable. Fully qualified name `projects/*/locations/global/catalogs/*/controls/*`",
            "type": "string"
          },
          "rule": {
            "$ref": "#/$defs/GoogleCloudRetailV2alphaRule"
          },
          "searchSolutionUseCase": {
            "description": "Specifies the use case for the control. Affects what condition fields can be set. Only settable by search controls. Will default to SEARCH_SOLUTION_USE_CASE_SEARCH if not specified. Currently only allow one search_solution_use_case per control.",
            "items": {
              "enum": [
                "SEARCH_SOLUTION_USE_CASE_UNSPECIFIED",
                "SEARCH_SOLUTION_USE_CASE_SEARCH",
                "SEARCH_SOLUTION_USE_CASE_BROWSE"
              ],
              "type": "string"
            },
            "type": "array"
          },
          "solutionTypes": {
            "description": "Required. Immutable. The solution types that the control is used for. Currently we support setting only one type of solution at creation time. Only `SOLUTION_TYPE_SEARCH` value is supported at the moment. If no solution type is provided at creation time, will default to SOLUTION_TYPE_SEARCH.",
            "items": {
              "enum": [
                "SOLUTION_TYPE_UNSPECIFIED",
                "SOLUTION_TYPE_RECOMMENDATION",
                "SOLUTION_TYPE_SEARCH"
              ],
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "GoogleCloudRetailV2alphaSearchRequestFacetSpec": {
        "description": "A facet specification to perform faceted search.",
        "properties": {
          "enableDynamicPosition": {
            "description": "Enables dynamic position for this facet. If set to true, the position of this facet among all facets in the response is determined by Google Retail Search. It is ordered together with dynamic facets if dynamic facets is enabled. If set to false, the position of this facet in the response is the same as in the request, and it is ranked before the facets with dynamic position enable and all dynamic facets. For example, you may always want to have rating facet returned in the response, but it's not necessarily to always display the rating facet at the top. In that case, you can set enable_dynamic_position to true so that the position of rating facet in response is determined by Google Retail Search. Another example, assuming you have the following facets in the request: * \"rating\", enable_dynamic_position = true * \"price\", enable_dynamic_position = false * \"brands\", enable_dynamic_position = false And also you have a dynamic facets enable, which generates a facet \"gender\". Then, the final order of the facets in the response can be (\"price\", \"brands\", \"rating\", \"gender\") or (\"price\", \"brands\", \"gender\", \"rating\") depends on how Google Retail Search orders \"gender\" and \"rating\" facets. However, notice that \"price\" and \"brands\" are always ranked at first and second position because their enable_dynamic_position values are false.",
            "type": "boolean"
          },
          "excludedFilterKeys": {
            "description": "List of keys to exclude when faceting. By default, FacetKey.key is not excluded from the filter unless it is listed in this field. Listing a facet key in this field allows its values to appear as facet results, even when they are filtered out of search results. Using this field does not affect what search results are returned. For example, suppose there are 100 products with the color facet \"Red\" and 200 products with the color facet \"Blue\". A query containing the filter \"colorFamilies:ANY(\"Red\")\" and having \"colorFamilies\" as FacetKey.key would by default return only \"Red\" products in the search results, and also return \"Red\" with count 100 as the only color facet. Although there are also blue products available, \"Blue\" would not be shown as an available facet value. If \"colorFamilies\" is listed in \"excludedFilterKeys\", then the query returns the facet values \"Red\" with count 100 and \"Blue\" with count 200, because the \"colorFamilies\" key is now excluded from the filter. Because this field doesn't affect search results, the search results are still correctly filtered to return only \"Red\" products. A maximum of 100 values are allowed. Otherwise, an INVALID_ARGUMENT error is returned.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "facetKey": {
            "$ref": "#/$defs/GoogleCloudRetailV2alphaSearchRequestFacetSpecFacetKey"
          },
          "limit": {
            "description": "Maximum of facet values that should be returned for this facet. If unspecified, defaults to 50. The maximum allowed value is 300. Values above 300 will be coerced to 300. If this field is negative, an INVALID_ARGUMENT is returned.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "GoogleCloudRetailV2alphaSearchRequestFacetSpecFacetKey": {
        "description": "Specifies how a facet is computed.",
        "properties": {
          "caseInsensitive": {
            "description": "True to make facet keys case insensitive when getting faceting values with prefixes or contains; false otherwise.",
            "type": "boolean"
          },
          "contains": {
            "description": "Only get facet values that contains the given strings. For example, suppose \"categories\" has three values \"Women > Shoe\", \"Women > Dress\" and \"Men > Shoe\". If set \"contains\" to \"Shoe\", the \"categories\" facet gives only \"Women > Shoe\" and \"Men > Shoe\". Only supported on textual fields. Maximum is 10.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "intervals": {
            "description": "Set only if values should be bucketized into intervals. Must be set for facets with numerical values. Must not be set for facet with text values. Maximum number of intervals is 40. For all numerical facet keys that appear in the list of products from the catalog, the percentiles 0, 10, 30, 50, 70, 90, and 100 are computed from their distribution weekly. If the model assigns a high score to a numerical facet key and its intervals are not specified in the search request, these percentiles become the bounds for its intervals and are returned in the response. If the facet key intervals are specified in the request, then the specified intervals are returned instead.",
            "items": {
              "$ref": "#/$defs/GoogleCloudRetailV2alphaInterval"
            },
            "type": "array"
          },
          "key": {
            "description": "Required. Supported textual and numerical facet keys in Product object, over which the facet values are computed. Facet key is case-sensitive. Allowed facet keys when FacetKey.query is not specified: * textual_field = * \"brands\" * \"categories\" * \"genders\" * \"ageGroups\" * \"availability\" * \"colorFamilies\" * \"colors\" * \"sizes\" * \"materials\" * \"patterns\" * \"conditions\" * \"attributes.key\" * \"pickupInStore\" * \"shipToStore\" * \"sameDayDelivery\" * \"nextDayDelivery\" * \"customFulfillment1\" * \"customFulfillment2\" * \"customFulfillment3\" * \"customFulfillment4\" * \"customFulfillment5\" * \"inventory(place_id,attributes.key)\" * numerical_field = * \"price\" * \"discount\" * \"rating\" * \"ratingCount\" * \"attributes.key\" * \"inventory(place_id,price)\" * \"inventory(place_id,original_price)\" * \"inventory(place_id,attributes.key)\"",
            "type": "string"
          },
          "orderBy": {
            "description": "The order in which SearchResponse.Facet.values are returned. Allowed values are: * \"count desc\", which means order by SearchResponse.Facet.values.count descending. * \"value desc\", which means order by SearchResponse.Facet.values.value descending. Only applies to textual facets. If not set, textual values are sorted in [natural order](https://en.wikipedia.org/wiki/Natural_sort_order); numerical intervals are sorted in the order given by FacetSpec.FacetKey.intervals; FulfillmentInfo.place_ids are sorted in the order given by FacetSpec.FacetKey.restricted_values.",
            "type": "string"
          },
          "prefixes": {
            "description": "Only get facet values that start with the given string prefix. For example, suppose \"categories\" has three values \"Women > Shoe\", \"Women > Dress\" and \"Men > Shoe\". If set \"prefixes\" to \"Women\", the \"categories\" facet gives only \"Women > Shoe\" and \"Women > Dress\". Only supported on textual fields. Maximum is 10.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "query": {
            "description": "The query that is used to compute facet for the given facet key. When provided, it overrides the default behavior of facet computation. The query syntax is the same as a filter expression. See SearchRequest.filter for detail syntax and limitations. Notice that there is no limitation on FacetKey.key when query is specified. In the response, SearchResponse.Facet.values.value is always \"1\" and SearchResponse.Facet.values.count is the number of results that match the query. For example, you can set a customized facet for \"shipToStore\", where FacetKey.key is \"customizedShipToStore\", and FacetKey.query is \"availability: ANY(\\\"IN_STOCK\\\") AND shipToStore: ANY(\\\"123\\\")\". Then the facet counts the products that are both in stock and ship to store \"123\".",
            "type": "string"
          },
          "restrictedValues": {
            "description": "Only get facet for the given restricted values. For example, when using \"pickupInStore\" as key and set restricted values to [\"store123\", \"store456\"], only facets for \"store123\" and \"store456\" are returned. Only supported on predefined textual fields, custom textual attributes and fulfillments. Maximum is 20. Must be set for the fulfillment facet keys: * pickupInStore * shipToStore * sameDayDelivery * nextDayDelivery * customFulfillment1 * customFulfillment2 * customFulfillment3 * customFulfillment4 * customFulfillment5",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "returnMinMax": {
            "description": "Returns the min and max value for each numerical facet intervals. Ignored for textual facets.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "GoogleCloudRetailV2alphaInterval": {
        "description": "A floating point interval.",
        "properties": {
          "exclusiveMaximum": {
            "description": "Exclusive upper bound.",
            "format": "double",
            "type": "number"
          },
          "exclusiveMinimum": {
            "description": "Exclusive lower bound.",
            "format": "double",
            "type": "number"
          },
          "maximum": {
            "description": "Inclusive upper bound.",
            "format": "double",
            "type": "number"
          },
          "minimum": {
            "description": "Inclusive lower bound.",
            "format": "double",
            "type": "number"
          }
        },
        "type": "object"
      },
      "GoogleCloudRetailV2alphaRule": {
        "description": "A rule is a condition-action pair * A condition defines when a rule is to be triggered. * An action specifies what occurs on that trigger. Currently rules only work for controls with SOLUTION_TYPE_SEARCH.",
        "properties": {
          "boostAction": {
            "$ref": "#/$defs/GoogleCloudRetailV2alphaRuleBoostAction"
          },
          "condition": {
            "$ref": "#/$defs/GoogleCloudRetailV2alphaCondition"
          },
          "doNotAssociateAction": {
            "$ref": "#/$defs/GoogleCloudRetailV2alphaRuleDoNotAssociateAction"
          },
          "filterAction": {
            "$ref": "#/$defs/GoogleCloudRetailV2alphaRuleFilterAction"
          },
          "forceReturnFacetAction": {
            "$ref": "#/$defs/GoogleCloudRetailV2alphaRuleForceReturnFacetAction"
          },
          "ignoreAction": {
            "$ref": "#/$defs/GoogleCloudRetailV2alphaRuleIgnoreAction"
          },
          "onewaySynonymsAction": {
            "$ref": "#/$defs/GoogleCloudRetailV2alphaRuleOnewaySynonymsAction"
          },
          "redirectAction": {
            "$ref": "#/$defs/GoogleCloudRetailV2alphaRuleRedirectAction"
          },
          "removeFacetAction": {
            "$ref": "#/$defs/GoogleCloudRetailV2alphaRuleRemoveFacetAction"
          },
          "replacementAction": {
            "$ref": "#/$defs/GoogleCloudRetailV2alphaRuleReplacementAction"
          },
          "twowaySynonymsAction": {
            "$ref": "#/$defs/GoogleCloudRetailV2alphaRuleTwowaySynonymsAction"
          }
        },
        "type": "object"
      },
      "GoogleCloudRetailV2alphaRuleBoostAction": {
        "description": "A boost action to apply to results matching condition specified above.",
        "properties": {
          "boost": {
            "description": "Strength of the condition boost, which must be in [-1, 1]. Negative boost means demotion. Default is 0.0. Setting to 1.0 gives the item a big promotion. However, it does not necessarily mean that the boosted item will be the top result at all times, nor that other items will be excluded. Results could still be shown even when none of them matches the condition. And results that are significantly more relevant to the search query can still trump your heavily favored but irrelevant items. Setting to -1.0 gives the item a big demotion. However, results that are deeply relevant might still be shown. The item will have an upstream battle to get a fairly high ranking, but it is not blocked out completely. Setting to 0.0 means no boost applied. The boosting condition is ignored.",
            "format": "float",
            "type": "number"
          },
          "productsFilter": {
            "description": "The filter can have a max size of 5000 characters. An expression which specifies which products to apply an action to. The syntax and supported fields are the same as a filter expression. See SearchRequest.filter for detail syntax and limitations. Examples: * To boost products with product ID \"product_1\" or \"product_2\", and color \"Red\" or \"Blue\": *(id: ANY(\"product_1\", \"product_2\")) * *AND * *(colorFamilies: ANY(\"Red\", \"Blue\")) *",
            "type": "string"
          }
        },
        "type": "object"
      },
      "GoogleCloudRetailV2alphaCondition": {
        "description": "Metadata that is used to define a condition that triggers an action. A valid condition must specify at least one of 'query_terms' or 'products_filter'. If multiple fields are specified, the condition is met if all the fields are satisfied e.g. if a set of query terms and product_filter are set, then only items matching the product_filter for requests with a query matching the query terms wil get boosted.",
        "properties": {
          "activeTimeRange": {
            "description": "Range of time(s) specifying when Condition is active. Condition true if any time range matches.",
            "items": {
              "$ref": "#/$defs/GoogleCloudRetailV2alphaConditionTimeRange"
            },
            "type": "array"
          },
          "pageCategories": {
            "description": "Used to support browse uses cases. A list (up to 10 entries) of categories or departments. The format should be the same as UserEvent.page_categories;",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "queryTerms": {
            "description": "A list (up to 10 entries) of terms to match the query on. If not specified, match all queries. If many query terms are specified, the condition is matched if any of the terms is a match (i.e. using the OR operator).",
            "items": {
              "$ref": "#/$defs/GoogleCloudRetailV2alphaConditionQueryTerm"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "GoogleCloudRetailV2alphaConditionTimeRange": {
        "description": "Used for time-dependent conditions. Example: Want to have rule applied for week long sale.",
        "properties": {
          "endTime": {
            "description": "End of time range. Range is inclusive.",
            "format": "google-datetime",
            "type": "string"
          },
          "startTime": {
            "description": "Start of time range. Range is inclusive.",
            "format": "google-datetime",
            "type": "string"
          }
        },
        "type": "object"
      },
      "GoogleCloudRetailV2alphaConditionQueryTerm": {
        "description": "Query terms that we want to match on.",
        "properties": {
          "fullMatch": {
            "description": "Whether this is supposed to be a full or partial match.",
            "type": "boolean"
          },
          "value": {
            "description": "The value of the term to match on. Value cannot be empty. Value can have at most 3 terms if specified as a partial match. Each space separated string is considered as one term. For example, \"a b c\" is 3 terms and allowed, but \" a b c d\" is 4 terms and not allowed for a partial match.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "GoogleCloudRetailV2alphaRuleDoNotAssociateAction": {
        "description": "Prevents `query_term` from being associated with specified terms during search. Example: Don't associate \"gShoe\" and \"cheap\".",
        "properties": {
          "doNotAssociateTerms": {
            "description": "Cannot contain duplicates or the query term. Can specify up to 100 terms.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "queryTerms": {
            "description": "Terms from the search query. Will not consider do_not_associate_terms for search if in search query. Can specify up to 100 terms.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "terms": {
            "description": "Will be [deprecated = true] post migration;",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "GoogleCloudRetailV2alphaRuleFilterAction": {
        "description": "* Rule Condition: - No Condition.query_terms provided is a global match. - 1 or more Condition.query_terms provided are combined with OR operator. * Action Input: The request query and filter that are applied to the retrieved products, in addition to any filters already provided with the SearchRequest. The AND operator is used to combine the query's existing filters with the filter rule(s). NOTE: May result in 0 results when filters conflict. * Action Result: Filters the returned objects to be ONLY those that passed the filter.",
        "properties": {
          "filter": {
            "description": "A filter to apply on the matching condition results. Supported features: * filter must be set. * Filter syntax is identical to SearchRequest.filter. For more information, see [Filter](/retail/docs/filter-and-order#filter). * To filter products with product ID \"product_1\" or \"product_2\", and color \"Red\" or \"Blue\": *(id: ANY(\"product_1\", \"product_2\")) * *AND * *(colorFamilies: ANY(\"Red\", \"Blue\")) *",
            "type": "string"
          }
        },
        "type": "object"
      },
      "GoogleCloudRetailV2alphaRuleForceReturnFacetAction": {
        "description": "Force returns an attribute/facet in the request around a certain position or above. * Rule Condition: Must specify non-empty Condition.query_terms (for search only) or Condition.page_categories (for browse only), but can't specify both. * Action Inputs: attribute name, position * Action Result: Will force return a facet key around a certain position or above if the condition is satisfied. Example: Suppose the query is \"shoes\", the Condition.query_terms is \"shoes\", the ForceReturnFacetAction.FacetPositionAdjustment.attribute_name is \"size\" and the ForceReturnFacetAction.FacetPositionAdjustment.position is 8. Two cases: a) The facet key \"size\" is not already in the top 8 slots, then the facet \"size\" will appear at a position close to 8. b) The facet key \"size\" in among the top 8 positions in the request, then it will stay at its current rank.",
        "properties": {
          "facetPositionAdjustments": {
            "description": "Each instance corresponds to a force return attribute for the given condition. There can't be more 3 instances here.",
            "items": {
              "$ref": "#/$defs/GoogleCloudRetailV2alphaRuleForceReturnFacetActionFacetPositionAdjustment"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "GoogleCloudRetailV2alphaRuleForceReturnFacetActionFacetPositionAdjustment": {
        "description": "Each facet position adjustment consists of a single attribute name (i.e. facet key) along with a specified position.",
        "properties": {
          "attributeName": {
            "description": "The attribute name to force return as a facet. Each attribute name should be a valid attribute name, be non-empty and contain at most 80 characters long.",
            "type": "string"
          },
          "position": {
            "description": "This is the position in the request as explained above. It should be strictly positive be at most 100.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "GoogleCloudRetailV2alphaRuleIgnoreAction": {
        "description": "Prevents a term in the query from being used in search. Example: Don't search for \"shoddy\".",
        "properties": {
          "ignoreTerms": {
            "description": "Terms to ignore in the search query.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "GoogleCloudRetailV2alphaRuleOnewaySynonymsAction": {
        "description": "Maps a set of terms to a set of synonyms. Set of synonyms will be treated as synonyms of each query term only. `query_terms` will not be treated as synonyms of each other. Example: \"sneakers\" will use a synonym of \"shoes\". \"shoes\" will not use a synonym of \"sneakers\".",
        "properties": {
          "onewayTerms": {
            "description": "Will be [deprecated = true] post migration;",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "queryTerms": {
            "description": "Terms from the search query. Will treat synonyms as their synonyms. Not themselves synonyms of the synonyms. Can specify up to 100 terms.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "synonyms": {
            "description": "Defines a set of synonyms. Cannot contain duplicates. Can specify up to 100 synonyms.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "GoogleCloudRetailV2alphaRuleRedirectAction": {
        "description": "Redirects a shopper to a specific page. * Rule Condition: Must specify Condition.query_terms. * Action Input: Request Query * Action Result: Redirects shopper to provided uri.",
        "properties": {
          "redirectUri": {
            "description": "URL must have length equal or less than 2000 characters.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "GoogleCloudRetailV2alphaRuleRemoveFacetAction": {
        "description": "Removes an attribute/facet in the request if is present. * Rule Condition: Must specify non-empty Condition.query_terms (for search only) or Condition.page_categories (for browse only), but can't specify both. * Action Input: attribute name * Action Result: Will remove the attribute (as a facet) from the request if it is present. Example: Suppose the query is \"shoes\", the Condition.query_terms is \"shoes\" and the attribute name \"size\", then facet key \"size\" will be removed from the request (if it is present).",
        "properties": {
          "attributeNames": {
            "description": "The attribute names (i.e. facet keys) to remove from the dynamic facets (if present in the request). There can't be more 3 attribute names. Each attribute name should be a valid attribute name, be non-empty and contain at most 80 characters.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "GoogleCloudRetailV2alphaRuleReplacementAction": {
        "description": "Replaces a term in the query. Multiple replacement candidates can be specified. All `query_terms` will be replaced with the replacement term. Example: Replace \"gShoe\" with \"google shoe\".",
        "properties": {
          "queryTerms": {
            "description": "Terms from the search query. Will be replaced by replacement term. Can specify up to 100 terms.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "replacementTerm": {
            "description": "Term that will be used for replacement.",
            "type": "string"
          },
          "term": {
            "description": "Will be [deprecated = true] post migration;",
            "type": "string"
          }
        },
        "type": "object"
      },
      "GoogleCloudRetailV2alphaRuleTwowaySynonymsAction": {
        "description": "Creates a set of terms that will be treated as synonyms of each other. Example: synonyms of \"sneakers\" and \"shoes\": * \"sneakers\" will use a synonym of \"shoes\". * \"shoes\" will use a synonym of \"sneakers\".",
        "properties": {
          "synonyms": {
            "description": "Defines a set of synonyms. Can specify up to 100 synonyms. Must specify at least 2 synonyms.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      }
    }
  },
  "handler": "http",
  "request": {
    "method": "POST",
    "url": {
      "$uri": "https://retail.googleapis.com//v2alpha/{parent}/controls{?controlId,$.xgafv,access_token,alt,callback,fields,key,oauth_token,prettyPrint,quotaUser,upload_protocol,uploadType}"
    },
    "body": {
      "$": "body",
      "encode": "json"
    }
  },
  "responses": {
    "200": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "Configures dynamic metadata that can be linked to a ServingConfig and affect search or recommendation results at serving time.",
        "**Key properties:**",
        {
          "$ul": [
            "**associatedServingConfigIds**: Output only. List of serving config ids that are associated with this control in the same Catalog. Note the association is managed via the ServingConfig, this is an output only denormalized view.",
            "**displayName**: Required. The human readable control display name. Used in Retail UI. This field must be a UTF-8 encoded string with a length limit of 128 characters. Otherwise, an INVALID_ARGUMENT error is thrown.",
            [
              "**facetSpec**: A facet specification to perform faceted search.",
              {
                "$ul": [
                  "**enableDynamicPosition**: Enables dynamic position for this facet. If set to true, the position of this facet among all facets in the response is determined by Google Retail Search. It is ordered together with dynamic facets if dynamic facets is enabled. If set to false, the position of this facet in the response is the same as in the request, and it is ranked before the facets with dynamic position enable and all dynamic facets. For example, you may always want to have rating facet returned in the response, but it's not necessarily to always display the rating facet at the top. In that case, you can set enable_dynamic_position to true so that the position of rating facet in response is determined by Google Retail Search. Another example, assuming you have the following facets in the request: * \"rating\", enable_dynamic_position = true * \"price\", enable_dynamic_position = false * \"brands\", enable_dynamic_position = false And also you have a dynamic facets enable, which generates a facet \"gender\". Then, the final order of the facets in the response can be (\"price\", \"brands\", \"rating\", \"gender\") or (\"price\", \"brands\", \"gender\", \"rating\") depends on how Google Retail Search orders \"gender\" and \"rating\" facets. However, notice that \"price\" and \"brands\" are always ranked at first and second position because their enable_dynamic_position values are false.",
                  "**excludedFilterKeys**: List of keys to exclude when faceting. By default, FacetKey.key is not excluded from the filter unless it is listed in this field. Listing a facet key in this field allows its values to appear as facet results, even when they are filtered out of search results. Using this field does not affect what search results are returned. For example, suppose there are 100 products with the color facet \"Red\" and 200 products with the color facet \"Blue\". A query containing the filter \"colorFamilies:ANY(\"Red\")\" and having \"colorFamilies\" as FacetKey.key would by default return only \"Red\" products in the search results, and also return \"Red\" with count 100 as the only color facet. Although there are also blue products available, \"Blue\" would not be shown as an available facet value. If \"colorFamilies\" is listed in \"excludedFilterKeys\", then the query returns the facet values \"Red\" with count 100 and \"Blue\" with count 200, because the \"colorFamilies\" key is now excluded from the filter. Because this field doesn't affect search results, the search results are still correctly filtered to return only \"Red\" products. A maximum of 100 values are allowed. Otherwise, an INVALID_ARGUMENT error is returned.",
                  [
                    "**facetKey**: Specifies how a facet is computed.",
                    {
                      "$ul": [
                        "**caseInsensitive**: True to make facet keys case insensitive when getting faceting values with prefixes or contains; false otherwise.",
                        "**contains**: Only get facet values that contains the given strings. For example, suppose \"categories\" has three values \"Women > Shoe\", \"Women > Dress\" and \"Men > Shoe\". If set \"contains\" to \"Shoe\", the \"categories\" facet gives only \"Women > Shoe\" and \"Men > Shoe\". Only supported on textual fields. Maximum is 10.",
                        "**intervals**: Set only if values should be bucketized into intervals. Must be set for facets with numerical values. Must not be set for facet with text values. Maximum number of intervals is 40. For all numerical facet keys that appear in the list of products from the catalog, the percentiles 0, 10, 30, 50, 70, 90, and 100 are computed from their distribution weekly. If the model assigns a high score to a numerical facet key and its intervals are not specified in the search request, these percentiles become the bounds for its intervals and are returned in the response. If the facet key intervals are specified in the request, then the specified intervals are returned instead.",
                        "**key**: Required. Supported textual and numerical facet keys in Product object, over which the facet values are computed. Facet key is case-sensitive. Allowed facet keys when FacetKey.query is not specified: * textual_field = * \"brands\" * \"categories\" * \"genders\" * \"ageGroups\" * \"availability\" * \"colorFamilies\" * \"colors\" * \"sizes\" * \"materials\" * \"patterns\" * \"conditions\" * \"attributes.key\" * \"pickupInStore\" * \"shipToStore\" * \"sameDayDelivery\" * \"nextDayDelivery\" * \"customFulfillment1\" * \"customFulfillment2\" * \"customFulfillment3\" * \"customFulfillment4\" * \"customFulfillment5\" * \"inventory(place_id,attributes.key)\" * numerical_field = * \"price\" * \"discount\" * \"rating\" * \"ratingCount\" * \"attributes.key\" * \"inventory(place_id,price)\" * \"inventory(place_id,original_price)\" * \"inventory(place_id,attributes.key)\"",
                        "**orderBy**: The order in which SearchResponse.Facet.values are returned. Allowed values are: * \"count desc\", which means order by SearchResponse.Facet.values.count descending. * \"value desc\", which means order by SearchResponse.Facet.values.value descending. Only applies to textual facets. If not set, textual values are sorted in [natural order](https://en.wikipedia.org/wiki/Natural_sort_order); numerical intervals are sorted in the order given by FacetSpec.FacetKey.intervals; FulfillmentInfo.place_ids are sorted in the order given by FacetSpec.FacetKey.restricted_values.",
                        "**prefixes**: Only get facet values that start with the given string prefix. For example, suppose \"categories\" has three values \"Women > Shoe\", \"Women > Dress\" and \"Men > Shoe\". If set \"prefixes\" to \"Women\", the \"categories\" facet gives only \"Women > Shoe\" and \"Women > Dress\". Only supported on textual fields. Maximum is 10.",
                        "**query**: The query that is used to compute facet for the given facet key. When provided, it overrides the default behavior of facet computation. The query syntax is the same as a filter expression. See SearchRequest.filter for detail syntax and limitations. Notice that there is no limitation on FacetKey.key when query is specified. In the response, SearchResponse.Facet.values.value is always \"1\" and SearchResponse.Facet.values.count is the number of results that match the query. For example, you can set a customized facet for \"shipToStore\", where FacetKey.key is \"customizedShipToStore\", and FacetKey.query is \"availability: ANY(\\\"IN_STOCK\\\") AND shipToStore: ANY(\\\"123\\\")\". Then the facet counts the products that are both in stock and ship to store \"123\".",
                        "**restrictedValues**: Only get facet for the given restricted values. For example, when using \"pickupInStore\" as key and set restricted values to [\"store123\", \"store456\"], only facets for \"store123\" and \"store456\" are returned. Only supported on predefined textual fields, custom textual attributes and fulfillments. Maximum is 20. Must be set for the fulfillment facet keys: * pickupInStore * shipToStore * sameDayDelivery * nextDayDelivery * customFulfillment1 * customFulfillment2 * customFulfillment3 * customFulfillment4 * customFulfillment5",
                        "**returnMinMax**: Returns the min and max value for each numerical facet intervals. Ignored for textual facets."
                      ]
                    }
                  ],
                  "**limit**: Maximum of facet values that should be returned for this facet. If unspecified, defaults to 50. The maximum allowed value is 300. Values above 300 will be coerced to 300. If this field is negative, an INVALID_ARGUMENT is returned."
                ]
              }
            ],
            "**name**: Immutable. Fully qualified name `projects/*/locations/global/catalogs/*/controls/*`",
            [
              "**rule**: A rule is a condition-action pair * A condition defines when a rule is to be triggered. * An action specifies what occurs on that trigger. Currently rules only work for controls with SOLUTION_TYPE_SEARCH.",
              {
                "$ul": [
                  [
                    "**boostAction**: A boost action to apply to results matching condition specified above.",
                    {
                      "$ul": [
                        "**boost**: Strength of the condition boost, which must be in [-1, 1]. Negative boost means demotion. Default is 0.0. Setting to 1.0 gives the item a big promotion. However, it does not necessarily mean that the boosted item will be the top result at all times, nor that other items will be excluded. Results could still be shown even when none of them matches the condition. And results that are significantly more relevant to the search query can still trump your heavily favored but irrelevant items. Setting to -1.0 gives the item a big demotion. However, results that are deeply relevant might still be shown. The item will have an upstream battle to get a fairly high ranking, but it is not blocked out completely. Setting to 0.0 means no boost applied. The boosting condition is ignored.",
                        "**productsFilter**: The filter can have a max size of 5000 characters. An expression which specifies which products to apply an action to. The syntax and supported fields are the same as a filter expression. See SearchRequest.filter for detail syntax and limitations. Examples: * To boost products with product ID \"product_1\" or \"product_2\", and color \"Red\" or \"Blue\": *(id: ANY(\"product_1\", \"product_2\")) * *AND * *(colorFamilies: ANY(\"Red\", \"Blue\")) *"
                      ]
                    }
                  ],
                  [
                    "**condition**: Metadata that is used to define a condition that triggers an action. A valid condition must specify at least one of 'query_terms' or 'products_filter'. If multiple fields are specified, the condition is met if all the fields are satisfied e.g. if a set of query terms and product_filter are set, then only items matching the product_filter for requests with a query matching the query terms wil get boosted.",
                    {
                      "$ul": [
                        "**activeTimeRange**: Range of time(s) specifying when Condition is active. Condition true if any time range matches.",
                        "**pageCategories**: Used to support browse uses cases. A list (up to 10 entries) of categories or departments. The format should be the same as UserEvent.page_categories;",
                        "**queryTerms**: A list (up to 10 entries) of terms to match the query on. If not specified, match all queries. If many query terms are specified, the condition is matched if any of the terms is a match (i.e. using the OR operator)."
                      ]
                    }
                  ],
                  [
                    "**doNotAssociateAction**: Prevents `query_term` from being associated with specified terms during search. Example: Don't associate \"gShoe\" and \"cheap\".",
                    {
                      "$ul": [
                        "**doNotAssociateTerms**: Cannot contain duplicates or the query term. Can specify up to 100 terms.",
                        "**queryTerms**: Terms from the search query. Will not consider do_not_associate_terms for search if in search query. Can specify up to 100 terms.",
                        "**terms**: Will be [deprecated = true] post migration;"
                      ]
                    }
                  ],
                  [
                    "**filterAction**: * Rule Condition: - No Condition.query_terms provided is a global match. - 1 or more Condition.query_terms provided are combined with OR operator. * Action Input: The request query and filter that are applied to the retrieved products, in addition to any filters already provided with the SearchRequest. The AND operator is used to combine the query's existing filters with the filter rule(s). NOTE: May result in 0 results when filters conflict. * Action Result: Filters the returned objects to be ONLY those that passed the filter.",
                    {
                      "$ul": [
                        "**filter**: A filter to apply on the matching condition results. Supported features: * filter must be set. * Filter syntax is identical to SearchRequest.filter. For more information, see [Filter](/retail/docs/filter-and-order#filter). * To filter products with product ID \"product_1\" or \"product_2\", and color \"Red\" or \"Blue\": *(id: ANY(\"product_1\", \"product_2\")) * *AND * *(colorFamilies: ANY(\"Red\", \"Blue\")) *"
                      ]
                    }
                  ],
                  [
                    "**forceReturnFacetAction**: Force returns an attribute/facet in the request around a certain position or above. * Rule Condition: Must specify non-empty Condition.query_terms (for search only) or Condition.page_categories (for browse only), but can't specify both. * Action Inputs: attribute name, position * Action Result: Will force return a facet key around a certain position or above if the condition is satisfied. Example: Suppose the query is \"shoes\", the Condition.query_terms is \"shoes\", the ForceReturnFacetAction.FacetPositionAdjustment.attribute_name is \"size\" and the ForceReturnFacetAction.FacetPositionAdjustment.position is 8. Two cases: a) The facet key \"size\" is not already in the top 8 slots, then the facet \"size\" will appear at a position close to 8. b) The facet key \"size\" in among the top 8 positions in the request, then it will stay at its current rank.",
                    {
                      "$ul": [
                        "**facetPositionAdjustments**: Each instance corresponds to a force return attribute for the given condition. There can't be more 3 instances here."
                      ]
                    }
                  ],
                  [
                    "**ignoreAction**: Prevents a term in the query from being used in search. Example: Don't search for \"shoddy\".",
                    {
                      "$ul": [
                        "**ignoreTerms**: Terms to ignore in the search query."
                      ]
                    }
                  ],
                  [
                    "**onewaySynonymsAction**: Maps a set of terms to a set of synonyms. Set of synonyms will be treated as synonyms of each query term only. `query_terms` will not be treated as synonyms of each other. Example: \"sneakers\" will use a synonym of \"shoes\". \"shoes\" will not use a synonym of \"sneakers\".",
                    {
                      "$ul": [
                        "**onewayTerms**: Will be [deprecated = true] post migration;",
                        "**queryTerms**: Terms from the search query. Will treat synonyms as their synonyms. Not themselves synonyms of the synonyms. Can specify up to 100 terms.",
                        "**synonyms**: Defines a set of synonyms. Cannot contain duplicates. Can specify up to 100 synonyms."
                      ]
                    }
                  ],
                  [
                    "**redirectAction**: Redirects a shopper to a specific page. * Rule Condition: Must specify Condition.query_terms. * Action Input: Request Query * Action Result: Redirects shopper to provided uri.",
                    {
                      "$ul": [
                        "**redirectUri**: URL must have length equal or less than 2000 characters."
                      ]
                    }
                  ],
                  [
                    "**removeFacetAction**: Removes an attribute/facet in the request if is present. * Rule Condition: Must specify non-empty Condition.query_terms (for search only) or Condition.page_categories (for browse only), but can't specify both. * Action Input: attribute name * Action Result: Will remove the attribute (as a facet) from the request if it is present. Example: Suppose the query is \"shoes\", the Condition.query_terms is \"shoes\" and the attribute name \"size\", then facet key \"size\" will be removed from the request (if it is present).",
                    {
                      "$ul": [
                        "**attributeNames**: The attribute names (i.e. facet keys) to remove from the dynamic facets (if present in the request). There can't be more 3 attribute names. Each attribute name should be a valid attribute name, be non-empty and contain at most 80 characters."
                      ]
                    }
                  ],
                  [
                    "**replacementAction**: Replaces a term in the query. Multiple replacement candidates can be specified. All `query_terms` will be replaced with the replacement term. Example: Replace \"gShoe\" with \"google shoe\".",
                    {
                      "$ul": [
                        "**queryTerms**: Terms from the search query. Will be replaced by replacement term. Can specify up to 100 terms.",
                        "**replacementTerm**: Term that will be used for replacement.",
                        "**term**: Will be [deprecated = true] post migration;"
                      ]
                    }
                  ],
                  [
                    "**twowaySynonymsAction**: Creates a set of terms that will be treated as synonyms of each other. Example: synonyms of \"sneakers\" and \"shoes\": * \"sneakers\" will use a synonym of \"shoes\". * \"shoes\" will use a synonym of \"sneakers\".",
                    {
                      "$ul": [
                        "**synonyms**: Defines a set of synonyms. Can specify up to 100 synonyms. Must specify at least 2 synonyms."
                      ]
                    }
                  ]
                ]
              }
            ],
            "**searchSolutionUseCase**: Specifies the use case for the control. Affects what condition fields can be set. Only settable by search controls. Will default to SEARCH_SOLUTION_USE_CASE_SEARCH if not specified. Currently only allow one search_solution_use_case per control.",
            "**solutionTypes**: Required. Immutable. The solution types that the control is used for. Currently we support setting only one type of solution at creation time. Only `SOLUTION_TYPE_SEARCH` value is supported at the moment. If no solution type is provided at creation time, will default to SOLUTION_TYPE_SEARCH."
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    }
  }
}
