{
  "name": "automl_projects_locations_models_predict",
  "description": "Perform an online prediction. The prediction result will be directly returned in the response. Available for following ML problems, and their expected request payloads: * Image Classification - Image in .JPEG, .GIF or .PNG format, image_bytes up to 30MB. * Image Object Detection - Image in .JPEG, .GIF or .PNG format, image_bytes up to 30MB. * Text Classification - TextSnippet, content up to 60,000 characters, UTF-8 encoded. * Text Extraction - TextSnippet, content up to 30,000 characters, UTF-8 NFC encoded. * Translation - TextSnippet, content up to 25,000 characters, UTF-8 encoded. * Tables - Row, with column values matching the columns of the model, up to 5MB. Not available for FORECASTING prediction_type. * Text Sentiment - TextSnippet, content up 500 characters, UTF-8 encoded.",
  "parameters": {
    "type": "object",
    "properties": {
      "name": {
        "type": "string",
        "description": "Required. Name of the model requested to serve the prediction."
      },
      "$.xgafv": {
        "enum": [
          "1",
          "2"
        ],
        "type": "string",
        "description": "V1 error format."
      },
      "access_token": {
        "type": "string",
        "description": "OAuth access token."
      },
      "alt": {
        "enum": [
          "json",
          "media",
          "proto"
        ],
        "type": "string",
        "description": "Data format for response."
      },
      "callback": {
        "type": "string",
        "description": "JSONP"
      },
      "fields": {
        "type": "string",
        "description": "Selector specifying which fields to include in a partial response."
      },
      "key": {
        "type": "string",
        "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
      },
      "oauth_token": {
        "type": "string",
        "description": "OAuth 2.0 token for the current user."
      },
      "prettyPrint": {
        "type": "boolean",
        "description": "Returns response with indentations and line breaks."
      },
      "quotaUser": {
        "type": "string",
        "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
      },
      "upload_protocol": {
        "type": "string",
        "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
      },
      "uploadType": {
        "type": "string",
        "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
      },
      "body": {
        "$ref": "#/$defs/PredictRequest"
      }
    },
    "required": [
      "name"
    ],
    "$defs": {
      "PredictRequest": {
        "description": "Request message for PredictionService.Predict.",
        "properties": {
          "params": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Additional domain-specific parameters, any string must be up to 25000 characters long. * For Image Classification: `score_threshold` - (float) A value from 0.0 to 1.0. When the model makes predictions for an image, it will only produce results that have at least this confidence score. The default is 0.5. * For Image Object Detection: `score_threshold` - (float) When Model detects objects on the image, it will only produce bounding boxes which have at least this confidence score. Value in 0 to 1 range, default is 0.5. `max_bounding_box_count` - (int64) No more than this number of bounding boxes will be returned in the response. Default is 100, the requested value may be limited by server. * For Tables: feature_importance - (boolean) Whether feature importance should be populated in the returned TablesAnnotation. The default is false.",
            "type": "object"
          },
          "payload": {
            "$ref": "#/$defs/ExamplePayload"
          }
        },
        "type": "object"
      },
      "ExamplePayload": {
        "description": "Example data used for training or prediction.",
        "properties": {
          "document": {
            "$ref": "#/$defs/Document"
          },
          "image": {
            "$ref": "#/$defs/Image"
          },
          "row": {
            "$ref": "#/$defs/Row"
          },
          "textSnippet": {
            "$ref": "#/$defs/TextSnippet"
          }
        },
        "type": "object"
      },
      "Document": {
        "description": "A structured text document e.g. a PDF.",
        "properties": {
          "documentDimensions": {
            "$ref": "#/$defs/DocumentDimensions"
          },
          "documentText": {
            "$ref": "#/$defs/TextSnippet"
          },
          "inputConfig": {
            "$ref": "#/$defs/DocumentInputConfig"
          },
          "layout": {
            "description": "Describes the layout of the document. Sorted by page_number.",
            "items": {
              "$ref": "#/$defs/Layout"
            },
            "type": "array"
          },
          "pageCount": {
            "description": "Number of pages in the document.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "DocumentDimensions": {
        "description": "Message that describes dimension of a document.",
        "properties": {
          "height": {
            "description": "Height value of the document, works together with the unit.",
            "format": "float",
            "type": "number"
          },
          "unit": {
            "description": "Unit of the dimension.",
            "enum": [
              "DOCUMENT_DIMENSION_UNIT_UNSPECIFIED",
              "INCH",
              "CENTIMETER",
              "POINT"
            ],
            "type": "string"
          },
          "width": {
            "description": "Width value of the document, works together with the unit.",
            "format": "float",
            "type": "number"
          }
        },
        "type": "object"
      },
      "TextSnippet": {
        "description": "A representation of a text snippet.",
        "properties": {
          "content": {
            "description": "Required. The content of the text snippet as a string. Up to 250000 characters long.",
            "type": "string"
          },
          "contentUri": {
            "description": "Output only. HTTP URI where you can download the content.",
            "type": "string"
          },
          "mimeType": {
            "description": "Optional. The format of content. Currently the only two allowed values are \"text/html\" and \"text/plain\". If left blank, the format is automatically determined from the type of the uploaded content.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "DocumentInputConfig": {
        "description": "Input configuration of a Document.",
        "properties": {
          "gcsSource": {
            "$ref": "#/$defs/GcsSource"
          }
        },
        "type": "object"
      },
      "GcsSource": {
        "description": "The Google Cloud Storage location for the input content.",
        "properties": {
          "inputUris": {
            "description": "Required. Google Cloud Storage URIs to input files, up to 2000 characters long. Accepted forms: * Full object path, e.g. gs://bucket/directory/object.csv",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "Layout": {
        "description": "Describes the layout information of a text_segment in the document.",
        "properties": {
          "boundingPoly": {
            "$ref": "#/$defs/BoundingPoly"
          },
          "pageNumber": {
            "description": "Page number of the text_segment in the original document, starts from 1.",
            "format": "int32",
            "type": "integer"
          },
          "textSegment": {
            "$ref": "#/$defs/TextSegment"
          },
          "textSegmentType": {
            "description": "The type of the text_segment in document.",
            "enum": [
              "TEXT_SEGMENT_TYPE_UNSPECIFIED",
              "TOKEN",
              "PARAGRAPH",
              "FORM_FIELD",
              "FORM_FIELD_NAME",
              "FORM_FIELD_CONTENTS",
              "TABLE",
              "TABLE_HEADER",
              "TABLE_ROW",
              "TABLE_CELL"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "BoundingPoly": {
        "description": "A bounding polygon of a detected object on a plane. On output both vertices and normalized_vertices are provided. The polygon is formed by connecting vertices in the order they are listed.",
        "properties": {
          "normalizedVertices": {
            "description": "Output only . The bounding polygon normalized vertices.",
            "items": {
              "$ref": "#/$defs/NormalizedVertex"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "NormalizedVertex": {
        "description": "A vertex represents a 2D point in the image. The normalized vertex coordinates are between 0 to 1 fractions relative to the original plane (image, video). E.g. if the plane (e.g. whole image) would have size 10 x 20 then a point with normalized coordinates (0.1, 0.3) would be at the position (1, 6) on that plane.",
        "properties": {
          "x": {
            "description": "Required. Horizontal coordinate.",
            "format": "float",
            "type": "number"
          },
          "y": {
            "description": "Required. Vertical coordinate.",
            "format": "float",
            "type": "number"
          }
        },
        "type": "object"
      },
      "TextSegment": {
        "description": "A contiguous part of a text (string), assuming it has an UTF-8 NFC encoding.",
        "properties": {
          "content": {
            "description": "Output only. The content of the TextSegment.",
            "type": "string"
          },
          "endOffset": {
            "description": "Required. Zero-based character index of the first character past the end of the text segment (counting character from the beginning of the text). The character at the end_offset is NOT included in the text segment.",
            "format": "int64",
            "type": "string"
          },
          "startOffset": {
            "description": "Required. Zero-based character index of the first character of the text segment (counting characters from the beginning of the text).",
            "format": "int64",
            "type": "string"
          }
        },
        "type": "object"
      },
      "Image": {
        "description": "A representation of an image. Only images up to 30MB in size are supported.",
        "properties": {
          "imageBytes": {
            "description": "Image content represented as a stream of bytes. Note: As with all `bytes` fields, protobuffers use a pure binary representation, whereas JSON representations use base64.",
            "format": "byte",
            "type": "string"
          },
          "inputConfig": {
            "$ref": "#/$defs/InputConfig"
          },
          "thumbnailUri": {
            "description": "Output only. HTTP URI to the thumbnail image.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "InputConfig": {
        "description": "Input configuration for ImportData Action. The format of input depends on dataset_metadata the Dataset into which the import is happening has. As input source the gcs_source is expected, unless specified otherwise. Additionally any input .CSV file by itself must be 100MB or smaller, unless specified otherwise. If an \"example\" file (that is, image, video etc.) with identical content (even if it had different GCS_FILE_PATH) is mentioned multiple times, then its label, bounding boxes etc. are appended. The same file should be always provided with the same ML_USE and GCS_FILE_PATH, if it is not, then these values are nondeterministically selected from the given ones. The formats are represented in EBNF with commas being literal and with non-terminal symbols defined near the end of this comment. The formats are: * For Image Classification: CSV file(s) with each line in format: ML_USE,GCS_FILE_PATH,LABEL,LABEL,... GCS_FILE_PATH leads to image of up to 30MB in size. Supported extensions: .JPEG, .GIF, .PNG, .WEBP, .BMP, .TIFF, .ICO For MULTICLASS classification type, at most one LABEL is allowed per image. If an image has not yet been labeled, then it should be mentioned just once with no LABEL. Some sample rows: TRAIN,gs://folder/image1.jpg,daisy TEST,gs://folder/image2.jpg,dandelion,tulip,rose UNASSIGNED,gs://folder/image3.jpg,daisy UNASSIGNED,gs://folder/image4.jpg * For Image Object Detection: CSV file(s) with each line in format: ML_USE,GCS_FILE_PATH,(LABEL,BOUNDING_BOX | ,,,,,,,) GCS_FILE_PATH leads to image of up to 30MB in size. Supported extensions: .JPEG, .GIF, .PNG. Each image is assumed to be exhaustively labeled. The minimum allowed BOUNDING_BOX edge length is 0.01, and no more than 500 BOUNDING_BOX-es per image are allowed (one BOUNDING_BOX is defined per line). If an image has not yet been labeled, then it should be mentioned just once with no LABEL and the \",,,,,,,\" in place of the BOUNDING_BOX. For images which are known to not contain any bounding boxes, they should be labelled explictly as \"NEGATIVE_IMAGE\", followed by \",,,,,,,\" in place of the BOUNDING_BOX. Sample rows: TRAIN,gs://folder/image1.png,car,0.1,0.1,,,0.3,0.3,, TRAIN,gs://folder/image1.png,bike,.7,.6,,,.8,.9,, UNASSIGNED,gs://folder/im2.png,car,0.1,0.1,0.2,0.1,0.2,0.3,0.1,0.3 TEST,gs://folder/im3.png,,,,,,,,, TRAIN,gs://folder/im4.png,NEGATIVE_IMAGE,,,,,,,,, * For Video Classification: CSV file(s) with each line in format: ML_USE,GCS_FILE_PATH where ML_USE VALIDATE value should not be used. The GCS_FILE_PATH should lead to another .csv file which describes examples that have given ML_USE, using the following row format: GCS_FILE_PATH,(LABEL,TIME_SEGMENT_START,TIME_SEGMENT_END | ,,) Here GCS_FILE_PATH leads to a video of up to 50GB in size and up to 3h duration. Supported extensions: .MOV, .MPEG4, .MP4, .AVI. TIME_SEGMENT_START and TIME_SEGMENT_END must be within the length of the video, and end has to be after the start. Any segment of a video which has one or more labels on it, is considered a hard negative for all other labels. Any segment with no labels on it is considered to be unknown. If a whole video is unknown, then it shuold be mentioned just once with \",,\" in place of LABEL, TIME_SEGMENT_START,TIME_SEGMENT_END. Sample top level CSV file: TRAIN,gs://folder/train_videos.csv TEST,gs://folder/test_videos.csv UNASSIGNED,gs://folder/other_videos.csv Sample rows of a CSV file for a particular ML_USE: gs://folder/video1.avi,car,120,180.000021 gs://folder/video1.avi,bike,150,180.000021 gs://folder/vid2.avi,car,0,60.5 gs://folder/vid3.avi,,, * For Video Object Tracking: CSV file(s) with each line in format: ML_USE,GCS_FILE_PATH where ML_USE VALIDATE value should not be used. The GCS_FILE_PATH should lead to another .csv file which describes examples that have given ML_USE, using one of the following row format: GCS_FILE_PATH,LABEL,[INSTANCE_ID],TIMESTAMP,BOUNDING_BOX or GCS_FILE_PATH,,,,,,,,,, Here GCS_FILE_PATH leads to a video of up to 50GB in size and up to 3h duration. Supported extensions: .MOV, .MPEG4, .MP4, .AVI. Providing INSTANCE_IDs can help to obtain a better model. When a specific labeled entity leaves the video frame, and shows up afterwards it is not required, albeit preferable, that the same INSTANCE_ID is given to it. TIMESTAMP must be within the length of the video, the BOUNDING_BOX is assumed to be drawn on the closest video's frame to the TIMESTAMP. Any mentioned by the TIMESTAMP frame is expected to be exhaustively labeled and no more than 500 BOUNDING_BOX-es per frame are allowed. If a whole video is unknown, then it should be mentioned just once with \",,,,,,,,,,\" in place of LABEL, [INSTANCE_ID],TIMESTAMP,BOUNDING_BOX. Sample top level CSV file: TRAIN,gs://folder/train_videos.csv TEST,gs://folder/test_videos.csv UNASSIGNED,gs://folder/other_videos.csv Seven sample rows of a CSV file for a particular ML_USE: gs://folder/video1.avi,car,1,12.10,0.8,0.8,0.9,0.8,0.9,0.9,0.8,0.9 gs://folder/video1.avi,car,1,12.90,0.4,0.8,0.5,0.8,0.5,0.9,0.4,0.9 gs://folder/video1.avi,car,2,12.10,.4,.2,.5,.2,.5,.3,.4,.3 gs://folder/video1.avi,car,2,12.90,.8,.2,,,.9,.3,, gs://folder/video1.avi,bike,,12.50,.45,.45,,,.55,.55,, gs://folder/video2.avi,car,1,0,.1,.9,,,.9,.1,, gs://folder/video2.avi,,,,,,,,,,, * For Text Extraction: CSV file(s) with each line in format: ML_USE,GCS_FILE_PATH GCS_FILE_PATH leads to a .JSONL (that is, JSON Lines) file which either imports text in-line or as documents. Any given .JSONL file must be 100MB or smaller. The in-line .JSONL file contains, per line, a proto that wraps a TextSnippet proto (in json representation) followed by one or more AnnotationPayload protos (called annotations), which have display_name and text_extraction detail populated. The given text is expected to be annotated exhaustively, for example, if you look for animals and text contains \"dolphin\" that is not labeled, then \"dolphin\" is assumed to not be an animal. Any given text snippet content must be 10KB or smaller, and also be UTF-8 NFC encoded (ASCII already is). The document .JSONL file contains, per line, a proto that wraps a Document proto. The Document proto must have either document_text or input_config set. In document_text case, the Document proto may also contain the spatial information of the document, including layout, document dimension and page number. In input_config case, only PDF documents are supported now, and each document may be up to 2MB large. Currently, annotations on documents cannot be specified at import. Three sample CSV rows: TRAIN,gs://folder/file1.jsonl VALIDATE,gs://folder/file2.jsonl TEST,gs://folder/file3.jsonl Sample in-line JSON Lines file for entity extraction (presented here with artificial line breaks, but the only actual line break is denoted by \\n).: { \"document\": { \"document_text\": {\"content\": \"dog cat\"} \"layout\": [ { \"text_segment\": { \"start_offset\": 0, \"end_offset\": 3, }, \"page_number\": 1, \"bounding_poly\": { \"normalized_vertices\": [ {\"x\": 0.1, \"y\": 0.1}, {\"x\": 0.1, \"y\": 0.3}, {\"x\": 0.3, \"y\": 0.3}, {\"x\": 0.3, \"y\": 0.1}, ], }, \"text_segment_type\": TOKEN, }, { \"text_segment\": { \"start_offset\": 4, \"end_offset\": 7, }, \"page_number\": 1, \"bounding_poly\": { \"normalized_vertices\": [ {\"x\": 0.4, \"y\": 0.1}, {\"x\": 0.4, \"y\": 0.3}, {\"x\": 0.8, \"y\": 0.3}, {\"x\": 0.8, \"y\": 0.1}, ], }, \"text_segment_type\": TOKEN, } ], \"document_dimensions\": { \"width\": 8.27, \"height\": 11.69, \"unit\": INCH, } \"page_count\": 1, }, \"annotations\": [ { \"display_name\": \"animal\", \"text_extraction\": {\"text_segment\": {\"start_offset\": 0, \"end_offset\": 3}} }, { \"display_name\": \"animal\", \"text_extraction\": {\"text_segment\": {\"start_offset\": 4, \"end_offset\": 7}} } ], }\\n { \"text_snippet\": { \"content\": \"This dog is good.\" }, \"annotations\": [ { \"display_name\": \"animal\", \"text_extraction\": { \"text_segment\": {\"start_offset\": 5, \"end_offset\": 8} } } ] } Sample document JSON Lines file (presented here with artificial line breaks, but the only actual line break is denoted by \\n).: { \"document\": { \"input_config\": { \"gcs_source\": { \"input_uris\": [ \"gs://folder/document1.pdf\" ] } } } }\\n { \"document\": { \"input_config\": { \"gcs_source\": { \"input_uris\": [ \"gs://folder/document2.pdf\" ] } } } } * For Text Classification: CSV file(s) with each line in format: ML_USE,(TEXT_SNIPPET | GCS_FILE_PATH),LABEL,LABEL,... TEXT_SNIPPET and GCS_FILE_PATH are distinguished by a pattern. If the column content is a valid gcs file path, i.e. prefixed by \"gs://\", it will be treated as a GCS_FILE_PATH, else if the content is enclosed within double quotes (\"\"), it is treated as a TEXT_SNIPPET. In the GCS_FILE_PATH case, the path must lead to a .txt file with UTF-8 encoding, for example, \"gs://folder/content.txt\", and the content in it is extracted as a text snippet. In TEXT_SNIPPET case, the column content excluding quotes is treated as to be imported text snippet. In both cases, the text snippet/file size must be within 128kB. Maximum 100 unique labels are allowed per CSV row. Sample rows: TRAIN,\"They have bad food and very rude\",RudeService,BadFood TRAIN,gs://folder/content.txt,SlowService TEST,\"Typically always bad service there.\",RudeService VALIDATE,\"Stomach ache to go.\",BadFood * For Text Sentiment: CSV file(s) with each line in format: ML_USE,(TEXT_SNIPPET | GCS_FILE_PATH),SENTIMENT TEXT_SNIPPET and GCS_FILE_PATH are distinguished by a pattern. If the column content is a valid gcs file path, that is, prefixed by \"gs://\", it is treated as a GCS_FILE_PATH, otherwise it is treated as a TEXT_SNIPPET. In the GCS_FILE_PATH case, the path must lead to a .txt file with UTF-8 encoding, for example, \"gs://folder/content.txt\", and the content in it is extracted as a text snippet. In TEXT_SNIPPET case, the column content itself is treated as to be imported text snippet. In both cases, the text snippet must be up to 500 characters long. Sample rows: TRAIN,\"@freewrytin this is way too good for your product\",2 TRAIN,\"I need this product so bad\",3 TEST,\"Thank you for this product.\",4 VALIDATE,gs://folder/content.txt,2 * For Tables: Either gcs_source or bigquery_source can be used. All inputs is concatenated into a single primary_table For gcs_source: CSV file(s), where the first row of the first file is the header, containing unique column names. If the first row of a subsequent file is the same as the header, then it is also treated as a header. All other rows contain values for the corresponding columns. Each .CSV file by itself must be 10GB or smaller, and their total size must be 100GB or smaller. First three sample rows of a CSV file: \"Id\",\"First Name\",\"Last Name\",\"Dob\",\"Addresses\" \"1\",\"John\",\"Doe\",\"1968-01-22\",\"[{\"status\":\"current\",\"address\":\"123_First_Avenue\",\"city\":\"Seattle\",\"state\":\"WA\",\"zip\":\"11111\",\"numberOfYears\":\"1\"},{\"status\":\"previous\",\"address\":\"456_Main_Street\",\"city\":\"Portland\",\"state\":\"OR\",\"zip\":\"22222\",\"numberOfYears\":\"5\"}]\" \"2\",\"Jane\",\"Doe\",\"1980-10-16\",\"[{\"status\":\"current\",\"address\":\"789_Any_Avenue\",\"city\":\"Albany\",\"state\":\"NY\",\"zip\":\"33333\",\"numberOfYears\":\"2\"},{\"status\":\"previous\",\"address\":\"321_Main_Street\",\"city\":\"Hoboken\",\"state\":\"NJ\",\"zip\":\"44444\",\"numberOfYears\":\"3\"}]} For bigquery_source: An URI of a BigQuery table. The user data size of the BigQuery table must be 100GB or smaller. An imported table must have between 2 and 1,000 columns, inclusive, and between 1000 and 100,000,000 rows, inclusive. There are at most 5 import data running in parallel. Definitions: ML_USE = \"TRAIN\" | \"VALIDATE\" | \"TEST\" | \"UNASSIGNED\" Describes how the given example (file) should be used for model training. \"UNASSIGNED\" can be used when user has no preference. GCS_FILE_PATH = A path to file on GCS, e.g. \"gs://folder/image1.png\". LABEL = A display name of an object on an image, video etc., e.g. \"dog\". Must be up to 32 characters long and can consist only of ASCII Latin letters A-Z and a-z, underscores(_), and ASCII digits 0-9. For each label an AnnotationSpec is created which display_name becomes the label; AnnotationSpecs are given back in predictions. INSTANCE_ID = A positive integer that identifies a specific instance of a labeled entity on an example. Used e.g. to track two cars on a video while being able to tell apart which one is which. BOUNDING_BOX = VERTEX,VERTEX,VERTEX,VERTEX | VERTEX,,,VERTEX,, A rectangle parallel to the frame of the example (image, video). If 4 vertices are given they are connected by edges in the order provided, if 2 are given they are recognized as diagonally opposite vertices of the rectangle. VERTEX = COORDINATE,COORDINATE First coordinate is horizontal (x), the second is vertical (y). COORDINATE = A float in 0 to 1 range, relative to total length of image or video in given dimension. For fractions the leading non-decimal 0 can be omitted (i.e. 0.3 = .3). Point 0,0 is in top left. TIME_SEGMENT_START = TIME_OFFSET Expresses a beginning, inclusive, of a time segment within an example that has a time dimension (e.g. video). TIME_SEGMENT_END = TIME_OFFSET Expresses an end, exclusive, of a time segment within an example that has a time dimension (e.g. video). TIME_OFFSET = A number of seconds as measured from the start of an example (e.g. video). Fractions are allowed, up to a microsecond precision. \"inf\" is allowed, and it means the end of the example. TEXT_SNIPPET = A content of a text snippet, UTF-8 encoded, enclosed within double quotes (\"\"). SENTIMENT = An integer between 0 and Dataset.text_sentiment_dataset_metadata.sentiment_max (inclusive). Describes the ordinal of the sentiment - higher value means a more positive sentiment. All the values are completely relative, i.e. neither 0 needs to mean a negative or neutral sentiment nor sentiment_max needs to mean a positive one - it is just required that 0 is the least positive sentiment in the data, and sentiment_max is the most positive one. The SENTIMENT shouldn't be confused with \"score\" or \"magnitude\" from the previous Natural Language Sentiment Analysis API. All SENTIMENT values between 0 and sentiment_max must be represented in the imported data. On prediction the same 0 to sentiment_max range will be used. The difference between neighboring sentiment values needs not to be uniform, e.g. 1 and 2 may be similar whereas the difference between 2 and 3 may be huge. Errors: If any of the provided CSV files can't be parsed or if more than certain percent of CSV rows cannot be processed then the operation fails and nothing is imported. Regardless of overall success or failure the per-row failures, up to a certain count cap, is listed in Operation.metadata.partial_failures. ",
        "properties": {
          "bigquerySource": {
            "$ref": "#/$defs/BigQuerySource"
          },
          "gcsSource": {
            "$ref": "#/$defs/GcsSource"
          },
          "params": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Additional domain-specific parameters describing the semantic of the imported data, any string must be up to 25000 characters long. * For Tables: `schema_inference_version` - (integer) Required. The version of the algorithm that should be used for the initial inference of the schema (columns' DataTypes) of the table the data is being imported into. Allowed values: \"1\".",
            "type": "object"
          }
        },
        "type": "object"
      },
      "BigQuerySource": {
        "description": "The BigQuery location for the input content.",
        "properties": {
          "inputUri": {
            "description": "Required. BigQuery URI to a table, up to 2000 characters long. Accepted forms: * BigQuery path e.g. bq://projectId.bqDatasetId.bqTableId",
            "type": "string"
          }
        },
        "type": "object"
      },
      "Row": {
        "description": "A representation of a row in a relational table.",
        "properties": {
          "columnSpecIds": {
            "description": "The resource IDs of the column specs describing the columns of the row. If set must contain, but possibly in a different order, all input feature column_spec_ids of the Model this row is being passed to. Note: The below `values` field must match order of this field, if this field is set.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "values": {
            "description": "Required. The values of the row cells, given in the same order as the column_spec_ids, or, if not set, then in the same order as input feature column_specs of the Model this row is being passed to.",
            "items": {},
            "type": "array"
          }
        },
        "type": "object"
      }
    }
  },
  "handler": "http",
  "request": {
    "method": "POST",
    "url": {
      "$uri": "https://automl.googleapis.com//v1beta1/{name}:predict{?$.xgafv,access_token,alt,callback,fields,key,oauth_token,prettyPrint,quotaUser,upload_protocol,uploadType}"
    },
    "body": {
      "$": "body",
      "encode": "json"
    }
  },
  "responses": {
    "200": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "Response message for PredictionService.Predict.",
        "**Key properties:**",
        {
          "$ul": [
            "**metadata**: Additional domain-specific prediction response metadata. * For Image Object Detection: `max_bounding_box_count` - (int64) At most that many bounding boxes per image could have been returned. * For Text Sentiment: `sentiment_score` - (float, deprecated) A value between -1 and 1, -1 maps to least positive sentiment, while 1 maps to the most positive one and the higher the score, the more positive the sentiment in the document is. Yet these values are relative to the training data, so e.g. if all data was positive then -1 will be also positive (though the least). The sentiment_score shouldn't be confused with \"score\" or \"magnitude\" from the previous Natural Language Sentiment Analysis API.",
            "**payload**: Prediction result. Translation and Text Sentiment will return precisely one payload.",
            [
              "**preprocessedInput**: Example data used for training or prediction.",
              {
                "$ul": [
                  [
                    "**document**: A structured text document e.g. a PDF.",
                    {
                      "$ul": [
                        [
                          "**documentDimensions**: Message that describes dimension of a document.",
                          {
                            "$ul": [
                              "**height**: Height value of the document, works together with the unit.",
                              "**unit**: Unit of the dimension.",
                              "**width**: Width value of the document, works together with the unit."
                            ]
                          }
                        ],
                        [
                          "**documentText**: A representation of a text snippet.",
                          {
                            "$ul": [
                              "**content**: Required. The content of the text snippet as a string. Up to 250000 characters long.",
                              "**contentUri**: Output only. HTTP URI where you can download the content.",
                              "**mimeType**: Optional. The format of content. Currently the only two allowed values are \"text/html\" and \"text/plain\". If left blank, the format is automatically determined from the type of the uploaded content."
                            ]
                          }
                        ],
                        [
                          "**inputConfig**: Input configuration of a Document.",
                          {
                            "$ul": [
                              [
                                "**gcsSource**: The Google Cloud Storage location for the input content.",
                                {
                                  "$ul": [
                                    "**inputUris**: Required. Google Cloud Storage URIs to input files, up to 2000 characters long. Accepted forms: * Full object path, e.g. gs://bucket/directory/object.csv"
                                  ]
                                }
                              ]
                            ]
                          }
                        ],
                        "**layout**: Describes the layout of the document. Sorted by page_number.",
                        "**pageCount**: Number of pages in the document."
                      ]
                    }
                  ],
                  [
                    "**image**: A representation of an image. Only images up to 30MB in size are supported.",
                    {
                      "$ul": [
                        "**imageBytes**: Image content represented as a stream of bytes. Note: As with all `bytes` fields, protobuffers use a pure binary representation, whereas JSON representations use base64.",
                        [
                          "**inputConfig**: Input configuration for ImportData Action. The format of input depends on dataset_metadata the Dataset into which the import is happening has. As input source the gcs_source is expected, unless specified otherwise. Additionally any input .CSV file by itself must be 100MB or smaller, unless specified otherwise. If an \"example\" file (that is, image, video etc.) with identical content (even if it had different GCS_FILE_PATH) is mentioned multiple times, then its label, bounding boxes etc. are appended. The same file should be always provided with the same ML_USE and GCS_FILE_PATH, if it is not, then these values are nondeterministically selected from the given ones. The formats are represented in EBNF with commas being literal and with non-terminal symbols defined near the end of this comment. The formats are: * For Image Classification: CSV file(s) with each line in format: ML_USE,GCS_FILE_PATH,LABEL,LABEL,... GCS_FILE_PATH leads to image of up to 30MB in size. Supported extensions: .JPEG, .GIF, .PNG, .WEBP, .BMP, .TIFF, .ICO For MULTICLASS classification type, at most one LABEL is allowed per image. If an image has not yet been labeled, then it should be mentioned just once with no LABEL. Some sample rows: TRAIN,gs://folder/image1.jpg,daisy TEST,gs://folder/image2.jpg,dandelion,tulip,rose UNASSIGNED,gs://folder/image3.jpg,daisy UNASSIGNED,gs://folder/image4.jpg * For Image Object Detection: CSV file(s) with each line in format: ML_USE,GCS_FILE_PATH,(LABEL,BOUNDING_BOX | ,,,,,,,) GCS_FILE_PATH leads to image of up to 30MB in size. Supported extensions: .JPEG, .GIF, .PNG. Each image is assumed to be exhaustively labeled. The minimum allowed BOUNDING_BOX edge length is 0.01, and no more than 500 BOUNDING_BOX-es per image are allowed (one BOUNDING_BOX is defined per line). If an image has not yet been labeled, then it should be mentioned just once with no LABEL and the \",,,,,,,\" in place of the BOUNDING_BOX. For images which are known to not contain any bounding boxes, they should be labelled explictly as \"NEGATIVE_IMAGE\", followed by \",,,,,,,\" in place of the BOUNDING_BOX. Sample rows: TRAIN,gs://folder/image1.png,car,0.1,0.1,,,0.3,0.3,, TRAIN,gs://folder/image1.png,bike,.7,.6,,,.8,.9,, UNASSIGNED,gs://folder/im2.png,car,0.1,0.1,0.2,0.1,0.2,0.3,0.1,0.3 TEST,gs://folder/im3.png,,,,,,,,, TRAIN,gs://folder/im4.png,NEGATIVE_IMAGE,,,,,,,,, * For Video Classification: CSV file(s) with each line in format: ML_USE,GCS_FILE_PATH where ML_USE VALIDATE value should not be used. The GCS_FILE_PATH should lead to another .csv file which describes examples that have given ML_USE, using the following row format: GCS_FILE_PATH,(LABEL,TIME_SEGMENT_START,TIME_SEGMENT_END | ,,) Here GCS_FILE_PATH leads to a video of up to 50GB in size and up to 3h duration. Supported extensions: .MOV, .MPEG4, .MP4, .AVI. TIME_SEGMENT_START and TIME_SEGMENT_END must be within the length of the video, and end has to be after the start. Any segment of a video which has one or more labels on it, is considered a hard negative for all other labels. Any segment with no labels on it is considered to be unknown. If a whole video is unknown, then it shuold be mentioned just once with \",,\" in place of LABEL, TIME_SEGMENT_START,TIME_SEGMENT_END. Sample top level CSV file: TRAIN,gs://folder/train_videos.csv TEST,gs://folder/test_videos.csv UNASSIGNED,gs://folder/other_videos.csv Sample rows of a CSV file for a particular ML_USE: gs://folder/video1.avi,car,120,180.000021 gs://folder/video1.avi,bike,150,180.000021 gs://folder/vid2.avi,car,0,60.5 gs://folder/vid3.avi,,, * For Video Object Tracking: CSV file(s) with each line in format: ML_USE,GCS_FILE_PATH where ML_USE VALIDATE value should not be used. The GCS_FILE_PATH should lead to another .csv file which describes examples that have given ML_USE, using one of the following row format: GCS_FILE_PATH,LABEL,[INSTANCE_ID],TIMESTAMP,BOUNDING_BOX or GCS_FILE_PATH,,,,,,,,,, Here GCS_FILE_PATH leads to a video of up to 50GB in size and up to 3h duration. Supported extensions: .MOV, .MPEG4, .MP4, .AVI. Providing INSTANCE_IDs can help to obtain a better model. When a specific labeled entity leaves the video frame, and shows up afterwards it is not required, albeit preferable, that the same INSTANCE_ID is given to it. TIMESTAMP must be within the length of the video, the BOUNDING_BOX is assumed to be drawn on the closest video's frame to the TIMESTAMP. Any mentioned by the TIMESTAMP frame is expected to be exhaustively labeled and no more than 500 BOUNDING_BOX-es per frame are allowed. If a whole video is unknown, then it should be mentioned just once with \",,,,,,,,,,\" in place of LABEL, [INSTANCE_ID],TIMESTAMP,BOUNDING_BOX. Sample top level CSV file: TRAIN,gs://folder/train_videos.csv TEST,gs://folder/test_videos.csv UNASSIGNED,gs://folder/other_videos.csv Seven sample rows of a CSV file for a particular ML_USE: gs://folder/video1.avi,car,1,12.10,0.8,0.8,0.9,0.8,0.9,0.9,0.8,0.9 gs://folder/video1.avi,car,1,12.90,0.4,0.8,0.5,0.8,0.5,0.9,0.4,0.9 gs://folder/video1.avi,car,2,12.10,.4,.2,.5,.2,.5,.3,.4,.3 gs://folder/video1.avi,car,2,12.90,.8,.2,,,.9,.3,, gs://folder/video1.avi,bike,,12.50,.45,.45,,,.55,.55,, gs://folder/video2.avi,car,1,0,.1,.9,,,.9,.1,, gs://folder/video2.avi,,,,,,,,,,, * For Text Extraction: CSV file(s) with each line in format: ML_USE,GCS_FILE_PATH GCS_FILE_PATH leads to a .JSONL (that is, JSON Lines) file which either imports text in-line or as documents. Any given .JSONL file must be 100MB or smaller. The in-line .JSONL file contains, per line, a proto that wraps a TextSnippet proto (in json representation) followed by one or more AnnotationPayload protos (called annotations), which have display_name and text_extraction detail populated. The given text is expected to be annotated exhaustively, for example, if you look for animals and text contains \"dolphin\" that is not labeled, then \"dolphin\" is assumed to not be an animal. Any given text snippet content must be 10KB or smaller, and also be UTF-8 NFC encoded (ASCII already is). The document .JSONL file contains, per line, a proto that wraps a Document proto. The Document proto must have either document_text or input_config set. In document_text case, the Document proto may also contain the spatial information of the document, including layout, document dimension and page number. In input_config case, only PDF documents are supported now, and each document may be up to 2MB large. Currently, annotations on documents cannot be specified at import. Three sample CSV rows: TRAIN,gs://folder/file1.jsonl VALIDATE,gs://folder/file2.jsonl TEST,gs://folder/file3.jsonl Sample in-line JSON Lines file for entity extraction (presented here with artificial line breaks, but the only actual line break is denoted by \\n).: { \"document\": { \"document_text\": {\"content\": \"dog cat\"} \"layout\": [ { \"text_segment\": { \"start_offset\": 0, \"end_offset\": 3, }, \"page_number\": 1, \"bounding_poly\": { \"normalized_vertices\": [ {\"x\": 0.1, \"y\": 0.1}, {\"x\": 0.1, \"y\": 0.3}, {\"x\": 0.3, \"y\": 0.3}, {\"x\": 0.3, \"y\": 0.1}, ], }, \"text_segment_type\": TOKEN, }, { \"text_segment\": { \"start_offset\": 4, \"end_offset\": 7, }, \"page_number\": 1, \"bounding_poly\": { \"normalized_vertices\": [ {\"x\": 0.4, \"y\": 0.1}, {\"x\": 0.4, \"y\": 0.3}, {\"x\": 0.8, \"y\": 0.3}, {\"x\": 0.8, \"y\": 0.1}, ], }, \"text_segment_type\": TOKEN, } ], \"document_dimensions\": { \"width\": 8.27, \"height\": 11.69, \"unit\": INCH, } \"page_count\": 1, }, \"annotations\": [ { \"display_name\": \"animal\", \"text_extraction\": {\"text_segment\": {\"start_offset\": 0, \"end_offset\": 3}} }, { \"display_name\": \"animal\", \"text_extraction\": {\"text_segment\": {\"start_offset\": 4, \"end_offset\": 7}} } ], }\\n { \"text_snippet\": { \"content\": \"This dog is good.\" }, \"annotations\": [ { \"display_name\": \"animal\", \"text_extraction\": { \"text_segment\": {\"start_offset\": 5, \"end_offset\": 8} } } ] } Sample document JSON Lines file (presented here with artificial line breaks, but the only actual line break is denoted by \\n).: { \"document\": { \"input_config\": { \"gcs_source\": { \"input_uris\": [ \"gs://folder/document1.pdf\" ] } } } }\\n { \"document\": { \"input_config\": { \"gcs_source\": { \"input_uris\": [ \"gs://folder/document2.pdf\" ] } } } } * For Text Classification: CSV file(s) with each line in format: ML_USE,(TEXT_SNIPPET | GCS_FILE_PATH),LABEL,LABEL,... TEXT_SNIPPET and GCS_FILE_PATH are distinguished by a pattern. If the column content is a valid gcs file path, i.e. prefixed by \"gs://\", it will be treated as a GCS_FILE_PATH, else if the content is enclosed within double quotes (\"\"), it is treated as a TEXT_SNIPPET. In the GCS_FILE_PATH case, the path must lead to a .txt file with UTF-8 encoding, for example, \"gs://folder/content.txt\", and the content in it is extracted as a text snippet. In TEXT_SNIPPET case, the column content excluding quotes is treated as to be imported text snippet. In both cases, the text snippet/file size must be within 128kB. Maximum 100 unique labels are allowed per CSV row. Sample rows: TRAIN,\"They have bad food and very rude\",RudeService,BadFood TRAIN,gs://folder/content.txt,SlowService TEST,\"Typically always bad service there.\",RudeService VALIDATE,\"Stomach ache to go.\",BadFood * For Text Sentiment: CSV file(s) with each line in format: ML_USE,(TEXT_SNIPPET | GCS_FILE_PATH),SENTIMENT TEXT_SNIPPET and GCS_FILE_PATH are distinguished by a pattern. If the column content is a valid gcs file path, that is, prefixed by \"gs://\", it is treated as a GCS_FILE_PATH, otherwise it is treated as a TEXT_SNIPPET. In the GCS_FILE_PATH case, the path must lead to a .txt file with UTF-8 encoding, for example, \"gs://folder/content.txt\", and the content in it is extracted as a text snippet. In TEXT_SNIPPET case, the column content itself is treated as to be imported text snippet. In both cases, the text snippet must be up to 500 characters long. Sample rows: TRAIN,\"@freewrytin this is way too good for your product\",2 TRAIN,\"I need this product so bad\",3 TEST,\"Thank you for this product.\",4 VALIDATE,gs://folder/content.txt,2 * For Tables: Either gcs_source or bigquery_source can be used. All inputs is concatenated into a single primary_table For gcs_source: CSV file(s), where the first row of the first file is the header, containing unique column names. If the first row of a subsequent file is the same as the header, then it is also treated as a header. All other rows contain values for the corresponding columns. Each .CSV file by itself must be 10GB or smaller, and their total size must be 100GB or smaller. First three sample rows of a CSV file: \"Id\",\"First Name\",\"Last Name\",\"Dob\",\"Addresses\" \"1\",\"John\",\"Doe\",\"1968-01-22\",\"[{\"status\":\"current\",\"address\":\"123_First_Avenue\",\"city\":\"Seattle\",\"state\":\"WA\",\"zip\":\"11111\",\"numberOfYears\":\"1\"},{\"status\":\"previous\",\"address\":\"456_Main_Street\",\"city\":\"Portland\",\"state\":\"OR\",\"zip\":\"22222\",\"numberOfYears\":\"5\"}]\" \"2\",\"Jane\",\"Doe\",\"1980-10-16\",\"[{\"status\":\"current\",\"address\":\"789_Any_Avenue\",\"city\":\"Albany\",\"state\":\"NY\",\"zip\":\"33333\",\"numberOfYears\":\"2\"},{\"status\":\"previous\",\"address\":\"321_Main_Street\",\"city\":\"Hoboken\",\"state\":\"NJ\",\"zip\":\"44444\",\"numberOfYears\":\"3\"}]} For bigquery_source: An URI of a BigQuery table. The user data size of the BigQuery table must be 100GB or smaller. An imported table must have between 2 and 1,000 columns, inclusive, and between 1000 and 100,000,000 rows, inclusive. There are at most 5 import data running in parallel. Definitions: ML_USE = \"TRAIN\" | \"VALIDATE\" | \"TEST\" | \"UNASSIGNED\" Describes how the given example (file) should be used for model training. \"UNASSIGNED\" can be used when user has no preference. GCS_FILE_PATH = A path to file on GCS, e.g. \"gs://folder/image1.png\". LABEL = A display name of an object on an image, video etc., e.g. \"dog\". Must be up to 32 characters long and can consist only of ASCII Latin letters A-Z and a-z, underscores(_), and ASCII digits 0-9. For each label an AnnotationSpec is created which display_name becomes the label; AnnotationSpecs are given back in predictions. INSTANCE_ID = A positive integer that identifies a specific instance of a labeled entity on an example. Used e.g. to track two cars on a video while being able to tell apart which one is which. BOUNDING_BOX = VERTEX,VERTEX,VERTEX,VERTEX | VERTEX,,,VERTEX,, A rectangle parallel to the frame of the example (image, video). If 4 vertices are given they are connected by edges in the order provided, if 2 are given they are recognized as diagonally opposite vertices of the rectangle. VERTEX = COORDINATE,COORDINATE First coordinate is horizontal (x), the second is vertical (y). COORDINATE = A float in 0 to 1 range, relative to total length of image or video in given dimension. For fractions the leading non-decimal 0 can be omitted (i.e. 0.3 = .3). Point 0,0 is in top left. TIME_SEGMENT_START = TIME_OFFSET Expresses a beginning, inclusive, of a time segment within an example that has a time dimension (e.g. video). TIME_SEGMENT_END = TIME_OFFSET Expresses an end, exclusive, of a time segment within an example that has a time dimension (e.g. video). TIME_OFFSET = A number of seconds as measured from the start of an example (e.g. video). Fractions are allowed, up to a microsecond precision. \"inf\" is allowed, and it means the end of the example. TEXT_SNIPPET = A content of a text snippet, UTF-8 encoded, enclosed within double quotes (\"\"). SENTIMENT = An integer between 0 and Dataset.text_sentiment_dataset_metadata.sentiment_max (inclusive). Describes the ordinal of the sentiment - higher value means a more positive sentiment. All the values are completely relative, i.e. neither 0 needs to mean a negative or neutral sentiment nor sentiment_max needs to mean a positive one - it is just required that 0 is the least positive sentiment in the data, and sentiment_max is the most positive one. The SENTIMENT shouldn't be confused with \"score\" or \"magnitude\" from the previous Natural Language Sentiment Analysis API. All SENTIMENT values between 0 and sentiment_max must be represented in the imported data. On prediction the same 0 to sentiment_max range will be used. The difference between neighboring sentiment values needs not to be uniform, e.g. 1 and 2 may be similar whereas the difference between 2 and 3 may be huge. Errors: If any of the provided CSV files can't be parsed or if more than certain percent of CSV rows cannot be processed then the operation fails and nothing is imported. Regardless of overall success or failure the per-row failures, up to a certain count cap, is listed in Operation.metadata.partial_failures. ",
                          {
                            "$ul": [
                              [
                                "**bigquerySource**: The BigQuery location for the input content.",
                                {
                                  "$ul": [
                                    "**inputUri**: Required. BigQuery URI to a table, up to 2000 characters long. Accepted forms: * BigQuery path e.g. bq://projectId.bqDatasetId.bqTableId"
                                  ]
                                }
                              ],
                              [
                                "**gcsSource**: The Google Cloud Storage location for the input content.",
                                {
                                  "$ul": [
                                    "**inputUris**: Required. Google Cloud Storage URIs to input files, up to 2000 characters long. Accepted forms: * Full object path, e.g. gs://bucket/directory/object.csv"
                                  ]
                                }
                              ],
                              "**params**: Additional domain-specific parameters describing the semantic of the imported data, any string must be up to 25000 characters long. * For Tables: `schema_inference_version` - (integer) Required. The version of the algorithm that should be used for the initial inference of the schema (columns' DataTypes) of the table the data is being imported into. Allowed values: \"1\"."
                            ]
                          }
                        ],
                        "**thumbnailUri**: Output only. HTTP URI to the thumbnail image."
                      ]
                    }
                  ],
                  [
                    "**row**: A representation of a row in a relational table.",
                    {
                      "$ul": [
                        "**columnSpecIds**: The resource IDs of the column specs describing the columns of the row. If set must contain, but possibly in a different order, all input feature column_spec_ids of the Model this row is being passed to. Note: The below `values` field must match order of this field, if this field is set.",
                        "**values**: Required. The values of the row cells, given in the same order as the column_spec_ids, or, if not set, then in the same order as input feature column_specs of the Model this row is being passed to."
                      ]
                    }
                  ],
                  [
                    "**textSnippet**: A representation of a text snippet.",
                    {
                      "$ul": [
                        "**content**: Required. The content of the text snippet as a string. Up to 250000 characters long.",
                        "**contentUri**: Output only. HTTP URI where you can download the content.",
                        "**mimeType**: Optional. The format of content. Currently the only two allowed values are \"text/html\" and \"text/plain\". If left blank, the format is automatically determined from the type of the uploaded content."
                      ]
                    }
                  ]
                ]
              }
            ]
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    }
  }
}
