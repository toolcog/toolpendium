{
  "name": "automl_projects_locations_models_create",
  "description": "Creates a model. Returns a Model in the response field when it completes. When you create a model, several model evaluations are created for it: a global evaluation, and one evaluation for each annotation spec.",
  "parameters": {
    "type": "object",
    "properties": {
      "parent": {
        "type": "string",
        "description": "Required. Resource name of the parent project where the model is being created."
      },
      "$.xgafv": {
        "enum": [
          "1",
          "2"
        ],
        "type": "string",
        "description": "V1 error format."
      },
      "access_token": {
        "type": "string",
        "description": "OAuth access token."
      },
      "alt": {
        "enum": [
          "json",
          "media",
          "proto"
        ],
        "type": "string",
        "description": "Data format for response."
      },
      "callback": {
        "type": "string",
        "description": "JSONP"
      },
      "fields": {
        "type": "string",
        "description": "Selector specifying which fields to include in a partial response."
      },
      "key": {
        "type": "string",
        "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
      },
      "oauth_token": {
        "type": "string",
        "description": "OAuth 2.0 token for the current user."
      },
      "prettyPrint": {
        "type": "boolean",
        "description": "Returns response with indentations and line breaks."
      },
      "quotaUser": {
        "type": "string",
        "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
      },
      "upload_protocol": {
        "type": "string",
        "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
      },
      "uploadType": {
        "type": "string",
        "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
      },
      "body": {
        "$ref": "#/$defs/Model"
      }
    },
    "required": [
      "parent"
    ],
    "$defs": {
      "Model": {
        "description": "API proto representing a trained machine learning model.",
        "properties": {
          "createTime": {
            "description": "Output only. Timestamp when the model training finished and can be used for prediction.",
            "format": "google-datetime",
            "type": "string"
          },
          "datasetId": {
            "description": "Required. The resource ID of the dataset used to create the model. The dataset must come from the same ancestor project and location.",
            "type": "string"
          },
          "deploymentState": {
            "description": "Output only. Deployment state of the model. A model can only serve prediction requests after it gets deployed.",
            "enum": [
              "DEPLOYMENT_STATE_UNSPECIFIED",
              "DEPLOYED",
              "UNDEPLOYED"
            ],
            "type": "string"
          },
          "displayName": {
            "description": "Required. The name of the model to show in the interface. The name can be up to 32 characters long and can consist only of ASCII Latin letters A-Z and a-z, underscores (_), and ASCII digits 0-9. It must start with a letter.",
            "type": "string"
          },
          "imageClassificationModelMetadata": {
            "$ref": "#/$defs/ImageClassificationModelMetadata"
          },
          "imageObjectDetectionModelMetadata": {
            "$ref": "#/$defs/ImageObjectDetectionModelMetadata"
          },
          "name": {
            "description": "Output only. Resource name of the model. Format: `projects/{project_id}/locations/{location_id}/models/{model_id}`",
            "type": "string"
          },
          "tablesModelMetadata": {
            "$ref": "#/$defs/TablesModelMetadata"
          },
          "textClassificationModelMetadata": {
            "$ref": "#/$defs/TextClassificationModelMetadata"
          },
          "textExtractionModelMetadata": {
            "$ref": "#/$defs/TextExtractionModelMetadata"
          },
          "textSentimentModelMetadata": {
            "$ref": "#/$defs/TextSentimentModelMetadata"
          },
          "trainExampleCount": {
            "description": "Output only. The number of examples in the training set used for the model creation.",
            "format": "int32",
            "readOnly": true,
            "type": "integer"
          },
          "translationModelMetadata": {
            "$ref": "#/$defs/TranslationModelMetadata"
          },
          "updateTime": {
            "description": "Output only. Timestamp when this model was last updated.",
            "format": "google-datetime",
            "type": "string"
          },
          "validateExampleCount": {
            "description": "Output only. The number of examples in the validation set used for the model creation.",
            "format": "int32",
            "readOnly": true,
            "type": "integer"
          },
          "videoClassificationModelMetadata": {
            "$ref": "#/$defs/VideoClassificationModelMetadata"
          },
          "videoObjectTrackingModelMetadata": {
            "$ref": "#/$defs/VideoObjectTrackingModelMetadata"
          }
        },
        "type": "object"
      },
      "ImageClassificationModelMetadata": {
        "description": "Model metadata for image classification.",
        "properties": {
          "baseModelId": {
            "description": "Optional. The ID of the `base` model. If it is specified, the new model will be created based on the `base` model. Otherwise, the new model will be created from scratch. The `base` model must be in the same `project` and `location` as the new model to create, and have the same `model_type`.",
            "type": "string"
          },
          "modelType": {
            "description": "Optional. Type of the model. The available values are: * `cloud` - Model to be used via prediction calls to AutoML API. This is the default value. * `mobile-low-latency-1` - A model that, in addition to providing prediction via AutoML API, can also be exported (see AutoMl.ExportModel) and used on a mobile or edge device with TensorFlow afterwards. Expected to have low latency, but may have lower prediction quality than other models. * `mobile-versatile-1` - A model that, in addition to providing prediction via AutoML API, can also be exported (see AutoMl.ExportModel) and used on a mobile or edge device with TensorFlow afterwards. * `mobile-high-accuracy-1` - A model that, in addition to providing prediction via AutoML API, can also be exported (see AutoMl.ExportModel) and used on a mobile or edge device with TensorFlow afterwards. Expected to have a higher latency, but should also have a higher prediction quality than other models. * `mobile-core-ml-low-latency-1` - A model that, in addition to providing prediction via AutoML API, can also be exported (see AutoMl.ExportModel) and used on a mobile device with Core ML afterwards. Expected to have low latency, but may have lower prediction quality than other models. * `mobile-core-ml-versatile-1` - A model that, in addition to providing prediction via AutoML API, can also be exported (see AutoMl.ExportModel) and used on a mobile device with Core ML afterwards. * `mobile-core-ml-high-accuracy-1` - A model that, in addition to providing prediction via AutoML API, can also be exported (see AutoMl.ExportModel) and used on a mobile device with Core ML afterwards. Expected to have a higher latency, but should also have a higher prediction quality than other models.",
            "type": "string"
          },
          "nodeCount": {
            "description": "Output only. The number of nodes this model is deployed on. A node is an abstraction of a machine resource, which can handle online prediction QPS as given in the node_qps field.",
            "format": "int64",
            "type": "string"
          },
          "nodeQps": {
            "description": "Output only. An approximate number of online prediction QPS that can be supported by this model per each node on which it is deployed.",
            "format": "double",
            "type": "number"
          },
          "stopReason": {
            "description": "Output only. The reason that this create model operation stopped, e.g. `BUDGET_REACHED`, `MODEL_CONVERGED`.",
            "type": "string"
          },
          "trainBudget": {
            "description": "Required. The train budget of creating this model, expressed in hours. The actual `train_cost` will be equal or less than this value.",
            "format": "int64",
            "type": "string"
          },
          "trainCost": {
            "description": "Output only. The actual train cost of creating this model, expressed in hours. If this model is created from a `base` model, the train cost used to create the `base` model are not included.",
            "format": "int64",
            "type": "string"
          }
        },
        "type": "object"
      },
      "ImageObjectDetectionModelMetadata": {
        "description": "Model metadata specific to image object detection.",
        "properties": {
          "modelType": {
            "description": "Optional. Type of the model. The available values are: * `cloud-high-accuracy-1` - (default) A model to be used via prediction calls to AutoML API. Expected to have a higher latency, but should also have a higher prediction quality than other models. * `cloud-low-latency-1` - A model to be used via prediction calls to AutoML API. Expected to have low latency, but may have lower prediction quality than other models. * `mobile-low-latency-1` - A model that, in addition to providing prediction via AutoML API, can also be exported (see AutoMl.ExportModel) and used on a mobile or edge device with TensorFlow afterwards. Expected to have low latency, but may have lower prediction quality than other models. * `mobile-versatile-1` - A model that, in addition to providing prediction via AutoML API, can also be exported (see AutoMl.ExportModel) and used on a mobile or edge device with TensorFlow afterwards. * `mobile-high-accuracy-1` - A model that, in addition to providing prediction via AutoML API, can also be exported (see AutoMl.ExportModel) and used on a mobile or edge device with TensorFlow afterwards. Expected to have a higher latency, but should also have a higher prediction quality than other models.",
            "type": "string"
          },
          "nodeCount": {
            "description": "Output only. The number of nodes this model is deployed on. A node is an abstraction of a machine resource, which can handle online prediction QPS as given in the qps_per_node field.",
            "format": "int64",
            "type": "string"
          },
          "nodeQps": {
            "description": "Output only. An approximate number of online prediction QPS that can be supported by this model per each node on which it is deployed.",
            "format": "double",
            "type": "number"
          },
          "stopReason": {
            "description": "Output only. The reason that this create model operation stopped, e.g. `BUDGET_REACHED`, `MODEL_CONVERGED`.",
            "type": "string"
          },
          "trainBudgetMilliNodeHours": {
            "description": "The train budget of creating this model, expressed in milli node hours i.e. 1,000 value in this field means 1 node hour. The actual `train_cost` will be equal or less than this value. If further model training ceases to provide any improvements, it will stop without using full budget and the stop_reason will be `MODEL_CONVERGED`. Note, node_hour = actual_hour * number_of_nodes_invovled. For model type `cloud-high-accuracy-1`(default) and `cloud-low-latency-1`, the train budget must be between 20,000 and 900,000 milli node hours, inclusive. The default value is 216, 000 which represents one day in wall time. For model type `mobile-low-latency-1`, `mobile-versatile-1`, `mobile-high-accuracy-1`, `mobile-core-ml-low-latency-1`, `mobile-core-ml-versatile-1`, `mobile-core-ml-high-accuracy-1`, the train budget must be between 1,000 and 100,000 milli node hours, inclusive. The default value is 24, 000 which represents one day in wall time.",
            "format": "int64",
            "type": "string"
          },
          "trainCostMilliNodeHours": {
            "description": "Output only. The actual train cost of creating this model, expressed in milli node hours, i.e. 1,000 value in this field means 1 node hour. Guaranteed to not exceed the train budget.",
            "format": "int64",
            "type": "string"
          }
        },
        "type": "object"
      },
      "TablesModelMetadata": {
        "description": "Model metadata specific to AutoML Tables.",
        "properties": {
          "disableEarlyStopping": {
            "description": "Use the entire training budget. This disables the early stopping feature. By default, the early stopping feature is enabled, which means that AutoML Tables might stop training before the entire training budget has been used.",
            "type": "boolean"
          },
          "inputFeatureColumnSpecs": {
            "description": "Column specs of the dataset's primary table's columns, on which the model is trained and which are used as the input for predictions. The target_column as well as, according to dataset's state upon model creation, weight_column, and ml_use_column must never be included here. Only 3 fields are used: * name - May be set on CreateModel, if set only the columns specified are used, otherwise all primary table's columns (except the ones listed above) are used for the training and prediction input. * display_name - Output only. * data_type - Output only.",
            "items": {
              "$ref": "#/$defs/ColumnSpec"
            },
            "type": "array"
          },
          "optimizationObjective": {
            "description": "Objective function the model is optimizing towards. The training process creates a model that maximizes/minimizes the value of the objective function over the validation set. The supported optimization objectives depend on the prediction type. If the field is not set, a default objective function is used. CLASSIFICATION_BINARY: \"MAXIMIZE_AU_ROC\" (default) - Maximize the area under the receiver operating characteristic (ROC) curve. \"MINIMIZE_LOG_LOSS\" - Minimize log loss. \"MAXIMIZE_AU_PRC\" - Maximize the area under the precision-recall curve. \"MAXIMIZE_PRECISION_AT_RECALL\" - Maximize precision for a specified recall value. \"MAXIMIZE_RECALL_AT_PRECISION\" - Maximize recall for a specified precision value. CLASSIFICATION_MULTI_CLASS : \"MINIMIZE_LOG_LOSS\" (default) - Minimize log loss. REGRESSION: \"MINIMIZE_RMSE\" (default) - Minimize root-mean-squared error (RMSE). \"MINIMIZE_MAE\" - Minimize mean-absolute error (MAE). \"MINIMIZE_RMSLE\" - Minimize root-mean-squared log error (RMSLE).",
            "type": "string"
          },
          "optimizationObjectivePrecisionValue": {
            "description": "Required when optimization_objective is \"MAXIMIZE_RECALL_AT_PRECISION\". Must be between 0 and 1, inclusive.",
            "format": "float",
            "type": "number"
          },
          "optimizationObjectiveRecallValue": {
            "description": "Required when optimization_objective is \"MAXIMIZE_PRECISION_AT_RECALL\". Must be between 0 and 1, inclusive.",
            "format": "float",
            "type": "number"
          },
          "tablesModelColumnInfo": {
            "description": "Output only. Auxiliary information for each of the input_feature_column_specs with respect to this particular model.",
            "items": {
              "$ref": "#/$defs/TablesModelColumnInfo"
            },
            "type": "array"
          },
          "targetColumnSpec": {
            "$ref": "#/$defs/ColumnSpec"
          },
          "trainBudgetMilliNodeHours": {
            "description": "Required. The train budget of creating this model, expressed in milli node hours i.e. 1,000 value in this field means 1 node hour. The training cost of the model will not exceed this budget. The final cost will be attempted to be close to the budget, though may end up being (even) noticeably smaller - at the backend's discretion. This especially may happen when further model training ceases to provide any improvements. If the budget is set to a value known to be insufficient to train a model for the given dataset, the training won't be attempted and will error. The train budget must be between 1,000 and 72,000 milli node hours, inclusive.",
            "format": "int64",
            "type": "string"
          },
          "trainCostMilliNodeHours": {
            "description": "Output only. The actual training cost of the model, expressed in milli node hours, i.e. 1,000 value in this field means 1 node hour. Guaranteed to not exceed the train budget.",
            "format": "int64",
            "type": "string"
          }
        },
        "type": "object"
      },
      "ColumnSpec": {
        "description": "A representation of a column in a relational table. When listing them, column specs are returned in the same order in which they were given on import . Used by: * Tables",
        "properties": {
          "dataStats": {
            "$ref": "#/$defs/DataStats"
          },
          "dataType": {
            "$ref": "#/$defs/DataType"
          },
          "displayName": {
            "description": "Output only. The name of the column to show in the interface. The name can be up to 100 characters long and can consist only of ASCII Latin letters A-Z and a-z, ASCII digits 0-9, underscores(_), and forward slashes(/), and must start with a letter or a digit.",
            "type": "string"
          },
          "etag": {
            "description": "Used to perform consistent read-modify-write updates. If not set, a blind \"overwrite\" update happens.",
            "type": "string"
          },
          "name": {
            "description": "Output only. The resource name of the column specs. Form: `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/tableSpecs/{table_spec_id}/columnSpecs/{column_spec_id}`",
            "type": "string"
          },
          "topCorrelatedColumns": {
            "description": "Deprecated.",
            "items": {
              "$ref": "#/$defs/CorrelatedColumn"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "DataStats": {
        "description": "The data statistics of a series of values that share the same DataType.",
        "properties": {
          "arrayStats": {
            "$ref": "#/$defs/ArrayStats"
          },
          "categoryStats": {
            "$ref": "#/$defs/CategoryStats"
          },
          "distinctValueCount": {
            "description": "The number of distinct values.",
            "format": "int64",
            "type": "string"
          },
          "float64Stats": {
            "$ref": "#/$defs/Float64Stats"
          },
          "nullValueCount": {
            "description": "The number of values that are null.",
            "format": "int64",
            "type": "string"
          },
          "stringStats": {
            "$ref": "#/$defs/StringStats"
          },
          "structStats": {
            "$ref": "#/$defs/StructStats"
          },
          "timestampStats": {
            "$ref": "#/$defs/TimestampStats"
          },
          "validValueCount": {
            "description": "The number of values that are valid.",
            "format": "int64",
            "type": "string"
          }
        },
        "type": "object"
      },
      "ArrayStats": {
        "description": "The data statistics of a series of ARRAY values.",
        "properties": {
          "memberStats": {
            "$ref": "#/$defs/DataStats"
          }
        },
        "type": "object"
      },
      "CategoryStats": {
        "description": "The data statistics of a series of CATEGORY values.",
        "properties": {
          "topCategoryStats": {
            "description": "The statistics of the top 20 CATEGORY values, ordered by count.",
            "items": {
              "$ref": "#/$defs/SingleCategoryStats"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "SingleCategoryStats": {
        "description": "The statistics of a single CATEGORY value.",
        "properties": {
          "count": {
            "description": "The number of occurrences of this value in the series.",
            "format": "int64",
            "type": "string"
          },
          "value": {
            "description": "The CATEGORY value.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "Float64Stats": {
        "description": "The data statistics of a series of FLOAT64 values.",
        "properties": {
          "histogramBuckets": {
            "description": "Histogram buckets of the data series. Sorted by the min value of the bucket, ascendingly, and the number of the buckets is dynamically generated. The buckets are non-overlapping and completely cover whole FLOAT64 range with min of first bucket being `\"-Infinity\"`, and max of the last one being `\"Infinity\"`.",
            "items": {
              "$ref": "#/$defs/HistogramBucket"
            },
            "type": "array"
          },
          "mean": {
            "description": "The mean of the series.",
            "format": "double",
            "type": "number"
          },
          "quantiles": {
            "description": "Ordered from 0 to k k-quantile values of the data series of n values. The value at index i is, approximately, the i*n/k-th smallest value in the series; for i = 0 and i = k these are, respectively, the min and max values.",
            "items": {
              "format": "double",
              "type": "number"
            },
            "type": "array"
          },
          "standardDeviation": {
            "description": "The standard deviation of the series.",
            "format": "double",
            "type": "number"
          }
        },
        "type": "object"
      },
      "HistogramBucket": {
        "description": "A bucket of a histogram.",
        "properties": {
          "count": {
            "description": "The number of data values that are in the bucket, i.e. are between min and max values.",
            "format": "int64",
            "type": "string"
          },
          "max": {
            "description": "The maximum value of the bucket, exclusive unless max = `\"Infinity\"`, in which case it's inclusive.",
            "format": "double",
            "type": "number"
          },
          "min": {
            "description": "The minimum value of the bucket, inclusive.",
            "format": "double",
            "type": "number"
          }
        },
        "type": "object"
      },
      "StringStats": {
        "description": "The data statistics of a series of STRING values.",
        "properties": {
          "topUnigramStats": {
            "description": "The statistics of the top 20 unigrams, ordered by count.",
            "items": {
              "$ref": "#/$defs/UnigramStats"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "UnigramStats": {
        "description": "The statistics of a unigram.",
        "properties": {
          "count": {
            "description": "The number of occurrences of this unigram in the series.",
            "format": "int64",
            "type": "string"
          },
          "value": {
            "description": "The unigram.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "StructStats": {
        "description": "The data statistics of a series of STRUCT values.",
        "properties": {
          "fieldStats": {
            "additionalProperties": {
              "$ref": "#/$defs/DataStats"
            },
            "description": "Map from a field name of the struct to data stats aggregated over series of all data in that field across all the structs.",
            "type": "object"
          }
        },
        "type": "object"
      },
      "TimestampStats": {
        "description": "The data statistics of a series of TIMESTAMP values.",
        "properties": {
          "granularStats": {
            "additionalProperties": {
              "$ref": "#/$defs/GranularStats"
            },
            "description": "The string key is the pre-defined granularity. Currently supported: hour_of_day, day_of_week, month_of_year. Granularities finer that the granularity of timestamp data are not populated (e.g. if timestamps are at day granularity, then hour_of_day is not populated).",
            "type": "object"
          }
        },
        "type": "object"
      },
      "GranularStats": {
        "description": "Stats split by a defined in context granularity.",
        "properties": {
          "buckets": {
            "additionalProperties": {
              "format": "int64",
              "type": "string"
            },
            "description": "A map from granularity key to example count for that key. E.g. for hour_of_day `13` means 1pm, or for month_of_year `5` means May).",
            "type": "object"
          }
        },
        "type": "object"
      },
      "DataType": {
        "description": "Indicated the type of data that can be stored in a structured data entity (e.g. a table).",
        "properties": {
          "listElementType": {
            "$ref": "#/$defs/DataType"
          },
          "nullable": {
            "description": "If true, this DataType can also be `NULL`. In .CSV files `NULL` value is expressed as an empty string.",
            "type": "boolean"
          },
          "structType": {
            "$ref": "#/$defs/StructType"
          },
          "timeFormat": {
            "description": "If type_code == TIMESTAMP then `time_format` provides the format in which that time field is expressed. The time_format must either be one of: * `UNIX_SECONDS` * `UNIX_MILLISECONDS` * `UNIX_MICROSECONDS` * `UNIX_NANOSECONDS` (for respectively number of seconds, milliseconds, microseconds and nanoseconds since start of the Unix epoch); or be written in `strftime` syntax. If time_format is not set, then the default format as described on the type_code is used.",
            "type": "string"
          },
          "typeCode": {
            "description": "Required. The TypeCode for this type.",
            "enum": [
              "TYPE_CODE_UNSPECIFIED",
              "FLOAT64",
              "TIMESTAMP",
              "STRING",
              "ARRAY",
              "STRUCT",
              "CATEGORY"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "StructType": {
        "description": "`StructType` defines the DataType-s of a STRUCT type.",
        "properties": {
          "fields": {
            "additionalProperties": {
              "$ref": "#/$defs/DataType"
            },
            "description": "Unordered map of struct field names to their data types. Fields cannot be added or removed via Update. Their names and data types are still mutable.",
            "type": "object"
          }
        },
        "type": "object"
      },
      "CorrelatedColumn": {
        "description": "Identifies the table's column, and its correlation with the column this ColumnSpec describes.",
        "properties": {
          "columnSpecId": {
            "description": "The column_spec_id of the correlated column, which belongs to the same table as the in-context column.",
            "type": "string"
          },
          "correlationStats": {
            "$ref": "#/$defs/CorrelationStats"
          }
        },
        "type": "object"
      },
      "CorrelationStats": {
        "description": "A correlation statistics between two series of DataType values. The series may have differing DataType-s, but within a single series the DataType must be the same.",
        "properties": {
          "cramersV": {
            "description": "The correlation value using the Cramer's V measure.",
            "format": "double",
            "type": "number"
          }
        },
        "type": "object"
      },
      "TablesModelColumnInfo": {
        "description": "An information specific to given column and Tables Model, in context of the Model and the predictions created by it.",
        "properties": {
          "columnDisplayName": {
            "description": "Output only. The display name of the column (same as the display_name of its ColumnSpec).",
            "type": "string"
          },
          "columnSpecName": {
            "description": "Output only. The name of the ColumnSpec describing the column. Not populated when this proto is outputted to BigQuery.",
            "type": "string"
          },
          "featureImportance": {
            "description": "Output only. When given as part of a Model (always populated): Measurement of how much model predictions correctness on the TEST data depend on values in this column. A value between 0 and 1, higher means higher influence. These values are normalized - for all input feature columns of a given model they add to 1. When given back by Predict (populated iff feature_importance param is set) or Batch Predict (populated iff feature_importance param is set): Measurement of how impactful for the prediction returned for the given row the value in this column was. Specifically, the feature importance specifies the marginal contribution that the feature made to the prediction score compared to the baseline score. These values are computed using the Sampled Shapley method.",
            "format": "float",
            "type": "number"
          }
        },
        "type": "object"
      },
      "TextClassificationModelMetadata": {
        "description": "Model metadata that is specific to text classification.",
        "properties": {
          "classificationType": {
            "description": "Output only. Classification type of the dataset used to train this model.",
            "enum": [
              "CLASSIFICATION_TYPE_UNSPECIFIED",
              "MULTICLASS",
              "MULTILABEL"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "TextExtractionModelMetadata": {
        "description": "Model metadata that is specific to text extraction.",
        "properties": {
          "modelHint": {
            "description": "Indicates the scope of model use case. * `default`: Use to train a general text extraction model. Default value. * `health_care`: Use to train a text extraction model that is tuned for healthcare applications.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "TextSentimentModelMetadata": {
        "description": "Model metadata that is specific to text sentiment.",
        "properties": {},
        "type": "object"
      },
      "TranslationModelMetadata": {
        "description": "Model metadata that is specific to translation.",
        "properties": {
          "baseModel": {
            "description": "The resource name of the model to use as a baseline to train the custom model. If unset, we use the default base model provided by Google Translate. Format: `projects/{project_id}/locations/{location_id}/models/{model_id}`",
            "type": "string"
          },
          "sourceLanguageCode": {
            "description": "Output only. Inferred from the dataset. The source languge (The BCP-47 language code) that is used for training.",
            "type": "string"
          },
          "targetLanguageCode": {
            "description": "Output only. The target languge (The BCP-47 language code) that is used for training.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "VideoClassificationModelMetadata": {
        "description": "Model metadata specific to video classification.",
        "properties": {},
        "type": "object"
      },
      "VideoObjectTrackingModelMetadata": {
        "description": "Model metadata specific to video object tracking.",
        "properties": {},
        "type": "object"
      }
    }
  },
  "handler": "http",
  "request": {
    "method": "POST",
    "url": {
      "$uri": "https://automl.googleapis.com//v1beta1/{parent}/models{?$.xgafv,access_token,alt,callback,fields,key,oauth_token,prettyPrint,quotaUser,upload_protocol,uploadType}"
    },
    "body": {
      "$": "body",
      "encode": "json"
    }
  },
  "responses": {
    "200": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "This resource represents a long-running operation that is the result of a network API call.",
        "**Key properties:**",
        {
          "$ul": [
            "**done**: If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.",
            [
              "**error**: The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).",
              {
                "$ul": [
                  "**code**: The status code, which should be an enum value of google.rpc.Code.",
                  "**details**: A list of messages that carry the error details. There is a common set of message types for APIs to use.",
                  "**message**: A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client."
                ]
              }
            ],
            "**metadata**: Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.",
            "**name**: The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.",
            "**response**: The normal, successful response of the operation. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`."
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    }
  }
}
