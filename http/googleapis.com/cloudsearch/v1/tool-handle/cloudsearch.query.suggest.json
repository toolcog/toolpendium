{
  "name": "cloudsearch_query_suggest",
  "description": "Provides suggestions for autocompleting the query. **Note:** This API requires a standard end user account to execute. A service account can't perform Query API requests directly; to use a service account to perform queries, set up [Google Workspace domain-wide delegation of authority](https://developers.google.com/cloud-search/docs/guides/delegation/).",
  "parameters": {
    "type": "object",
    "properties": {
      "$.xgafv": {
        "enum": [
          "1",
          "2"
        ],
        "type": "string",
        "description": "V1 error format."
      },
      "access_token": {
        "type": "string",
        "description": "OAuth access token."
      },
      "alt": {
        "enum": [
          "json",
          "media",
          "proto"
        ],
        "type": "string",
        "description": "Data format for response."
      },
      "callback": {
        "type": "string",
        "description": "JSONP"
      },
      "fields": {
        "type": "string",
        "description": "Selector specifying which fields to include in a partial response."
      },
      "key": {
        "type": "string",
        "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
      },
      "oauth_token": {
        "type": "string",
        "description": "OAuth 2.0 token for the current user."
      },
      "prettyPrint": {
        "type": "boolean",
        "description": "Returns response with indentations and line breaks."
      },
      "quotaUser": {
        "type": "string",
        "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
      },
      "upload_protocol": {
        "type": "string",
        "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
      },
      "uploadType": {
        "type": "string",
        "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
      },
      "body": {
        "$ref": "#/$defs/SuggestRequest"
      }
    },
    "$defs": {
      "SuggestRequest": {
        "description": "Request of suggest API.",
        "properties": {
          "dataSourceRestrictions": {
            "description": "The sources to use for suggestions. If not specified, the data sources are taken from the current search application. NOTE: Suggestions are only supported for the following sources: * Third-party data sources * PredefinedSource.PERSON * PredefinedSource.GOOGLE_DRIVE",
            "items": {
              "$ref": "#/$defs/DataSourceRestriction"
            },
            "type": "array"
          },
          "query": {
            "description": "Partial query for which autocomplete suggestions will be shown. For example, if the query is \"sea\", then the server might return \"season\", \"search\", \"seagull\" and so on.",
            "type": "string"
          },
          "requestOptions": {
            "$ref": "#/$defs/RequestOptions"
          }
        },
        "type": "object"
      },
      "DataSourceRestriction": {
        "description": "Restriction on Datasource.",
        "properties": {
          "filterOptions": {
            "description": "Filter options restricting the results. If multiple filters are present, they are grouped by object type before joining. Filters with the same object type are joined conjunctively, then the resulting expressions are joined disjunctively. The maximum number of elements is 20. NOTE: Suggest API supports only few filters at the moment: \"objecttype\", \"type\" and \"mimetype\". For now, schema specific filters cannot be used to filter suggestions.",
            "items": {
              "$ref": "#/$defs/FilterOptions"
            },
            "type": "array"
          },
          "source": {
            "$ref": "#/$defs/Source"
          }
        },
        "type": "object"
      },
      "FilterOptions": {
        "description": "Filter options to be applied on query.",
        "properties": {
          "filter": {
            "$ref": "#/$defs/Filter"
          },
          "objectType": {
            "description": "If object_type is set, only objects of that type are returned. This should correspond to the name of the object that was registered within the definition of schema. The maximum length is 256 characters.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "Filter": {
        "description": "A generic way of expressing filters in a query, which supports two approaches: **1. Setting a ValueFilter.** The name must match an operator_name defined in the schema for your data source. **2. Setting a CompositeFilter.** The filters are evaluated using the logical operator. The top-level operators can only be either an AND or a NOT. AND can appear only at the top-most level. OR can appear only under a top-level AND.",
        "properties": {
          "compositeFilter": {
            "$ref": "#/$defs/CompositeFilter"
          },
          "valueFilter": {
            "$ref": "#/$defs/ValueFilter"
          }
        },
        "type": "object"
      },
      "CompositeFilter": {
        "properties": {
          "logicOperator": {
            "description": "The logic operator of the sub filter.",
            "enum": [
              "AND",
              "OR",
              "NOT"
            ],
            "type": "string"
          },
          "subFilters": {
            "description": "Sub filters.",
            "items": {
              "$ref": "#/$defs/Filter"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "ValueFilter": {
        "properties": {
          "operatorName": {
            "description": "The `operator_name` applied to the query, such as *price_greater_than*. The filter can work against both types of filters defined in the schema for your data source: 1. `operator_name`, where the query filters results by the property that matches the value. 2. `greater_than_operator_name` or `less_than_operator_name` in your schema. The query filters the results for the property values that are greater than or less than the supplied value in the query.",
            "type": "string"
          },
          "value": {
            "$ref": "#/$defs/Value"
          }
        },
        "type": "object"
      },
      "Value": {
        "description": "Definition of a single value with generic type.",
        "properties": {
          "booleanValue": {
            "type": "boolean"
          },
          "dateValue": {
            "$ref": "#/$defs/Date"
          },
          "doubleValue": {
            "format": "double",
            "type": "number"
          },
          "integerValue": {
            "format": "int64",
            "type": "string"
          },
          "stringValue": {
            "type": "string"
          },
          "timestampValue": {
            "format": "google-datetime",
            "type": "string"
          }
        },
        "type": "object"
      },
      "Date": {
        "description": "Represents a whole calendar date, for example a date of birth. The time of day and time zone are either specified elsewhere or are not significant. The date is relative to the [Proleptic Gregorian Calendar](https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar). The date must be a valid calendar date between the year 1 and 9999.",
        "properties": {
          "day": {
            "description": "Day of month. Must be from 1 to 31 and valid for the year and month.",
            "format": "int32",
            "type": "integer"
          },
          "month": {
            "description": "Month of date. Must be from 1 to 12.",
            "format": "int32",
            "type": "integer"
          },
          "year": {
            "description": "Year of date. Must be from 1 to 9999.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "Source": {
        "description": "Defines sources for the suggest/search APIs.",
        "properties": {
          "name": {
            "description": "Source name for content indexed by the Indexing API.",
            "type": "string"
          },
          "predefinedSource": {
            "description": "Predefined content source for Google Apps.",
            "enum": [
              "NONE",
              "QUERY_HISTORY",
              "PERSON",
              "GOOGLE_DRIVE",
              "GOOGLE_GMAIL",
              "GOOGLE_SITES",
              "GOOGLE_GROUPS",
              "GOOGLE_CALENDAR",
              "GOOGLE_KEEP"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "RequestOptions": {
        "description": "Shared request options for all RPC methods.",
        "properties": {
          "debugOptions": {
            "$ref": "#/$defs/DebugOptions"
          },
          "languageCode": {
            "description": "The BCP-47 language code, such as \"en-US\" or \"sr-Latn\". For more information, see http://www.unicode.org/reports/tr35/#Unicode_locale_identifier. For translations. Set this field using the language set in browser or for the page. In the event that the user's language preference is known, set this field to the known user language. When specified, the documents in search results are biased towards the specified language. The Suggest API uses this field as a hint to make better third-party autocomplete predictions.",
            "type": "string"
          },
          "searchApplicationId": {
            "description": "The ID generated when you create a search application using the [admin console](https://support.google.com/a/answer/9043922).",
            "type": "string"
          },
          "timeZone": {
            "description": "Current user's time zone id, such as \"America/Los_Angeles\" or \"Australia/Sydney\". These IDs are defined by [Unicode Common Locale Data Repository (CLDR)](http://cldr.unicode.org/) project, and currently available in the file [timezone.xml](http://unicode.org/repos/cldr/trunk/common/bcp47/timezone.xml). This field is used to correctly interpret date and time queries. If this field is not specified, the default time zone (UTC) is used.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "DebugOptions": {
        "description": "Shared request debug options for all cloudsearch RPC methods.",
        "properties": {
          "enableDebugging": {
            "description": "If you are asked by Google to help with debugging, set this field. Otherwise, ignore this field.",
            "type": "boolean"
          }
        },
        "type": "object"
      }
    }
  },
  "handler": "http",
  "request": {
    "method": "POST",
    "url": {
      "$uri": "https://cloudsearch.googleapis.com//v1/query/suggest{?$.xgafv,access_token,alt,callback,fields,key,oauth_token,prettyPrint,quotaUser,upload_protocol,uploadType}"
    },
    "body": {
      "$": "body",
      "encode": "json"
    }
  },
  "responses": {
    "200": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "Response of the suggest API.",
        "**Key properties:**",
        {
          "$ul": [
            "**suggestResults**: List of suggestions."
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    }
  }
}
