{
  "name": "cloudsearch_settings_searchapplications_update",
  "description": "Updates a search application. **Note:** This API requires an admin account to execute.",
  "parameters": {
    "type": "object",
    "properties": {
      "name": {
        "type": "string",
        "description": "The name of the Search Application. Format: searchapplications/{application_id}."
      },
      "updateMask": {
        "type": "string",
        "description": "Only applies to [`settings.searchapplications.patch`](https://developers.google.com/cloud-search/docs/reference/rest/v1/settings.searchapplications/patch). Update mask to control which fields to update. Example field paths: `search_application.name`, `search_application.displayName`. * If `update_mask` is non-empty, then only the fields specified in the `update_mask` are updated. * If you specify a field in the `update_mask`, but don't specify its value in the `search_application`, then that field is cleared. * If the `update_mask` is not present or empty or has the value `*`, then all fields are updated."
      },
      "$.xgafv": {
        "enum": [
          "1",
          "2"
        ],
        "type": "string",
        "description": "V1 error format."
      },
      "access_token": {
        "type": "string",
        "description": "OAuth access token."
      },
      "alt": {
        "enum": [
          "json",
          "media",
          "proto"
        ],
        "type": "string",
        "description": "Data format for response."
      },
      "callback": {
        "type": "string",
        "description": "JSONP"
      },
      "fields": {
        "type": "string",
        "description": "Selector specifying which fields to include in a partial response."
      },
      "key": {
        "type": "string",
        "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
      },
      "oauth_token": {
        "type": "string",
        "description": "OAuth 2.0 token for the current user."
      },
      "prettyPrint": {
        "type": "boolean",
        "description": "Returns response with indentations and line breaks."
      },
      "quotaUser": {
        "type": "string",
        "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
      },
      "upload_protocol": {
        "type": "string",
        "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
      },
      "uploadType": {
        "type": "string",
        "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
      },
      "body": {
        "$ref": "#/$defs/SearchApplication"
      }
    },
    "required": [
      "name"
    ],
    "$defs": {
      "SearchApplication": {
        "description": "SearchApplication",
        "properties": {
          "dataSourceRestrictions": {
            "description": "Retrictions applied to the configurations. The maximum number of elements is 10.",
            "items": {
              "$ref": "#/$defs/DataSourceRestriction"
            },
            "type": "array"
          },
          "defaultFacetOptions": {
            "description": "The default fields for returning facet results. The sources specified here also have been included in data_source_restrictions above.",
            "items": {
              "$ref": "#/$defs/FacetOptions"
            },
            "type": "array"
          },
          "defaultSortOptions": {
            "$ref": "#/$defs/SortOptions"
          },
          "displayName": {
            "description": "Display name of the Search Application. The maximum length is 300 characters.",
            "type": "string"
          },
          "enableAuditLog": {
            "description": "Indicates whether audit logging is on/off for requests made for the search application in query APIs.",
            "type": "boolean"
          },
          "name": {
            "description": "The name of the Search Application. Format: searchapplications/{application_id}.",
            "type": "string"
          },
          "operationIds": {
            "description": "Output only. IDs of the Long Running Operations (LROs) currently running for this schema. Output only field.",
            "items": {
              "type": "string"
            },
            "readOnly": true,
            "type": "array"
          },
          "queryInterpretationConfig": {
            "$ref": "#/$defs/QueryInterpretationConfig"
          },
          "returnResultThumbnailUrls": {
            "description": "With each result we should return the URI for its thumbnail (when applicable)",
            "type": "boolean"
          },
          "scoringConfig": {
            "$ref": "#/$defs/ScoringConfig"
          },
          "sourceConfig": {
            "description": "Configuration for a sources specified in data_source_restrictions.",
            "items": {
              "$ref": "#/$defs/SourceConfig"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "DataSourceRestriction": {
        "description": "Restriction on Datasource.",
        "properties": {
          "filterOptions": {
            "description": "Filter options restricting the results. If multiple filters are present, they are grouped by object type before joining. Filters with the same object type are joined conjunctively, then the resulting expressions are joined disjunctively. The maximum number of elements is 20. NOTE: Suggest API supports only few filters at the moment: \"objecttype\", \"type\" and \"mimetype\". For now, schema specific filters cannot be used to filter suggestions.",
            "items": {
              "$ref": "#/$defs/FilterOptions"
            },
            "type": "array"
          },
          "source": {
            "$ref": "#/$defs/Source"
          }
        },
        "type": "object"
      },
      "FilterOptions": {
        "description": "Filter options to be applied on query.",
        "properties": {
          "filter": {
            "$ref": "#/$defs/Filter"
          },
          "objectType": {
            "description": "If object_type is set, only objects of that type are returned. This should correspond to the name of the object that was registered within the definition of schema. The maximum length is 256 characters.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "Filter": {
        "description": "A generic way of expressing filters in a query, which supports two approaches: **1. Setting a ValueFilter.** The name must match an operator_name defined in the schema for your data source. **2. Setting a CompositeFilter.** The filters are evaluated using the logical operator. The top-level operators can only be either an AND or a NOT. AND can appear only at the top-most level. OR can appear only under a top-level AND.",
        "properties": {
          "compositeFilter": {
            "$ref": "#/$defs/CompositeFilter"
          },
          "valueFilter": {
            "$ref": "#/$defs/ValueFilter"
          }
        },
        "type": "object"
      },
      "CompositeFilter": {
        "properties": {
          "logicOperator": {
            "description": "The logic operator of the sub filter.",
            "enum": [
              "AND",
              "OR",
              "NOT"
            ],
            "type": "string"
          },
          "subFilters": {
            "description": "Sub filters.",
            "items": {
              "$ref": "#/$defs/Filter"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "ValueFilter": {
        "properties": {
          "operatorName": {
            "description": "The `operator_name` applied to the query, such as *price_greater_than*. The filter can work against both types of filters defined in the schema for your data source: 1. `operator_name`, where the query filters results by the property that matches the value. 2. `greater_than_operator_name` or `less_than_operator_name` in your schema. The query filters the results for the property values that are greater than or less than the supplied value in the query.",
            "type": "string"
          },
          "value": {
            "$ref": "#/$defs/Value"
          }
        },
        "type": "object"
      },
      "Value": {
        "description": "Definition of a single value with generic type.",
        "properties": {
          "booleanValue": {
            "type": "boolean"
          },
          "dateValue": {
            "$ref": "#/$defs/Date"
          },
          "doubleValue": {
            "format": "double",
            "type": "number"
          },
          "integerValue": {
            "format": "int64",
            "type": "string"
          },
          "stringValue": {
            "type": "string"
          },
          "timestampValue": {
            "format": "google-datetime",
            "type": "string"
          }
        },
        "type": "object"
      },
      "Date": {
        "description": "Represents a whole calendar date, for example a date of birth. The time of day and time zone are either specified elsewhere or are not significant. The date is relative to the [Proleptic Gregorian Calendar](https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar). The date must be a valid calendar date between the year 1 and 9999.",
        "properties": {
          "day": {
            "description": "Day of month. Must be from 1 to 31 and valid for the year and month.",
            "format": "int32",
            "type": "integer"
          },
          "month": {
            "description": "Month of date. Must be from 1 to 12.",
            "format": "int32",
            "type": "integer"
          },
          "year": {
            "description": "Year of date. Must be from 1 to 9999.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "Source": {
        "description": "Defines sources for the suggest/search APIs.",
        "properties": {
          "name": {
            "description": "Source name for content indexed by the Indexing API.",
            "type": "string"
          },
          "predefinedSource": {
            "description": "Predefined content source for Google Apps.",
            "enum": [
              "NONE",
              "QUERY_HISTORY",
              "PERSON",
              "GOOGLE_DRIVE",
              "GOOGLE_GMAIL",
              "GOOGLE_SITES",
              "GOOGLE_GROUPS",
              "GOOGLE_CALENDAR",
              "GOOGLE_KEEP"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "FacetOptions": {
        "description": "Specifies operators to return facet results for. There will be one FacetResult for every source_name/object_type/operator_name combination.",
        "properties": {
          "integerFacetingOptions": {
            "$ref": "#/$defs/IntegerFacetingOptions"
          },
          "numFacetBuckets": {
            "description": "Maximum number of facet buckets that should be returned for this facet. Defaults to 10. Maximum value is 100.",
            "format": "int32",
            "type": "integer"
          },
          "objectType": {
            "description": "If object_type is set, only those objects of that type will be used to compute facets. If empty, then all objects will be used to compute facets.",
            "type": "string"
          },
          "operatorName": {
            "description": "The name of the operator chosen for faceting. @see cloudsearch.SchemaPropertyOptions",
            "type": "string"
          },
          "sourceName": {
            "description": "Source name to facet on. Format: datasources/{source_id} If empty, all data sources will be used.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "IntegerFacetingOptions": {
        "description": "Used to specify integer faceting options.",
        "properties": {
          "integerBuckets": {
            "description": "Buckets for given integer values should be in strictly ascending order. For example, if values supplied are (1,5,10,100), the following facet buckets will be formed {<1, [1,5), [5-10), [10-100), >=100}.",
            "items": {
              "format": "int64",
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "SortOptions": {
        "properties": {
          "operatorName": {
            "description": "The name of the operator corresponding to the field to sort on. The corresponding property must be marked as sortable.",
            "type": "string"
          },
          "sortOrder": {
            "description": "Ascending is the default sort order",
            "enum": [
              "ASCENDING",
              "DESCENDING"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "QueryInterpretationConfig": {
        "description": "Default options to interpret user query.",
        "properties": {
          "forceDisableSupplementalResults": {
            "description": "Set this flag to disable supplemental results retrieval, setting a flag here will not retrieve supplemental results for queries associated with a given search application. If this flag is set to True, it will take precedence over the option set at Query level. For the default value of False, query level flag will set the correct interpretation for supplemental results.",
            "type": "boolean"
          },
          "forceVerbatimMode": {
            "description": "Enable this flag to turn off all internal optimizations like natural language (NL) interpretation of queries, supplemental results retrieval, and usage of synonyms including custom ones. If this flag is set to True, it will take precedence over the option set at Query level. For the default value of False, query level flag will set the correct interpretation for verbatim mode.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "ScoringConfig": {
        "description": "Scoring configurations for a source while processing a Search or Suggest request.",
        "properties": {
          "disableFreshness": {
            "description": "Whether to use freshness as a ranking signal. By default, freshness is used as a ranking signal. Note that this setting is not available in the Admin UI.",
            "type": "boolean"
          },
          "disablePersonalization": {
            "description": "Whether to personalize the results. By default, personal signals will be used to boost results.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "SourceConfig": {
        "description": "Configurations for a source while processing a Search or Suggest request.",
        "properties": {
          "crowdingConfig": {
            "$ref": "#/$defs/SourceCrowdingConfig"
          },
          "scoringConfig": {
            "$ref": "#/$defs/SourceScoringConfig"
          },
          "source": {
            "$ref": "#/$defs/Source"
          }
        },
        "type": "object"
      },
      "SourceCrowdingConfig": {
        "description": "Set search results crowding limits. Crowding is a situation in which multiple results from the same source or host \"crowd out\" other results, diminishing the quality of search for users. To foster better search quality and source diversity in search results, you can set a condition to reduce repetitive results by source.",
        "properties": {
          "numResults": {
            "description": "Maximum number of results allowed from a datasource in a result page as long as results from other sources are not exhausted. Value specified must not be negative. A default value is used if this value is equal to 0. To disable crowding, set the value greater than 100.",
            "format": "int32",
            "type": "integer"
          },
          "numSuggestions": {
            "description": "Maximum number of suggestions allowed from a source. No limits will be set on results if this value is less than or equal to 0.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "SourceScoringConfig": {
        "description": "Set the scoring configuration. This allows modifying the ranking of results for a source.",
        "properties": {
          "sourceImportance": {
            "description": "Importance of the source.",
            "enum": [
              "DEFAULT",
              "LOW",
              "HIGH"
            ],
            "type": "string"
          }
        },
        "type": "object"
      }
    }
  },
  "handler": "http",
  "request": {
    "method": "PUT",
    "url": {
      "$uri": "https://cloudsearch.googleapis.com//v1/settings/{name}{?updateMask,$.xgafv,access_token,alt,callback,fields,key,oauth_token,prettyPrint,quotaUser,upload_protocol,uploadType}"
    },
    "body": {
      "$": "body",
      "encode": "json"
    }
  },
  "responses": {
    "200": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "This resource represents a long-running operation that is the result of a network API call.",
        "**Key properties:**",
        {
          "$ul": [
            "**done**: If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.",
            [
              "**error**: The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).",
              {
                "$ul": [
                  "**code**: The status code, which should be an enum value of google.rpc.Code.",
                  "**details**: A list of messages that carry the error details. There is a common set of message types for APIs to use.",
                  "**message**: A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client."
                ]
              }
            ],
            "**metadata**: Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.",
            "**name**: The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.",
            "**response**: The normal, successful response of the operation. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`."
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    }
  }
}
