{
  "name": "networksecurity_projects_locations_authorizationPolicies_create",
  "description": "Creates a new AuthorizationPolicy in a given project and location.",
  "parameters": {
    "type": "object",
    "properties": {
      "parent": {
        "type": "string",
        "description": "Required. The parent resource of the AuthorizationPolicy. Must be in the format `projects/{project}/locations/{location}`."
      },
      "authorizationPolicyId": {
        "type": "string",
        "description": "Required. Short name of the AuthorizationPolicy resource to be created. This value should be 1-63 characters long, containing only letters, numbers, hyphens, and underscores, and should not start with a number. E.g. \"authz_policy\"."
      },
      "$.xgafv": {
        "enum": [
          "1",
          "2"
        ],
        "type": "string",
        "description": "V1 error format."
      },
      "access_token": {
        "type": "string",
        "description": "OAuth access token."
      },
      "alt": {
        "enum": [
          "json",
          "media",
          "proto"
        ],
        "type": "string",
        "description": "Data format for response."
      },
      "callback": {
        "type": "string",
        "description": "JSONP"
      },
      "fields": {
        "type": "string",
        "description": "Selector specifying which fields to include in a partial response."
      },
      "key": {
        "type": "string",
        "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
      },
      "oauth_token": {
        "type": "string",
        "description": "OAuth 2.0 token for the current user."
      },
      "prettyPrint": {
        "type": "boolean",
        "description": "Returns response with indentations and line breaks."
      },
      "quotaUser": {
        "type": "string",
        "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
      },
      "upload_protocol": {
        "type": "string",
        "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
      },
      "uploadType": {
        "type": "string",
        "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
      },
      "body": {
        "$ref": "#/$defs/AuthorizationPolicy"
      }
    },
    "required": [
      "parent"
    ],
    "$defs": {
      "AuthorizationPolicy": {
        "description": "AuthorizationPolicy is a resource that specifies how a server should authorize incoming connections. This resource in itself does not change the configuration unless it's attached to a target https proxy or endpoint config selector resource.",
        "properties": {
          "action": {
            "description": "Required. The action to take when a rule match is found. Possible values are \"ALLOW\" or \"DENY\".",
            "enum": [
              "ACTION_UNSPECIFIED",
              "ALLOW",
              "DENY"
            ],
            "type": "string"
          },
          "createTime": {
            "description": "Output only. The timestamp when the resource was created.",
            "format": "google-datetime",
            "readOnly": true,
            "type": "string"
          },
          "description": {
            "description": "Optional. Free-text description of the resource.",
            "type": "string"
          },
          "labels": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Optional. Set of label tags associated with the AuthorizationPolicy resource.",
            "type": "object"
          },
          "name": {
            "description": "Required. Name of the AuthorizationPolicy resource. It matches pattern `projects/{project}/locations/{location}/authorizationPolicies/`.",
            "type": "string"
          },
          "rules": {
            "description": "Optional. List of rules to match. Note that at least one of the rules must match in order for the action specified in the 'action' field to be taken. A rule is a match if there is a matching source and destination. If left blank, the action specified in the `action` field will be applied on every request.",
            "items": {
              "$ref": "#/$defs/Rule"
            },
            "type": "array"
          },
          "updateTime": {
            "description": "Output only. The timestamp when the resource was updated.",
            "format": "google-datetime",
            "readOnly": true,
            "type": "string"
          }
        },
        "type": "object"
      },
      "Rule": {
        "description": "Specification of rules.",
        "properties": {
          "destinations": {
            "description": "Optional. List of attributes for the traffic destination. All of the destinations must match. A destination is a match if a request matches all the specified hosts, ports, methods and headers. If not set, the action specified in the 'action' field will be applied without any rule checks for the destination.",
            "items": {
              "$ref": "#/$defs/Destination"
            },
            "type": "array"
          },
          "sources": {
            "description": "Optional. List of attributes for the traffic source. All of the sources must match. A source is a match if both principals and ip_blocks match. If not set, the action specified in the 'action' field will be applied without any rule checks for the source.",
            "items": {
              "$ref": "#/$defs/Source"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "Destination": {
        "description": "Specification of traffic destination attributes.",
        "properties": {
          "hosts": {
            "description": "Required. List of host names to match. Matched against the \":authority\" header in http requests. At least one host should match. Each host can be an exact match, or a prefix match (example \"mydomain.*\") or a suffix match (example \"*.myorg.com\") or a presence (any) match \"*\".",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "httpHeaderMatch": {
            "$ref": "#/$defs/HttpHeaderMatch"
          },
          "methods": {
            "description": "Optional. A list of HTTP methods to match. At least one method should match. Should not be set for gRPC services.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "ports": {
            "description": "Required. List of destination ports to match. At least one port should match.",
            "items": {
              "format": "uint32",
              "type": "integer"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "HttpHeaderMatch": {
        "description": "Specification of HTTP header match attributes.",
        "properties": {
          "headerName": {
            "description": "Required. The name of the HTTP header to match. For matching against the HTTP request's authority, use a headerMatch with the header name \":authority\". For matching a request's method, use the headerName \":method\".",
            "type": "string"
          },
          "regexMatch": {
            "description": "Required. The value of the header must match the regular expression specified in regexMatch. For regular expression grammar, please see: en.cppreference.com/w/cpp/regex/ecmascript For matching against a port specified in the HTTP request, use a headerMatch with headerName set to Host and a regular expression that satisfies the RFC2616 Host header's port specifier.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "Source": {
        "description": "Specification of traffic source attributes.",
        "properties": {
          "ipBlocks": {
            "description": "Optional. List of CIDR ranges to match based on source IP address. At least one IP block should match. Single IP (e.g., \"1.2.3.4\") and CIDR (e.g., \"1.2.3.0/24\") are supported. Authorization based on source IP alone should be avoided. The IP addresses of any load balancers or proxies should be considered untrusted.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "principals": {
            "description": "Optional. List of peer identities to match for authorization. At least one principal should match. Each peer can be an exact match, or a prefix match (example, \"namespace/*\") or a suffix match (example, \"*/service-account\") or a presence match \"*\". Authorization based on the principal name without certificate validation (configured by ServerTlsPolicy resource) is considered insecure.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      }
    }
  },
  "handler": "http",
  "request": {
    "method": "POST",
    "url": {
      "$uri": "https://networksecurity.googleapis.com//v1beta1/{parent}/authorizationPolicies{?authorizationPolicyId,$.xgafv,access_token,alt,callback,fields,key,oauth_token,prettyPrint,quotaUser,upload_protocol,uploadType}"
    },
    "body": {
      "$": "body",
      "encode": "json"
    }
  },
  "responses": {
    "200": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "This resource represents a long-running operation that is the result of a network API call.",
        "**Key properties:**",
        {
          "$ul": [
            "**done**: If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.",
            [
              "**error**: The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).",
              {
                "$ul": [
                  "**code**: The status code, which should be an enum value of google.rpc.Code.",
                  "**details**: A list of messages that carry the error details. There is a common set of message types for APIs to use.",
                  "**message**: A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client."
                ]
              }
            ],
            "**metadata**: Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.",
            "**name**: The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.",
            "**response**: The normal, successful response of the operation. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`."
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    }
  }
}
