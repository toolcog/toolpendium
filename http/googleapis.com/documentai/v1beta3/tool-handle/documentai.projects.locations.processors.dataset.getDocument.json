{
  "name": "documentai_projects_locations_processors_dataset_getDocument",
  "description": "Returns relevant fields present in the requested document.",
  "parameters": {
    "type": "object",
    "properties": {
      "dataset": {
        "type": "string",
        "description": "Required. The resource name of the dataset that the document belongs to . Format: projects/{project}/locations/{location}/processors/{processor}/dataset"
      },
      "documentId.gcsManagedDocId.cwDocId": {
        "type": "string",
        "description": "Id of the document (indexed) managed by Content Warehouse."
      },
      "documentId.gcsManagedDocId.gcsUri": {
        "type": "string",
        "description": "Required. The Cloud Storage URI where the actual document is stored."
      },
      "documentId.revisionRef.latestProcessorVersion": {
        "type": "string",
        "description": "Reads the revision generated by the processor version. The format takes the full resource name of processor version. `projects/{project}/locations/{location}/processors/{processor}/processorVersions/{processorVersion}`"
      },
      "documentId.revisionRef.revisionCase": {
        "enum": [
          "REVISION_CASE_UNSPECIFIED",
          "LATEST_HUMAN_REVIEW",
          "LATEST_TIMESTAMP",
          "BASE_OCR_REVISION"
        ],
        "type": "string",
        "description": "Reads the revision by the predefined case."
      },
      "documentId.revisionRef.revisionId": {
        "type": "string",
        "description": "Reads the revision given by the id."
      },
      "documentId.unmanagedDocId.docId": {
        "type": "string",
        "description": "Required. The id of the document."
      },
      "pageRange.end": {
        "type": "integer",
        "description": "Last page number (one-based index) to be returned."
      },
      "pageRange.start": {
        "type": "integer",
        "description": "First page number (one-based index) to be returned."
      },
      "readMask": {
        "type": "string",
        "description": "If set, only fields listed here will be returned. Otherwise, all fields will be returned by default."
      },
      "$.xgafv": {
        "enum": [
          "1",
          "2"
        ],
        "type": "string",
        "description": "V1 error format."
      },
      "access_token": {
        "type": "string",
        "description": "OAuth access token."
      },
      "alt": {
        "enum": [
          "json",
          "media",
          "proto"
        ],
        "type": "string",
        "description": "Data format for response."
      },
      "callback": {
        "type": "string",
        "description": "JSONP"
      },
      "fields": {
        "type": "string",
        "description": "Selector specifying which fields to include in a partial response."
      },
      "key": {
        "type": "string",
        "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
      },
      "oauth_token": {
        "type": "string",
        "description": "OAuth 2.0 token for the current user."
      },
      "prettyPrint": {
        "type": "boolean",
        "description": "Returns response with indentations and line breaks."
      },
      "quotaUser": {
        "type": "string",
        "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
      },
      "upload_protocol": {
        "type": "string",
        "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
      },
      "uploadType": {
        "type": "string",
        "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
      }
    },
    "required": [
      "dataset"
    ]
  },
  "handler": "http",
  "request": {
    "method": "GET",
    "url": {
      "$uri": "https://documentai.googleapis.com//v1beta3/{dataset}:getDocument{?documentId.gcsManagedDocId.cwDocId,documentId.gcsManagedDocId.gcsUri,documentId.revisionRef.latestProcessorVersion,documentId.revisionRef.revisionCase,documentId.revisionRef.revisionId,documentId.unmanagedDocId.docId,pageRange.end,pageRange.start,readMask,$.xgafv,access_token,alt,callback,fields,key,oauth_token,prettyPrint,quotaUser,upload_protocol,uploadType}"
    }
  },
  "responses": {
    "200": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "**Key properties:**",
        {
          "$ul": [
            [
              "**document**: Document represents the canonical document resource in Document AI. It is an interchange format that provides insights into documents and allows for collaboration between users and Document AI to iterate and optimize for quality.",
              {
                "$ul": [
                  "**content**: Optional. Inline document content, represented as a stream of bytes. Note: As with all `bytes` fields, protobuffers use a pure binary representation, whereas JSON representations use base64.",
                  "**entities**: A list of entities detected on Document.text. For document shards, entities in this list may cross shard boundaries.",
                  "**entityRelations**: Placeholder. Relationship among Document.entities.",
                  [
                    "**error**: The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).",
                    {
                      "$ul": [
                        "**code**: The status code, which should be an enum value of google.rpc.Code.",
                        "**details**: A list of messages that carry the error details. There is a common set of message types for APIs to use.",
                        "**message**: A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client."
                      ]
                    }
                  ],
                  "**mimeType**: An IANA published [media type (MIME type)](https://www.iana.org/assignments/media-types/media-types.xhtml).",
                  "**pages**: Visual page layout for the Document.",
                  "**revisions**: Placeholder. Revision history of this document.",
                  [
                    "**shardInfo**: For a large document, sharding may be performed to produce several document shards. Each document shard contains this field to detail which shard it is.",
                    {
                      "$ul": [
                        "**shardCount**: Total number of shards.",
                        "**shardIndex**: The 0-based index of this shard.",
                        "**textOffset**: The index of the first character in Document.text in the overall document global text."
                      ]
                    }
                  ],
                  "**text**: Optional. UTF-8 encoded text in reading order from the document.",
                  "**textChanges**: Placeholder. A list of text corrections made to Document.text. This is usually used for annotating corrections to OCR mistakes. Text changes for a given revision may not overlap with each other.",
                  "**textStyles**: Styles for the Document.text.",
                  "**uri**: Optional. Currently supports Google Cloud Storage URI of the form `gs://bucket_name/object_name`. Object versioning is not supported. For more information, refer to [Google Cloud Storage Request URIs](https://cloud.google.com/storage/docs/reference-uris)."
                ]
              }
            ]
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    }
  }
}
