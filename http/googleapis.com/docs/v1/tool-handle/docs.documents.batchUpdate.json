{
  "name": "docs_documents_batchUpdate",
  "description": "Applies one or more updates to the document. Each request is validated before being applied. If any request is not valid, then the entire request will fail and nothing will be applied. Some requests have replies to give you some information about how they are applied. Other requests do not need to return information; these each return an empty reply. The order of replies matches that of the requests. For example, suppose you call batchUpdate with four updates, and only the third one returns information. The response would have two empty replies, the reply to the third request, and another empty reply, in that order. Because other users may be editing the document, the document might not exactly reflect your changes: your changes may be altered with respect to collaborator changes. If there are no collaborators, the document should reflect your changes. In any case, the updates in your request are guaranteed to be applied together atomically.",
  "parameters": {
    "type": "object",
    "properties": {
      "documentId": {
        "type": "string",
        "description": "The ID of the document to update."
      },
      "$.xgafv": {
        "enum": [
          "1",
          "2"
        ],
        "type": "string",
        "description": "V1 error format."
      },
      "access_token": {
        "type": "string",
        "description": "OAuth access token."
      },
      "alt": {
        "enum": [
          "json",
          "media",
          "proto"
        ],
        "type": "string",
        "description": "Data format for response."
      },
      "callback": {
        "type": "string",
        "description": "JSONP"
      },
      "fields": {
        "type": "string",
        "description": "Selector specifying which fields to include in a partial response."
      },
      "key": {
        "type": "string",
        "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
      },
      "oauth_token": {
        "type": "string",
        "description": "OAuth 2.0 token for the current user."
      },
      "prettyPrint": {
        "type": "boolean",
        "description": "Returns response with indentations and line breaks."
      },
      "quotaUser": {
        "type": "string",
        "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
      },
      "upload_protocol": {
        "type": "string",
        "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
      },
      "uploadType": {
        "type": "string",
        "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
      },
      "body": {
        "$ref": "#/$defs/BatchUpdateDocumentRequest"
      }
    },
    "required": [
      "documentId"
    ],
    "$defs": {
      "BatchUpdateDocumentRequest": {
        "description": "Request message for BatchUpdateDocument.",
        "properties": {
          "requests": {
            "description": "A list of updates to apply to the document.",
            "items": {
              "$ref": "#/$defs/Request"
            },
            "type": "array"
          },
          "writeControl": {
            "$ref": "#/$defs/WriteControl"
          }
        },
        "type": "object"
      },
      "Request": {
        "description": "A single update to apply to a document.",
        "properties": {
          "createFooter": {
            "$ref": "#/$defs/CreateFooterRequest"
          },
          "createFootnote": {
            "$ref": "#/$defs/CreateFootnoteRequest"
          },
          "createHeader": {
            "$ref": "#/$defs/CreateHeaderRequest"
          },
          "createNamedRange": {
            "$ref": "#/$defs/CreateNamedRangeRequest"
          },
          "createParagraphBullets": {
            "$ref": "#/$defs/CreateParagraphBulletsRequest"
          },
          "deleteContentRange": {
            "$ref": "#/$defs/DeleteContentRangeRequest"
          },
          "deleteFooter": {
            "$ref": "#/$defs/DeleteFooterRequest"
          },
          "deleteHeader": {
            "$ref": "#/$defs/DeleteHeaderRequest"
          },
          "deleteNamedRange": {
            "$ref": "#/$defs/DeleteNamedRangeRequest"
          },
          "deleteParagraphBullets": {
            "$ref": "#/$defs/DeleteParagraphBulletsRequest"
          },
          "deletePositionedObject": {
            "$ref": "#/$defs/DeletePositionedObjectRequest"
          },
          "deleteTableColumn": {
            "$ref": "#/$defs/DeleteTableColumnRequest"
          },
          "deleteTableRow": {
            "$ref": "#/$defs/DeleteTableRowRequest"
          },
          "insertInlineImage": {
            "$ref": "#/$defs/InsertInlineImageRequest"
          },
          "insertPageBreak": {
            "$ref": "#/$defs/InsertPageBreakRequest"
          },
          "insertSectionBreak": {
            "$ref": "#/$defs/InsertSectionBreakRequest"
          },
          "insertTable": {
            "$ref": "#/$defs/InsertTableRequest"
          },
          "insertTableColumn": {
            "$ref": "#/$defs/InsertTableColumnRequest"
          },
          "insertTableRow": {
            "$ref": "#/$defs/InsertTableRowRequest"
          },
          "insertText": {
            "$ref": "#/$defs/InsertTextRequest"
          },
          "mergeTableCells": {
            "$ref": "#/$defs/MergeTableCellsRequest"
          },
          "pinTableHeaderRows": {
            "$ref": "#/$defs/PinTableHeaderRowsRequest"
          },
          "replaceAllText": {
            "$ref": "#/$defs/ReplaceAllTextRequest"
          },
          "replaceImage": {
            "$ref": "#/$defs/ReplaceImageRequest"
          },
          "replaceNamedRangeContent": {
            "$ref": "#/$defs/ReplaceNamedRangeContentRequest"
          },
          "unmergeTableCells": {
            "$ref": "#/$defs/UnmergeTableCellsRequest"
          },
          "updateDocumentStyle": {
            "$ref": "#/$defs/UpdateDocumentStyleRequest"
          },
          "updateParagraphStyle": {
            "$ref": "#/$defs/UpdateParagraphStyleRequest"
          },
          "updateSectionStyle": {
            "$ref": "#/$defs/UpdateSectionStyleRequest"
          },
          "updateTableCellStyle": {
            "$ref": "#/$defs/UpdateTableCellStyleRequest"
          },
          "updateTableColumnProperties": {
            "$ref": "#/$defs/UpdateTableColumnPropertiesRequest"
          },
          "updateTableRowStyle": {
            "$ref": "#/$defs/UpdateTableRowStyleRequest"
          },
          "updateTextStyle": {
            "$ref": "#/$defs/UpdateTextStyleRequest"
          }
        },
        "type": "object"
      },
      "CreateFooterRequest": {
        "description": "Creates a Footer. The new footer is applied to the SectionStyle at the location of the SectionBreak if specified, otherwise it is applied to the DocumentStyle. If a footer of the specified type already exists, a 400 bad request error is returned.",
        "properties": {
          "sectionBreakLocation": {
            "$ref": "#/$defs/Location"
          },
          "type": {
            "description": "The type of footer to create.",
            "enum": [
              "HEADER_FOOTER_TYPE_UNSPECIFIED",
              "DEFAULT"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "Location": {
        "description": "A particular location in the document.",
        "properties": {
          "index": {
            "description": "The zero-based index, in UTF-16 code units. The index is relative to the beginning of the segment specified by segment_id.",
            "format": "int32",
            "type": "integer"
          },
          "segmentId": {
            "description": "The ID of the header, footer or footnote the location is in. An empty segment ID signifies the document's body.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "CreateFootnoteRequest": {
        "description": "Creates a Footnote segment and inserts a new FootnoteReference to it at the given location. The new Footnote segment will contain a space followed by a newline character.",
        "properties": {
          "endOfSegmentLocation": {
            "$ref": "#/$defs/EndOfSegmentLocation"
          },
          "location": {
            "$ref": "#/$defs/Location"
          }
        },
        "type": "object"
      },
      "EndOfSegmentLocation": {
        "description": "Location at the end of a body, header, footer or footnote. The location is immediately before the last newline in the document segment.",
        "properties": {
          "segmentId": {
            "description": "The ID of the header, footer or footnote the location is in. An empty segment ID signifies the document's body.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "CreateHeaderRequest": {
        "description": "Creates a Header. The new header is applied to the SectionStyle at the location of the SectionBreak if specified, otherwise it is applied to the DocumentStyle. If a header of the specified type already exists, a 400 bad request error is returned.",
        "properties": {
          "sectionBreakLocation": {
            "$ref": "#/$defs/Location"
          },
          "type": {
            "description": "The type of header to create.",
            "enum": [
              "HEADER_FOOTER_TYPE_UNSPECIFIED",
              "DEFAULT"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "CreateNamedRangeRequest": {
        "description": "Creates a NamedRange referencing the given range.",
        "properties": {
          "name": {
            "description": "The name of the NamedRange. Names do not need to be unique. Names must be at least 1 character and no more than 256 characters, measured in UTF-16 code units.",
            "type": "string"
          },
          "range": {
            "$ref": "#/$defs/Range"
          }
        },
        "type": "object"
      },
      "Range": {
        "description": "Specifies a contiguous range of text.",
        "properties": {
          "endIndex": {
            "description": "The zero-based end index of this range, exclusive, in UTF-16 code units. In all current uses, an end index must be provided. This field is an Int32Value in order to accommodate future use cases with open-ended ranges.",
            "format": "int32",
            "type": "integer"
          },
          "segmentId": {
            "description": "The ID of the header, footer, or footnote that this range is contained in. An empty segment ID signifies the document's body.",
            "type": "string"
          },
          "startIndex": {
            "description": "The zero-based start index of this range, in UTF-16 code units. In all current uses, a start index must be provided. This field is an Int32Value in order to accommodate future use cases with open-ended ranges.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "CreateParagraphBulletsRequest": {
        "description": "Creates bullets for all of the paragraphs that overlap with the given range. The nesting level of each paragraph will be determined by counting leading tabs in front of each paragraph. To avoid excess space between the bullet and the corresponding paragraph, these leading tabs are removed by this request. This may change the indices of parts of the text. If the paragraph immediately before paragraphs being updated is in a list with a matching preset, the paragraphs being updated are added to that preceding list.",
        "properties": {
          "bulletPreset": {
            "description": "The kinds of bullet glyphs to be used.",
            "enum": [
              "BULLET_GLYPH_PRESET_UNSPECIFIED",
              "BULLET_DISC_CIRCLE_SQUARE",
              "BULLET_DIAMONDX_ARROW3D_SQUARE",
              "BULLET_CHECKBOX",
              "BULLET_ARROW_DIAMOND_DISC",
              "BULLET_STAR_CIRCLE_SQUARE",
              "BULLET_ARROW3D_CIRCLE_SQUARE",
              "BULLET_LEFTTRIANGLE_DIAMOND_DISC",
              "BULLET_DIAMONDX_HOLLOWDIAMOND_SQUARE",
              "BULLET_DIAMOND_CIRCLE_SQUARE",
              "NUMBERED_DECIMAL_ALPHA_ROMAN",
              "NUMBERED_DECIMAL_ALPHA_ROMAN_PARENS",
              "NUMBERED_DECIMAL_NESTED",
              "NUMBERED_UPPERALPHA_ALPHA_ROMAN",
              "NUMBERED_UPPERROMAN_UPPERALPHA_DECIMAL",
              "NUMBERED_ZERODECIMAL_ALPHA_ROMAN"
            ],
            "type": "string"
          },
          "range": {
            "$ref": "#/$defs/Range"
          }
        },
        "type": "object"
      },
      "DeleteContentRangeRequest": {
        "description": "Deletes content from the document.",
        "properties": {
          "range": {
            "$ref": "#/$defs/Range"
          }
        },
        "type": "object"
      },
      "DeleteFooterRequest": {
        "description": "Deletes a Footer from the document.",
        "properties": {
          "footerId": {
            "description": "The id of the footer to delete. If this footer is defined on DocumentStyle, the reference to this footer is removed, resulting in no footer of that type for the first section of the document. If this footer is defined on a SectionStyle, the reference to this footer is removed and the footer of that type is now continued from the previous section.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "DeleteHeaderRequest": {
        "description": "Deletes a Header from the document.",
        "properties": {
          "headerId": {
            "description": "The id of the header to delete. If this header is defined on DocumentStyle, the reference to this header is removed, resulting in no header of that type for the first section of the document. If this header is defined on a SectionStyle, the reference to this header is removed and the header of that type is now continued from the previous section.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "DeleteNamedRangeRequest": {
        "description": "Deletes a NamedRange.",
        "properties": {
          "name": {
            "description": "The name of the range(s) to delete. All named ranges with the given name will be deleted.",
            "type": "string"
          },
          "namedRangeId": {
            "description": "The ID of the named range to delete.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "DeleteParagraphBulletsRequest": {
        "description": "Deletes bullets from all of the paragraphs that overlap with the given range. The nesting level of each paragraph will be visually preserved by adding indent to the start of the corresponding paragraph.",
        "properties": {
          "range": {
            "$ref": "#/$defs/Range"
          }
        },
        "type": "object"
      },
      "DeletePositionedObjectRequest": {
        "description": "Deletes a PositionedObject from the document.",
        "properties": {
          "objectId": {
            "description": "The ID of the positioned object to delete.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "DeleteTableColumnRequest": {
        "description": "Deletes a column from a table.",
        "properties": {
          "tableCellLocation": {
            "$ref": "#/$defs/TableCellLocation"
          }
        },
        "type": "object"
      },
      "TableCellLocation": {
        "description": "Location of a single cell within a table.",
        "properties": {
          "columnIndex": {
            "description": "The zero-based column index. For example, the second column in the table has a column index of 1.",
            "format": "int32",
            "type": "integer"
          },
          "rowIndex": {
            "description": "The zero-based row index. For example, the second row in the table has a row index of 1.",
            "format": "int32",
            "type": "integer"
          },
          "tableStartLocation": {
            "$ref": "#/$defs/Location"
          }
        },
        "type": "object"
      },
      "DeleteTableRowRequest": {
        "description": "Deletes a row from a table.",
        "properties": {
          "tableCellLocation": {
            "$ref": "#/$defs/TableCellLocation"
          }
        },
        "type": "object"
      },
      "InsertInlineImageRequest": {
        "description": "Inserts an InlineObject containing an image at the given location.",
        "properties": {
          "endOfSegmentLocation": {
            "$ref": "#/$defs/EndOfSegmentLocation"
          },
          "location": {
            "$ref": "#/$defs/Location"
          },
          "objectSize": {
            "$ref": "#/$defs/Size"
          },
          "uri": {
            "description": "The image URI. The image is fetched once at insertion time and a copy is stored for display inside the document. Images must be less than 50MB in size, cannot exceed 25 megapixels, and must be in one of PNG, JPEG, or GIF format. The provided URI must be publicly accessible and at most 2 kB in length. The URI itself is saved with the image, and exposed via the ImageProperties.content_uri field.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "Size": {
        "description": "A width and height.",
        "properties": {
          "height": {
            "$ref": "#/$defs/Dimension"
          },
          "width": {
            "$ref": "#/$defs/Dimension"
          }
        },
        "type": "object"
      },
      "Dimension": {
        "description": "A magnitude in a single direction in the specified units.",
        "properties": {
          "magnitude": {
            "description": "The magnitude.",
            "format": "double",
            "type": "number"
          },
          "unit": {
            "description": "The units for magnitude.",
            "enum": [
              "UNIT_UNSPECIFIED",
              "PT"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "InsertPageBreakRequest": {
        "description": "Inserts a page break followed by a newline at the specified location.",
        "properties": {
          "endOfSegmentLocation": {
            "$ref": "#/$defs/EndOfSegmentLocation"
          },
          "location": {
            "$ref": "#/$defs/Location"
          }
        },
        "type": "object"
      },
      "InsertSectionBreakRequest": {
        "description": "Inserts a section break at the given location. A newline character will be inserted before the section break.",
        "properties": {
          "endOfSegmentLocation": {
            "$ref": "#/$defs/EndOfSegmentLocation"
          },
          "location": {
            "$ref": "#/$defs/Location"
          },
          "sectionType": {
            "description": "The type of section to insert.",
            "enum": [
              "SECTION_TYPE_UNSPECIFIED",
              "CONTINUOUS",
              "NEXT_PAGE"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "InsertTableRequest": {
        "description": "Inserts a table at the specified location. A newline character will be inserted before the inserted table.",
        "properties": {
          "columns": {
            "description": "The number of columns in the table.",
            "format": "int32",
            "type": "integer"
          },
          "endOfSegmentLocation": {
            "$ref": "#/$defs/EndOfSegmentLocation"
          },
          "location": {
            "$ref": "#/$defs/Location"
          },
          "rows": {
            "description": "The number of rows in the table.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "InsertTableColumnRequest": {
        "description": "Inserts an empty column into a table.",
        "properties": {
          "insertRight": {
            "description": "Whether to insert new column to the right of the reference cell location. - `True`: insert to the right. - `False`: insert to the left.",
            "type": "boolean"
          },
          "tableCellLocation": {
            "$ref": "#/$defs/TableCellLocation"
          }
        },
        "type": "object"
      },
      "InsertTableRowRequest": {
        "description": "Inserts an empty row into a table.",
        "properties": {
          "insertBelow": {
            "description": "Whether to insert new row below the reference cell location. - `True`: insert below the cell. - `False`: insert above the cell.",
            "type": "boolean"
          },
          "tableCellLocation": {
            "$ref": "#/$defs/TableCellLocation"
          }
        },
        "type": "object"
      },
      "InsertTextRequest": {
        "description": "Inserts text at the specified location.",
        "properties": {
          "endOfSegmentLocation": {
            "$ref": "#/$defs/EndOfSegmentLocation"
          },
          "location": {
            "$ref": "#/$defs/Location"
          },
          "text": {
            "description": "The text to be inserted. Inserting a newline character will implicitly create a new Paragraph at that index. The paragraph style of the new paragraph will be copied from the paragraph at the current insertion index, including lists and bullets. Text styles for inserted text will be determined automatically, generally preserving the styling of neighboring text. In most cases, the text style for the inserted text will match the text immediately before the insertion index. Some control characters (U+0000-U+0008, U+000C-U+001F) and characters from the Unicode Basic Multilingual Plane Private Use Area (U+E000-U+F8FF) will be stripped out of the inserted text.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "MergeTableCellsRequest": {
        "description": "Merges cells in a Table.",
        "properties": {
          "tableRange": {
            "$ref": "#/$defs/TableRange"
          }
        },
        "type": "object"
      },
      "TableRange": {
        "description": "A table range represents a reference to a subset of a table. It's important to note that the cells specified by a table range do not necessarily form a rectangle. For example, let's say we have a 3 x 3 table where all the cells of the last row are merged together. The table looks like this: [ ] A table range with table cell location = (table_start_location, row = 0, column = 0), row span = 3 and column span = 2 specifies the following cells: x x [ x x x ]",
        "properties": {
          "columnSpan": {
            "description": "The column span of the table range.",
            "format": "int32",
            "type": "integer"
          },
          "rowSpan": {
            "description": "The row span of the table range.",
            "format": "int32",
            "type": "integer"
          },
          "tableCellLocation": {
            "$ref": "#/$defs/TableCellLocation"
          }
        },
        "type": "object"
      },
      "PinTableHeaderRowsRequest": {
        "description": "Updates the number of pinned table header rows in a table.",
        "properties": {
          "pinnedHeaderRowsCount": {
            "description": "The number of table rows to pin, where 0 implies that all rows are unpinned.",
            "format": "int32",
            "type": "integer"
          },
          "tableStartLocation": {
            "$ref": "#/$defs/Location"
          }
        },
        "type": "object"
      },
      "ReplaceAllTextRequest": {
        "description": "Replaces all instances of text matching a criteria with replace text.",
        "properties": {
          "containsText": {
            "$ref": "#/$defs/SubstringMatchCriteria"
          },
          "replaceText": {
            "description": "The text that will replace the matched text.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "SubstringMatchCriteria": {
        "description": "A criteria that matches a specific string of text in the document.",
        "properties": {
          "matchCase": {
            "description": "Indicates whether the search should respect case: - `True`: the search is case sensitive. - `False`: the search is case insensitive.",
            "type": "boolean"
          },
          "text": {
            "description": "The text to search for in the document.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "ReplaceImageRequest": {
        "description": "Replaces an existing image with a new image. Replacing an image removes some image effects from the existing image in order to mirror the behavior of the Docs editor.",
        "properties": {
          "imageObjectId": {
            "description": "The ID of the existing image that will be replaced. The ID can be retrieved from the response of a get request.",
            "type": "string"
          },
          "imageReplaceMethod": {
            "description": "The replacement method.",
            "enum": [
              "IMAGE_REPLACE_METHOD_UNSPECIFIED",
              "CENTER_CROP"
            ],
            "type": "string"
          },
          "uri": {
            "description": "The URI of the new image. The image is fetched once at insertion time and a copy is stored for display inside the document. Images must be less than 50MB, cannot exceed 25 megapixels, and must be in PNG, JPEG, or GIF format. The provided URI can't surpass 2 KB in length. The URI is saved with the image, and exposed through the ImageProperties.source_uri field.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "ReplaceNamedRangeContentRequest": {
        "description": "Replaces the contents of the specified NamedRange or NamedRanges with the given replacement content. Note that an individual NamedRange may consist of multiple discontinuous ranges. In this case, only the content in the first range will be replaced. The other ranges and their content will be deleted. In cases where replacing or deleting any ranges would result in an invalid document structure, a 400 bad request error is returned.",
        "properties": {
          "namedRangeId": {
            "description": "The ID of the named range whose content will be replaced. If there is no named range with the given ID a 400 bad request error is returned.",
            "type": "string"
          },
          "namedRangeName": {
            "description": "The name of the NamedRanges whose content will be replaced. If there are multiple named ranges with the given name, then the content of each one will be replaced. If there are no named ranges with the given name, then the request will be a no-op.",
            "type": "string"
          },
          "text": {
            "description": "Replaces the content of the specified named range(s) with the given text.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "UnmergeTableCellsRequest": {
        "description": "Unmerges cells in a Table.",
        "properties": {
          "tableRange": {
            "$ref": "#/$defs/TableRange"
          }
        },
        "type": "object"
      },
      "UpdateDocumentStyleRequest": {
        "description": "Updates the DocumentStyle.",
        "properties": {
          "documentStyle": {
            "$ref": "#/$defs/DocumentStyle"
          },
          "fields": {
            "description": "The fields that should be updated. At least one field must be specified. The root `document_style` is implied and should not be specified. A single `\"*\"` can be used as short-hand for listing every field. For example to update the background, set `fields` to `\"background\"`.",
            "format": "google-fieldmask",
            "type": "string"
          }
        },
        "type": "object"
      },
      "DocumentStyle": {
        "description": "The style of the document.",
        "properties": {
          "background": {
            "$ref": "#/$defs/Background"
          },
          "defaultFooterId": {
            "description": "The ID of the default footer. If not set, there's no default footer. This property is read-only.",
            "type": "string"
          },
          "defaultHeaderId": {
            "description": "The ID of the default header. If not set, there's no default header. This property is read-only.",
            "type": "string"
          },
          "evenPageFooterId": {
            "description": "The ID of the footer used only for even pages. The value of use_even_page_header_footer determines whether to use the default_footer_id or this value for the footer on even pages. If not set, there's no even page footer. This property is read-only.",
            "type": "string"
          },
          "evenPageHeaderId": {
            "description": "The ID of the header used only for even pages. The value of use_even_page_header_footer determines whether to use the default_header_id or this value for the header on even pages. If not set, there's no even page header. This property is read-only.",
            "type": "string"
          },
          "firstPageFooterId": {
            "description": "The ID of the footer used only for the first page. If not set then a unique footer for the first page does not exist. The value of use_first_page_header_footer determines whether to use the default_footer_id or this value for the footer on the first page. If not set, there's no first page footer. This property is read-only.",
            "type": "string"
          },
          "firstPageHeaderId": {
            "description": "The ID of the header used only for the first page. If not set then a unique header for the first page does not exist. The value of use_first_page_header_footer determines whether to use the default_header_id or this value for the header on the first page. If not set, there's no first page header. This property is read-only.",
            "type": "string"
          },
          "flipPageOrientation": {
            "description": "Optional. Indicates whether to flip the dimensions of the page_size, which allows changing the page orientation between portrait and landscape.",
            "type": "boolean"
          },
          "marginBottom": {
            "$ref": "#/$defs/Dimension"
          },
          "marginFooter": {
            "$ref": "#/$defs/Dimension"
          },
          "marginHeader": {
            "$ref": "#/$defs/Dimension"
          },
          "marginLeft": {
            "$ref": "#/$defs/Dimension"
          },
          "marginRight": {
            "$ref": "#/$defs/Dimension"
          },
          "marginTop": {
            "$ref": "#/$defs/Dimension"
          },
          "pageNumberStart": {
            "description": "The page number from which to start counting the number of pages.",
            "format": "int32",
            "type": "integer"
          },
          "pageSize": {
            "$ref": "#/$defs/Size"
          },
          "useCustomHeaderFooterMargins": {
            "description": "Indicates whether DocumentStyle margin_header, SectionStyle margin_header and DocumentStyle margin_footer, SectionStyle margin_footer are respected. When false, the default values in the Docs editor for header and footer margin are used. This property is read-only.",
            "type": "boolean"
          },
          "useEvenPageHeaderFooter": {
            "description": "Indicates whether to use the even page header / footer IDs for the even pages.",
            "type": "boolean"
          },
          "useFirstPageHeaderFooter": {
            "description": "Indicates whether to use the first page header / footer IDs for the first page.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "Background": {
        "description": "Represents the background of a document.",
        "properties": {
          "color": {
            "$ref": "#/$defs/OptionalColor"
          }
        },
        "type": "object"
      },
      "OptionalColor": {
        "description": "A color that can either be fully opaque or fully transparent.",
        "properties": {
          "color": {
            "$ref": "#/$defs/Color"
          }
        },
        "type": "object"
      },
      "Color": {
        "description": "A solid color.",
        "properties": {
          "rgbColor": {
            "$ref": "#/$defs/RgbColor"
          }
        },
        "type": "object"
      },
      "RgbColor": {
        "description": "An RGB color.",
        "properties": {
          "blue": {
            "description": "The blue component of the color, from 0.0 to 1.0.",
            "format": "float",
            "type": "number"
          },
          "green": {
            "description": "The green component of the color, from 0.0 to 1.0.",
            "format": "float",
            "type": "number"
          },
          "red": {
            "description": "The red component of the color, from 0.0 to 1.0.",
            "format": "float",
            "type": "number"
          }
        },
        "type": "object"
      },
      "UpdateParagraphStyleRequest": {
        "description": "Update the styling of all paragraphs that overlap with the given range.",
        "properties": {
          "fields": {
            "description": "The fields that should be updated. At least one field must be specified. The root `paragraph_style` is implied and should not be specified. A single `\"*\"` can be used as short-hand for listing every field. For example, to update the paragraph style's alignment property, set `fields` to `\"alignment\"`. To reset a property to its default value, include its field name in the field mask but leave the field itself unset.",
            "format": "google-fieldmask",
            "type": "string"
          },
          "paragraphStyle": {
            "$ref": "#/$defs/ParagraphStyle"
          },
          "range": {
            "$ref": "#/$defs/Range"
          }
        },
        "type": "object"
      },
      "ParagraphStyle": {
        "description": "Styles that apply to a whole paragraph. Inherited paragraph styles are represented as unset fields in this message. A paragraph style's parent depends on where the paragraph style is defined: * The ParagraphStyle on a Paragraph inherits from the paragraph's corresponding named style type. * The ParagraphStyle on a named style inherits from the normal text named style. * The ParagraphStyle of the normal text named style inherits from the default paragraph style in the Docs editor. * The ParagraphStyle on a Paragraph element that's contained in a table may inherit its paragraph style from the table style. If the paragraph style does not inherit from a parent, unsetting fields will revert the style to a value matching the defaults in the Docs editor.",
        "properties": {
          "alignment": {
            "description": "The text alignment for this paragraph.",
            "enum": [
              "ALIGNMENT_UNSPECIFIED",
              "START",
              "CENTER",
              "END",
              "JUSTIFIED"
            ],
            "type": "string"
          },
          "avoidWidowAndOrphan": {
            "description": "Whether to avoid widows and orphans for the paragraph. If unset, the value is inherited from the parent.",
            "type": "boolean"
          },
          "borderBetween": {
            "$ref": "#/$defs/ParagraphBorder"
          },
          "borderBottom": {
            "$ref": "#/$defs/ParagraphBorder"
          },
          "borderLeft": {
            "$ref": "#/$defs/ParagraphBorder"
          },
          "borderRight": {
            "$ref": "#/$defs/ParagraphBorder"
          },
          "borderTop": {
            "$ref": "#/$defs/ParagraphBorder"
          },
          "direction": {
            "description": "The text direction of this paragraph. If unset, the value defaults to LEFT_TO_RIGHT since paragraph direction is not inherited.",
            "enum": [
              "CONTENT_DIRECTION_UNSPECIFIED",
              "LEFT_TO_RIGHT",
              "RIGHT_TO_LEFT"
            ],
            "type": "string"
          },
          "headingId": {
            "description": "The heading ID of the paragraph. If empty, then this paragraph is not a heading. This property is read-only.",
            "type": "string"
          },
          "indentEnd": {
            "$ref": "#/$defs/Dimension"
          },
          "indentFirstLine": {
            "$ref": "#/$defs/Dimension"
          },
          "indentStart": {
            "$ref": "#/$defs/Dimension"
          },
          "keepLinesTogether": {
            "description": "Whether all lines of the paragraph should be laid out on the same page or column if possible. If unset, the value is inherited from the parent.",
            "type": "boolean"
          },
          "keepWithNext": {
            "description": "Whether at least a part of this paragraph should be laid out on the same page or column as the next paragraph if possible. If unset, the value is inherited from the parent.",
            "type": "boolean"
          },
          "lineSpacing": {
            "description": "The amount of space between lines, as a percentage of normal, where normal is represented as 100.0. If unset, the value is inherited from the parent.",
            "format": "float",
            "type": "number"
          },
          "namedStyleType": {
            "description": "The named style type of the paragraph. Since updating the named style type affects other properties within ParagraphStyle, the named style type is applied before the other properties are updated.",
            "enum": [
              "NAMED_STYLE_TYPE_UNSPECIFIED",
              "NORMAL_TEXT",
              "TITLE",
              "SUBTITLE",
              "HEADING_1",
              "HEADING_2",
              "HEADING_3",
              "HEADING_4",
              "HEADING_5",
              "HEADING_6"
            ],
            "type": "string"
          },
          "pageBreakBefore": {
            "description": "Whether the current paragraph should always start at the beginning of a page. If unset, the value is inherited from the parent. Attempting to update page_break_before for paragraphs in unsupported regions, including Table, Header, Footer and Footnote, can result in an invalid document state that returns a 400 bad request error.",
            "type": "boolean"
          },
          "shading": {
            "$ref": "#/$defs/Shading"
          },
          "spaceAbove": {
            "$ref": "#/$defs/Dimension"
          },
          "spaceBelow": {
            "$ref": "#/$defs/Dimension"
          },
          "spacingMode": {
            "description": "The spacing mode for the paragraph.",
            "enum": [
              "SPACING_MODE_UNSPECIFIED",
              "NEVER_COLLAPSE",
              "COLLAPSE_LISTS"
            ],
            "type": "string"
          },
          "tabStops": {
            "description": "A list of the tab stops for this paragraph. The list of tab stops is not inherited. This property is read-only.",
            "items": {
              "$ref": "#/$defs/TabStop"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "ParagraphBorder": {
        "description": "A border around a paragraph.",
        "properties": {
          "color": {
            "$ref": "#/$defs/OptionalColor"
          },
          "dashStyle": {
            "description": "The dash style of the border.",
            "enum": [
              "DASH_STYLE_UNSPECIFIED",
              "SOLID",
              "DOT",
              "DASH"
            ],
            "type": "string"
          },
          "padding": {
            "$ref": "#/$defs/Dimension"
          },
          "width": {
            "$ref": "#/$defs/Dimension"
          }
        },
        "type": "object"
      },
      "Shading": {
        "description": "The shading of a paragraph.",
        "properties": {
          "backgroundColor": {
            "$ref": "#/$defs/OptionalColor"
          }
        },
        "type": "object"
      },
      "TabStop": {
        "description": "A tab stop within a paragraph.",
        "properties": {
          "alignment": {
            "description": "The alignment of this tab stop. If unset, the value defaults to START.",
            "enum": [
              "TAB_STOP_ALIGNMENT_UNSPECIFIED",
              "START",
              "CENTER",
              "END"
            ],
            "type": "string"
          },
          "offset": {
            "$ref": "#/$defs/Dimension"
          }
        },
        "type": "object"
      },
      "UpdateSectionStyleRequest": {
        "description": "Updates the SectionStyle.",
        "properties": {
          "fields": {
            "description": "The fields that should be updated. At least one field must be specified. The root `section_style` is implied and must not be specified. A single `\"*\"` can be used as short-hand for listing every field. For example to update the left margin, set `fields` to `\"margin_left\"`.",
            "format": "google-fieldmask",
            "type": "string"
          },
          "range": {
            "$ref": "#/$defs/Range"
          },
          "sectionStyle": {
            "$ref": "#/$defs/SectionStyle"
          }
        },
        "type": "object"
      },
      "SectionStyle": {
        "description": "The styling that applies to a section.",
        "properties": {
          "columnProperties": {
            "description": "The section's columns properties. If empty, the section contains one column with the default properties in the Docs editor. A section can be updated to have no more than 3 columns. When updating this property, setting a concrete value is required. Unsetting this property will result in a 400 bad request error.",
            "items": {
              "$ref": "#/$defs/SectionColumnProperties"
            },
            "type": "array"
          },
          "columnSeparatorStyle": {
            "description": "The style of column separators. This style can be set even when there's one column in the section. When updating this property, setting a concrete value is required. Unsetting this property results in a 400 bad request error.",
            "enum": [
              "COLUMN_SEPARATOR_STYLE_UNSPECIFIED",
              "NONE",
              "BETWEEN_EACH_COLUMN"
            ],
            "type": "string"
          },
          "contentDirection": {
            "description": "The content direction of this section. If unset, the value defaults to LEFT_TO_RIGHT. When updating this property, setting a concrete value is required. Unsetting this property results in a 400 bad request error.",
            "enum": [
              "CONTENT_DIRECTION_UNSPECIFIED",
              "LEFT_TO_RIGHT",
              "RIGHT_TO_LEFT"
            ],
            "type": "string"
          },
          "defaultFooterId": {
            "description": "The ID of the default footer. If unset, the value inherits from the previous SectionBreak's SectionStyle. If the value is unset in the first SectionBreak, it inherits from DocumentStyle's default_footer_id. This property is read-only.",
            "type": "string"
          },
          "defaultHeaderId": {
            "description": "The ID of the default header. If unset, the value inherits from the previous SectionBreak's SectionStyle. If the value is unset in the first SectionBreak, it inherits from DocumentStyle's default_header_id. This property is read-only.",
            "type": "string"
          },
          "evenPageFooterId": {
            "description": "The ID of the footer used only for even pages. If the value of DocumentStyle's use_even_page_header_footer is true, this value is used for the footers on even pages in the section. If it is false, the footers on even pages use the default_footer_id. If unset, the value inherits from the previous SectionBreak's SectionStyle. If the value is unset in the first SectionBreak, it inherits from DocumentStyle's even_page_footer_id. This property is read-only.",
            "type": "string"
          },
          "evenPageHeaderId": {
            "description": "The ID of the header used only for even pages. If the value of DocumentStyle's use_even_page_header_footer is true, this value is used for the headers on even pages in the section. If it is false, the headers on even pages use the default_header_id. If unset, the value inherits from the previous SectionBreak's SectionStyle. If the value is unset in the first SectionBreak, it inherits from DocumentStyle's even_page_header_id. This property is read-only.",
            "type": "string"
          },
          "firstPageFooterId": {
            "description": "The ID of the footer used only for the first page of the section. If use_first_page_header_footer is true, this value is used for the footer on the first page of the section. If it's false, the footer on the first page of the section uses the default_footer_id. If unset, the value inherits from the previous SectionBreak's SectionStyle. If the value is unset in the first SectionBreak, it inherits from DocumentStyle's first_page_footer_id. This property is read-only.",
            "type": "string"
          },
          "firstPageHeaderId": {
            "description": "The ID of the header used only for the first page of the section. If use_first_page_header_footer is true, this value is used for the header on the first page of the section. If it's false, the header on the first page of the section uses the default_header_id. If unset, the value inherits from the previous SectionBreak's SectionStyle. If the value is unset in the first SectionBreak, it inherits from DocumentStyle's first_page_header_id. This property is read-only.",
            "type": "string"
          },
          "flipPageOrientation": {
            "description": "Optional. Indicates whether to flip the dimensions of DocumentStyle's page_size for this section, which allows changing the page orientation between portrait and landscape. If unset, the value inherits from DocumentStyle's flip_page_orientation. When updating this property, setting a concrete value is required. Unsetting this property results in a 400 bad request error.",
            "type": "boolean"
          },
          "marginBottom": {
            "$ref": "#/$defs/Dimension"
          },
          "marginFooter": {
            "$ref": "#/$defs/Dimension"
          },
          "marginHeader": {
            "$ref": "#/$defs/Dimension"
          },
          "marginLeft": {
            "$ref": "#/$defs/Dimension"
          },
          "marginRight": {
            "$ref": "#/$defs/Dimension"
          },
          "marginTop": {
            "$ref": "#/$defs/Dimension"
          },
          "pageNumberStart": {
            "description": "The page number from which to start counting the number of pages for this section. If unset, page numbering continues from the previous section. If the value is unset in the first SectionBreak, refer to DocumentStyle's page_number_start. When updating this property, setting a concrete value is required. Unsetting this property results in a 400 bad request error.",
            "format": "int32",
            "type": "integer"
          },
          "sectionType": {
            "description": "Output only. The type of section.",
            "enum": [
              "SECTION_TYPE_UNSPECIFIED",
              "CONTINUOUS",
              "NEXT_PAGE"
            ],
            "type": "string"
          },
          "useFirstPageHeaderFooter": {
            "description": "Indicates whether to use the first page header / footer IDs for the first page of the section. If unset, it inherits from DocumentStyle's use_first_page_header_footer for the first section. If the value is unset for subsequent sectors, it should be interpreted as false. When updating this property, setting a concrete value is required. Unsetting this property results in a 400 bad request error.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "SectionColumnProperties": {
        "description": "Properties that apply to a section's column.",
        "properties": {
          "paddingEnd": {
            "$ref": "#/$defs/Dimension"
          },
          "width": {
            "$ref": "#/$defs/Dimension"
          }
        },
        "type": "object"
      },
      "UpdateTableCellStyleRequest": {
        "description": "Updates the style of a range of table cells.",
        "properties": {
          "fields": {
            "description": "The fields that should be updated. At least one field must be specified. The root `tableCellStyle` is implied and should not be specified. A single `\"*\"` can be used as short-hand for listing every field. For example to update the table cell background color, set `fields` to `\"backgroundColor\"`. To reset a property to its default value, include its field name in the field mask but leave the field itself unset.",
            "format": "google-fieldmask",
            "type": "string"
          },
          "tableCellStyle": {
            "$ref": "#/$defs/TableCellStyle"
          },
          "tableRange": {
            "$ref": "#/$defs/TableRange"
          },
          "tableStartLocation": {
            "$ref": "#/$defs/Location"
          }
        },
        "type": "object"
      },
      "TableCellStyle": {
        "description": "The style of a TableCell. Inherited table cell styles are represented as unset fields in this message. A table cell style can inherit from the table's style.",
        "properties": {
          "backgroundColor": {
            "$ref": "#/$defs/OptionalColor"
          },
          "borderBottom": {
            "$ref": "#/$defs/TableCellBorder"
          },
          "borderLeft": {
            "$ref": "#/$defs/TableCellBorder"
          },
          "borderRight": {
            "$ref": "#/$defs/TableCellBorder"
          },
          "borderTop": {
            "$ref": "#/$defs/TableCellBorder"
          },
          "columnSpan": {
            "description": "The column span of the cell. This property is read-only.",
            "format": "int32",
            "type": "integer"
          },
          "contentAlignment": {
            "description": "The alignment of the content in the table cell. The default alignment matches the alignment for newly created table cells in the Docs editor.",
            "enum": [
              "CONTENT_ALIGNMENT_UNSPECIFIED",
              "CONTENT_ALIGNMENT_UNSUPPORTED",
              "TOP",
              "MIDDLE",
              "BOTTOM"
            ],
            "type": "string"
          },
          "paddingBottom": {
            "$ref": "#/$defs/Dimension"
          },
          "paddingLeft": {
            "$ref": "#/$defs/Dimension"
          },
          "paddingRight": {
            "$ref": "#/$defs/Dimension"
          },
          "paddingTop": {
            "$ref": "#/$defs/Dimension"
          },
          "rowSpan": {
            "description": "The row span of the cell. This property is read-only.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "TableCellBorder": {
        "description": "A border around a table cell. Table cell borders cannot be transparent. To hide a table cell border, make its width 0.",
        "properties": {
          "color": {
            "$ref": "#/$defs/OptionalColor"
          },
          "dashStyle": {
            "description": "The dash style of the border.",
            "enum": [
              "DASH_STYLE_UNSPECIFIED",
              "SOLID",
              "DOT",
              "DASH"
            ],
            "type": "string"
          },
          "width": {
            "$ref": "#/$defs/Dimension"
          }
        },
        "type": "object"
      },
      "UpdateTableColumnPropertiesRequest": {
        "description": "Updates the TableColumnProperties of columns in a table.",
        "properties": {
          "columnIndices": {
            "description": "The list of zero-based column indices whose property should be updated. If no indices are specified, all columns will be updated.",
            "items": {
              "format": "int32",
              "type": "integer"
            },
            "type": "array"
          },
          "fields": {
            "description": "The fields that should be updated. At least one field must be specified. The root `tableColumnProperties` is implied and should not be specified. A single `\"*\"` can be used as short-hand for listing every field. For example to update the column width, set `fields` to `\"width\"`.",
            "format": "google-fieldmask",
            "type": "string"
          },
          "tableColumnProperties": {
            "$ref": "#/$defs/TableColumnProperties"
          },
          "tableStartLocation": {
            "$ref": "#/$defs/Location"
          }
        },
        "type": "object"
      },
      "TableColumnProperties": {
        "description": "The properties of a column in a table.",
        "properties": {
          "width": {
            "$ref": "#/$defs/Dimension"
          },
          "widthType": {
            "description": "The width type of the column.",
            "enum": [
              "WIDTH_TYPE_UNSPECIFIED",
              "EVENLY_DISTRIBUTED",
              "FIXED_WIDTH"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "UpdateTableRowStyleRequest": {
        "description": "Updates the TableRowStyle of rows in a table.",
        "properties": {
          "fields": {
            "description": "The fields that should be updated. At least one field must be specified. The root `tableRowStyle` is implied and should not be specified. A single `\"*\"` can be used as short-hand for listing every field. For example to update the minimum row height, set `fields` to `\"min_row_height\"`.",
            "format": "google-fieldmask",
            "type": "string"
          },
          "rowIndices": {
            "description": "The list of zero-based row indices whose style should be updated. If no indices are specified, all rows will be updated.",
            "items": {
              "format": "int32",
              "type": "integer"
            },
            "type": "array"
          },
          "tableRowStyle": {
            "$ref": "#/$defs/TableRowStyle"
          },
          "tableStartLocation": {
            "$ref": "#/$defs/Location"
          }
        },
        "type": "object"
      },
      "TableRowStyle": {
        "description": "Styles that apply to a table row.",
        "properties": {
          "minRowHeight": {
            "$ref": "#/$defs/Dimension"
          },
          "preventOverflow": {
            "description": "Whether the row cannot overflow across page or column boundaries.",
            "type": "boolean"
          },
          "tableHeader": {
            "description": "Whether the row is a table header.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "UpdateTextStyleRequest": {
        "description": "Update the styling of text.",
        "properties": {
          "fields": {
            "description": "The fields that should be updated. At least one field must be specified. The root `text_style` is implied and should not be specified. A single `\"*\"` can be used as short-hand for listing every field. For example, to update the text style to bold, set `fields` to `\"bold\"`. To reset a property to its default value, include its field name in the field mask but leave the field itself unset.",
            "format": "google-fieldmask",
            "type": "string"
          },
          "range": {
            "$ref": "#/$defs/Range"
          },
          "textStyle": {
            "$ref": "#/$defs/TextStyle"
          }
        },
        "type": "object"
      },
      "TextStyle": {
        "description": "Represents the styling that can be applied to text. Inherited text styles are represented as unset fields in this message. A text style's parent depends on where the text style is defined: * The TextStyle of text in a Paragraph inherits from the paragraph's corresponding named style type. * The TextStyle on a named style inherits from the normal text named style. * The TextStyle of the normal text named style inherits from the default text style in the Docs editor. * The TextStyle on a Paragraph element that's contained in a table may inherit its text style from the table style. If the text style does not inherit from a parent, unsetting fields will revert the style to a value matching the defaults in the Docs editor.",
        "properties": {
          "backgroundColor": {
            "$ref": "#/$defs/OptionalColor"
          },
          "baselineOffset": {
            "description": "The text's vertical offset from its normal position. Text with `SUPERSCRIPT` or `SUBSCRIPT` baseline offsets is automatically rendered in a smaller font size, computed based on the `font_size` field. Changes in this field don't affect the `font_size`.",
            "enum": [
              "BASELINE_OFFSET_UNSPECIFIED",
              "NONE",
              "SUPERSCRIPT",
              "SUBSCRIPT"
            ],
            "type": "string"
          },
          "bold": {
            "description": "Whether or not the text is rendered as bold.",
            "type": "boolean"
          },
          "fontSize": {
            "$ref": "#/$defs/Dimension"
          },
          "foregroundColor": {
            "$ref": "#/$defs/OptionalColor"
          },
          "italic": {
            "description": "Whether or not the text is italicized.",
            "type": "boolean"
          },
          "link": {
            "$ref": "#/$defs/Link"
          },
          "smallCaps": {
            "description": "Whether or not the text is in small capital letters.",
            "type": "boolean"
          },
          "strikethrough": {
            "description": "Whether or not the text is struck through.",
            "type": "boolean"
          },
          "underline": {
            "description": "Whether or not the text is underlined.",
            "type": "boolean"
          },
          "weightedFontFamily": {
            "$ref": "#/$defs/WeightedFontFamily"
          }
        },
        "type": "object"
      },
      "Link": {
        "description": "A reference to another portion of a document or an external URL resource.",
        "properties": {
          "bookmarkId": {
            "description": "The ID of a bookmark in this document.",
            "type": "string"
          },
          "headingId": {
            "description": "The ID of a heading in this document.",
            "type": "string"
          },
          "url": {
            "description": "An external URL.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "WeightedFontFamily": {
        "description": "Represents a font family and weight of text.",
        "properties": {
          "fontFamily": {
            "description": "The font family of the text. The font family can be any font from the Font menu in Docs or from [Google Fonts] (https://fonts.google.com/). If the font name is unrecognized, the text is rendered in `Arial`.",
            "type": "string"
          },
          "weight": {
            "description": "The weight of the font. This field can have any value that's a multiple of `100` between `100` and `900`, inclusive. This range corresponds to the numerical values described in the CSS 2.1 Specification, [section 15.6](https://www.w3.org/TR/CSS21/fonts.html#font-boldness), with non-numerical values disallowed. The default value is `400` (\"normal\"). The font weight makes up just one component of the rendered font weight. A combination of the `weight` and the text style's resolved `bold` value determine the rendered weight, after accounting for inheritance: * If the text is bold and the weight is less than `400`, the rendered weight is 400. * If the text is bold and the weight is greater than or equal to `400` but is less than `700`, the rendered weight is `700`. * If the weight is greater than or equal to `700`, the rendered weight is equal to the weight. * If the text is not bold, the rendered weight is equal to the weight.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "WriteControl": {
        "description": "Provides control over how write requests are executed.",
        "properties": {
          "requiredRevisionId": {
            "description": "The optional revision ID of the document the write request is applied to. If this is not the latest revision of the document, the request is not processed and returns a 400 bad request error. When a required revision ID is returned in a response, it indicates the revision ID of the document after the request was applied.",
            "type": "string"
          },
          "targetRevisionId": {
            "description": "The optional target revision ID of the document the write request is applied to. If collaborator changes have occurred after the document was read using the API, the changes produced by this write request are applied against the collaborator changes. This results in a new revision of the document that incorporates both the collaborator changes and the changes in the request, with the Docs server resolving conflicting changes. When using target revision ID, the API client can be thought of as another collaborator of the document. The target revision ID can only be used to write to recent versions of a document. If the target revision is too far behind the latest revision, the request is not processed and returns a 400 bad request error. The request should be tried again after retrieving the latest version of the document. Usually a revision ID remains valid for use as a target revision for several minutes after it's read, but for frequently edited documents this window might be shorter.",
            "type": "string"
          }
        },
        "type": "object"
      }
    }
  },
  "handler": "http",
  "request": {
    "method": "POST",
    "url": {
      "$uri": "https://docs.googleapis.com//v1/documents/{documentId}:batchUpdate{?$.xgafv,access_token,alt,callback,fields,key,oauth_token,prettyPrint,quotaUser,upload_protocol,uploadType}"
    },
    "body": {
      "$": "body",
      "encode": "json"
    }
  },
  "responses": {
    "200": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "Response message from a BatchUpdateDocument request.",
        "**Key properties:**",
        {
          "$ul": [
            "**documentId**: The ID of the document to which the updates were applied to.",
            "**replies**: The reply of the updates. This maps 1:1 with the updates, although replies to some requests may be empty.",
            [
              "**writeControl**: Provides control over how write requests are executed.",
              {
                "$ul": [
                  "**requiredRevisionId**: The optional revision ID of the document the write request is applied to. If this is not the latest revision of the document, the request is not processed and returns a 400 bad request error. When a required revision ID is returned in a response, it indicates the revision ID of the document after the request was applied.",
                  "**targetRevisionId**: The optional target revision ID of the document the write request is applied to. If collaborator changes have occurred after the document was read using the API, the changes produced by this write request are applied against the collaborator changes. This results in a new revision of the document that incorporates both the collaborator changes and the changes in the request, with the Docs server resolving conflicting changes. When using target revision ID, the API client can be thought of as another collaborator of the document. The target revision ID can only be used to write to recent versions of a document. If the target revision is too far behind the latest revision, the request is not processed and returns a 400 bad request error. The request should be tried again after retrieving the latest version of the document. Usually a revision ID remains valid for use as a target revision for several minutes after it's read, but for frequently edited documents this window might be shorter."
                ]
              }
            ]
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    }
  }
}
