{
  "name": "bigquery_models_patch",
  "description": "Patch specific fields in the specified model.",
  "parameters": {
    "type": "object",
    "properties": {
      "projectId": {
        "type": "string",
        "description": "Required. Project ID of the model to patch."
      },
      "datasetId": {
        "type": "string",
        "description": "Required. Dataset ID of the model to patch."
      },
      "modelId": {
        "type": "string",
        "description": "Required. Model ID of the model to patch."
      },
      "$.xgafv": {
        "enum": [
          "1",
          "2"
        ],
        "type": "string",
        "description": "V1 error format."
      },
      "access_token": {
        "type": "string",
        "description": "OAuth access token."
      },
      "alt": {
        "enum": [
          "json",
          "media",
          "proto"
        ],
        "type": "string",
        "description": "Data format for response."
      },
      "callback": {
        "type": "string",
        "description": "JSONP"
      },
      "fields": {
        "type": "string",
        "description": "Selector specifying which fields to include in a partial response."
      },
      "key": {
        "type": "string",
        "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
      },
      "oauth_token": {
        "type": "string",
        "description": "OAuth 2.0 token for the current user."
      },
      "prettyPrint": {
        "type": "boolean",
        "description": "Returns response with indentations and line breaks."
      },
      "quotaUser": {
        "type": "string",
        "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
      },
      "upload_protocol": {
        "type": "string",
        "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
      },
      "uploadType": {
        "type": "string",
        "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
      },
      "body": {
        "$ref": "#/$defs/Model"
      }
    },
    "required": [
      "projectId",
      "datasetId",
      "modelId"
    ],
    "$defs": {
      "Model": {
        "properties": {
          "bestTrialId": {
            "deprecated": true,
            "description": "The best trial_id across all training runs.",
            "format": "int64",
            "type": "string"
          },
          "creationTime": {
            "description": "Output only. The time when this model was created, in millisecs since the epoch.",
            "format": "int64",
            "readOnly": true,
            "type": "string"
          },
          "defaultTrialId": {
            "description": "Output only. The default trial_id to use in TVFs when the trial_id is not passed in. For single-objective [hyperparameter tuning](/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-hp-tuning-overview) models, this is the best trial ID. For multi-objective [hyperparameter tuning](/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-hp-tuning-overview) models, this is the smallest trial ID among all Pareto optimal trials.",
            "format": "int64",
            "readOnly": true,
            "type": "string"
          },
          "description": {
            "description": "Optional. A user-friendly description of this model.",
            "type": "string"
          },
          "encryptionConfiguration": {
            "$ref": "#/$defs/EncryptionConfiguration"
          },
          "etag": {
            "description": "Output only. A hash of this resource.",
            "readOnly": true,
            "type": "string"
          },
          "expirationTime": {
            "description": "Optional. The time when this model expires, in milliseconds since the epoch. If not present, the model will persist indefinitely. Expired models will be deleted and their storage reclaimed. The defaultTableExpirationMs property of the encapsulating dataset can be used to set a default expirationTime on newly created models.",
            "format": "int64",
            "type": "string"
          },
          "featureColumns": {
            "description": "Output only. Input feature columns for the model inference. If the model is trained with TRANSFORM clause, these are the input of the TRANSFORM clause.",
            "items": {
              "$ref": "#/$defs/StandardSqlField"
            },
            "readOnly": true,
            "type": "array"
          },
          "friendlyName": {
            "description": "Optional. A descriptive name for this model.",
            "type": "string"
          },
          "hparamSearchSpaces": {
            "$ref": "#/$defs/HparamSearchSpaces"
          },
          "hparamTrials": {
            "description": "Output only. Trials of a [hyperparameter tuning](/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-hp-tuning-overview) model sorted by trial_id.",
            "items": {
              "$ref": "#/$defs/HparamTuningTrial"
            },
            "readOnly": true,
            "type": "array"
          },
          "labelColumns": {
            "description": "Output only. Label columns that were used to train this model. The output of the model will have a \"predicted_\" prefix to these columns.",
            "items": {
              "$ref": "#/$defs/StandardSqlField"
            },
            "readOnly": true,
            "type": "array"
          },
          "labels": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "The labels associated with this model. You can use these to organize and group your models. Label keys and values can be no longer than 63 characters, can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. Label values are optional. Label keys must start with a letter and each label in the list must have a different key.",
            "type": "object"
          },
          "lastModifiedTime": {
            "description": "Output only. The time when this model was last modified, in millisecs since the epoch.",
            "format": "int64",
            "readOnly": true,
            "type": "string"
          },
          "location": {
            "description": "Output only. The geographic location where the model resides. This value is inherited from the dataset.",
            "readOnly": true,
            "type": "string"
          },
          "modelReference": {
            "$ref": "#/$defs/ModelReference"
          },
          "modelType": {
            "description": "Output only. Type of the model resource.",
            "enum": [
              "MODEL_TYPE_UNSPECIFIED",
              "LINEAR_REGRESSION",
              "LOGISTIC_REGRESSION",
              "KMEANS",
              "MATRIX_FACTORIZATION",
              "DNN_CLASSIFIER",
              "TENSORFLOW",
              "DNN_REGRESSOR",
              "XGBOOST",
              "BOOSTED_TREE_REGRESSOR",
              "BOOSTED_TREE_CLASSIFIER",
              "ARIMA",
              "AUTOML_REGRESSOR",
              "AUTOML_CLASSIFIER",
              "PCA",
              "DNN_LINEAR_COMBINED_CLASSIFIER",
              "DNN_LINEAR_COMBINED_REGRESSOR",
              "AUTOENCODER",
              "ARIMA_PLUS",
              "ARIMA_PLUS_XREG",
              "RANDOM_FOREST_REGRESSOR",
              "RANDOM_FOREST_CLASSIFIER",
              "TENSORFLOW_LITE",
              "ONNX"
            ],
            "readOnly": true,
            "type": "string"
          },
          "optimalTrialIds": {
            "description": "Output only. For single-objective [hyperparameter tuning](/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-hp-tuning-overview) models, it only contains the best trial. For multi-objective [hyperparameter tuning](/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-hp-tuning-overview) models, it contains all Pareto optimal trials sorted by trial_id.",
            "items": {
              "format": "int64",
              "type": "string"
            },
            "readOnly": true,
            "type": "array"
          },
          "remoteModelInfo": {
            "$ref": "#/$defs/RemoteModelInfo"
          },
          "trainingRuns": {
            "description": "Information for all training runs in increasing order of start_time.",
            "items": {
              "$ref": "#/$defs/TrainingRun"
            },
            "type": "array"
          },
          "transformColumns": {
            "description": "Output only. This field will be populated if a TRANSFORM clause was used to train a model. TRANSFORM clause (if used) takes feature_columns as input and outputs transform_columns. transform_columns then are used to train the model.",
            "items": {
              "$ref": "#/$defs/TransformColumn"
            },
            "readOnly": true,
            "type": "array"
          }
        },
        "type": "object"
      },
      "EncryptionConfiguration": {
        "properties": {
          "kmsKeyName": {
            "description": "Optional. Describes the Cloud KMS encryption key that will be used to protect destination BigQuery table. The BigQuery Service Account associated with your project requires access to this encryption key.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "StandardSqlField": {
        "description": "A field or a column.",
        "properties": {
          "name": {
            "description": "Optional. The name of this field. Can be absent for struct fields.",
            "type": "string"
          },
          "type": {
            "$ref": "#/$defs/StandardSqlDataType"
          }
        },
        "type": "object"
      },
      "StandardSqlDataType": {
        "description": "The data type of a variable such as a function argument. Examples include: * INT64: `{\"typeKind\": \"INT64\"}` * ARRAY: { \"typeKind\": \"ARRAY\", \"arrayElementType\": {\"typeKind\": \"STRING\"} } * STRUCT>: { \"typeKind\": \"STRUCT\", \"structType\": { \"fields\": [ { \"name\": \"x\", \"type\": {\"typeKind\": \"STRING\"} }, { \"name\": \"y\", \"type\": { \"typeKind\": \"ARRAY\", \"arrayElementType\": {\"typeKind\": \"DATE\"} } } ] } }",
        "properties": {
          "arrayElementType": {
            "$ref": "#/$defs/StandardSqlDataType"
          },
          "rangeElementType": {
            "$ref": "#/$defs/StandardSqlDataType"
          },
          "structType": {
            "$ref": "#/$defs/StandardSqlStructType"
          },
          "typeKind": {
            "description": "Required. The top level type of this field. Can be any GoogleSQL data type (e.g., \"INT64\", \"DATE\", \"ARRAY\").",
            "enum": [
              "TYPE_KIND_UNSPECIFIED",
              "INT64",
              "BOOL",
              "FLOAT64",
              "STRING",
              "BYTES",
              "TIMESTAMP",
              "DATE",
              "TIME",
              "DATETIME",
              "INTERVAL",
              "GEOGRAPHY",
              "NUMERIC",
              "BIGNUMERIC",
              "JSON",
              "ARRAY",
              "STRUCT",
              "RANGE"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "StandardSqlStructType": {
        "description": "The representation of a SQL STRUCT type.",
        "properties": {
          "fields": {
            "description": "Fields within the struct.",
            "items": {
              "$ref": "#/$defs/StandardSqlField"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "HparamSearchSpaces": {
        "description": "Hyperparameter search spaces. These should be a subset of training_options.",
        "properties": {
          "activationFn": {
            "$ref": "#/$defs/StringHparamSearchSpace"
          },
          "batchSize": {
            "$ref": "#/$defs/IntHparamSearchSpace"
          },
          "boosterType": {
            "$ref": "#/$defs/StringHparamSearchSpace"
          },
          "colsampleBylevel": {
            "$ref": "#/$defs/DoubleHparamSearchSpace"
          },
          "colsampleBynode": {
            "$ref": "#/$defs/DoubleHparamSearchSpace"
          },
          "colsampleBytree": {
            "$ref": "#/$defs/DoubleHparamSearchSpace"
          },
          "dartNormalizeType": {
            "$ref": "#/$defs/StringHparamSearchSpace"
          },
          "dropout": {
            "$ref": "#/$defs/DoubleHparamSearchSpace"
          },
          "hiddenUnits": {
            "$ref": "#/$defs/IntArrayHparamSearchSpace"
          },
          "l1Reg": {
            "$ref": "#/$defs/DoubleHparamSearchSpace"
          },
          "l2Reg": {
            "$ref": "#/$defs/DoubleHparamSearchSpace"
          },
          "learnRate": {
            "$ref": "#/$defs/DoubleHparamSearchSpace"
          },
          "maxTreeDepth": {
            "$ref": "#/$defs/IntHparamSearchSpace"
          },
          "minSplitLoss": {
            "$ref": "#/$defs/DoubleHparamSearchSpace"
          },
          "minTreeChildWeight": {
            "$ref": "#/$defs/IntHparamSearchSpace"
          },
          "numClusters": {
            "$ref": "#/$defs/IntHparamSearchSpace"
          },
          "numFactors": {
            "$ref": "#/$defs/IntHparamSearchSpace"
          },
          "numParallelTree": {
            "$ref": "#/$defs/IntHparamSearchSpace"
          },
          "optimizer": {
            "$ref": "#/$defs/StringHparamSearchSpace"
          },
          "subsample": {
            "$ref": "#/$defs/DoubleHparamSearchSpace"
          },
          "treeMethod": {
            "$ref": "#/$defs/StringHparamSearchSpace"
          },
          "walsAlpha": {
            "$ref": "#/$defs/DoubleHparamSearchSpace"
          }
        },
        "type": "object"
      },
      "StringHparamSearchSpace": {
        "description": "Search space for string and enum.",
        "properties": {
          "candidates": {
            "description": "Canididates for the string or enum parameter in lower case.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "IntHparamSearchSpace": {
        "description": "Search space for an int hyperparameter.",
        "properties": {
          "candidates": {
            "$ref": "#/$defs/IntCandidates"
          },
          "range": {
            "$ref": "#/$defs/IntRange"
          }
        },
        "type": "object"
      },
      "IntCandidates": {
        "description": "Discrete candidates of an int hyperparameter.",
        "properties": {
          "candidates": {
            "description": "Candidates for the int parameter in increasing order.",
            "items": {
              "format": "int64",
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "IntRange": {
        "description": "Range of an int hyperparameter.",
        "properties": {
          "max": {
            "description": "Max value of the int parameter.",
            "format": "int64",
            "type": "string"
          },
          "min": {
            "description": "Min value of the int parameter.",
            "format": "int64",
            "type": "string"
          }
        },
        "type": "object"
      },
      "DoubleHparamSearchSpace": {
        "description": "Search space for a double hyperparameter.",
        "properties": {
          "candidates": {
            "$ref": "#/$defs/DoubleCandidates"
          },
          "range": {
            "$ref": "#/$defs/DoubleRange"
          }
        },
        "type": "object"
      },
      "DoubleCandidates": {
        "description": "Discrete candidates of a double hyperparameter.",
        "properties": {
          "candidates": {
            "description": "Candidates for the double parameter in increasing order.",
            "items": {
              "format": "double",
              "type": "number"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "DoubleRange": {
        "description": "Range of a double hyperparameter.",
        "properties": {
          "max": {
            "description": "Max value of the double parameter.",
            "format": "double",
            "type": "number"
          },
          "min": {
            "description": "Min value of the double parameter.",
            "format": "double",
            "type": "number"
          }
        },
        "type": "object"
      },
      "IntArrayHparamSearchSpace": {
        "description": "Search space for int array.",
        "properties": {
          "candidates": {
            "description": "Candidates for the int array parameter.",
            "items": {
              "$ref": "#/$defs/IntArray"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "IntArray": {
        "description": "An array of int.",
        "properties": {
          "elements": {
            "description": "Elements in the int array.",
            "items": {
              "format": "int64",
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "HparamTuningTrial": {
        "description": "Training info of a trial in [hyperparameter tuning](/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-hp-tuning-overview) models.",
        "properties": {
          "endTimeMs": {
            "description": "Ending time of the trial.",
            "format": "int64",
            "type": "string"
          },
          "errorMessage": {
            "description": "Error message for FAILED and INFEASIBLE trial.",
            "type": "string"
          },
          "evalLoss": {
            "description": "Loss computed on the eval data at the end of trial.",
            "format": "double",
            "type": "number"
          },
          "evaluationMetrics": {
            "$ref": "#/$defs/EvaluationMetrics"
          },
          "hparamTuningEvaluationMetrics": {
            "$ref": "#/$defs/EvaluationMetrics"
          },
          "hparams": {
            "$ref": "#/$defs/TrainingOptions"
          },
          "startTimeMs": {
            "description": "Starting time of the trial.",
            "format": "int64",
            "type": "string"
          },
          "status": {
            "description": "The status of the trial.",
            "enum": [
              "TRIAL_STATUS_UNSPECIFIED",
              "NOT_STARTED",
              "RUNNING",
              "SUCCEEDED",
              "FAILED",
              "INFEASIBLE",
              "STOPPED_EARLY"
            ],
            "type": "string"
          },
          "trainingLoss": {
            "description": "Loss computed on the training data at the end of trial.",
            "format": "double",
            "type": "number"
          },
          "trialId": {
            "description": "1-based index of the trial.",
            "format": "int64",
            "type": "string"
          }
        },
        "type": "object"
      },
      "EvaluationMetrics": {
        "description": "Evaluation metrics of a model. These are either computed on all training data or just the eval data based on whether eval data was used during training. These are not present for imported models.",
        "properties": {
          "arimaForecastingMetrics": {
            "$ref": "#/$defs/ArimaForecastingMetrics"
          },
          "binaryClassificationMetrics": {
            "$ref": "#/$defs/BinaryClassificationMetrics"
          },
          "clusteringMetrics": {
            "$ref": "#/$defs/ClusteringMetrics"
          },
          "dimensionalityReductionMetrics": {
            "$ref": "#/$defs/DimensionalityReductionMetrics"
          },
          "multiClassClassificationMetrics": {
            "$ref": "#/$defs/MultiClassClassificationMetrics"
          },
          "rankingMetrics": {
            "$ref": "#/$defs/RankingMetrics"
          },
          "regressionMetrics": {
            "$ref": "#/$defs/RegressionMetrics"
          }
        },
        "type": "object"
      },
      "ArimaForecastingMetrics": {
        "description": "Model evaluation metrics for ARIMA forecasting models.",
        "properties": {
          "arimaFittingMetrics": {
            "deprecated": true,
            "description": "Arima model fitting metrics.",
            "items": {
              "$ref": "#/$defs/ArimaFittingMetrics"
            },
            "type": "array"
          },
          "arimaSingleModelForecastingMetrics": {
            "description": "Repeated as there can be many metric sets (one for each model) in auto-arima and the large-scale case.",
            "items": {
              "$ref": "#/$defs/ArimaSingleModelForecastingMetrics"
            },
            "type": "array"
          },
          "hasDrift": {
            "deprecated": true,
            "description": "Whether Arima model fitted with drift or not. It is always false when d is not 1.",
            "items": {
              "type": "boolean"
            },
            "type": "array"
          },
          "nonSeasonalOrder": {
            "deprecated": true,
            "description": "Non-seasonal order.",
            "items": {
              "$ref": "#/$defs/ArimaOrder"
            },
            "type": "array"
          },
          "seasonalPeriods": {
            "deprecated": true,
            "description": "Seasonal periods. Repeated because multiple periods are supported for one time series.",
            "items": {
              "enum": [
                "SEASONAL_PERIOD_TYPE_UNSPECIFIED",
                "NO_SEASONALITY",
                "DAILY",
                "WEEKLY",
                "MONTHLY",
                "QUARTERLY",
                "YEARLY"
              ],
              "type": "string"
            },
            "type": "array"
          },
          "timeSeriesId": {
            "deprecated": true,
            "description": "Id to differentiate different time series for the large-scale case.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "ArimaFittingMetrics": {
        "description": "ARIMA model fitting metrics.",
        "properties": {
          "aic": {
            "description": "AIC.",
            "format": "double",
            "type": "number"
          },
          "logLikelihood": {
            "description": "Log-likelihood.",
            "format": "double",
            "type": "number"
          },
          "variance": {
            "description": "Variance.",
            "format": "double",
            "type": "number"
          }
        },
        "type": "object"
      },
      "ArimaSingleModelForecastingMetrics": {
        "description": "Model evaluation metrics for a single ARIMA forecasting model.",
        "properties": {
          "arimaFittingMetrics": {
            "$ref": "#/$defs/ArimaFittingMetrics"
          },
          "hasDrift": {
            "description": "Is arima model fitted with drift or not. It is always false when d is not 1.",
            "type": "boolean"
          },
          "hasHolidayEffect": {
            "description": "If true, holiday_effect is a part of time series decomposition result.",
            "type": "boolean"
          },
          "hasSpikesAndDips": {
            "description": "If true, spikes_and_dips is a part of time series decomposition result.",
            "type": "boolean"
          },
          "hasStepChanges": {
            "description": "If true, step_changes is a part of time series decomposition result.",
            "type": "boolean"
          },
          "nonSeasonalOrder": {
            "$ref": "#/$defs/ArimaOrder"
          },
          "seasonalPeriods": {
            "description": "Seasonal periods. Repeated because multiple periods are supported for one time series.",
            "items": {
              "enum": [
                "SEASONAL_PERIOD_TYPE_UNSPECIFIED",
                "NO_SEASONALITY",
                "DAILY",
                "WEEKLY",
                "MONTHLY",
                "QUARTERLY",
                "YEARLY"
              ],
              "type": "string"
            },
            "type": "array"
          },
          "timeSeriesId": {
            "description": "The time_series_id value for this time series. It will be one of the unique values from the time_series_id_column specified during ARIMA model training. Only present when time_series_id_column training option was used.",
            "type": "string"
          },
          "timeSeriesIds": {
            "description": "The tuple of time_series_ids identifying this time series. It will be one of the unique tuples of values present in the time_series_id_columns specified during ARIMA model training. Only present when time_series_id_columns training option was used and the order of values here are same as the order of time_series_id_columns.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "ArimaOrder": {
        "description": "Arima order, can be used for both non-seasonal and seasonal parts.",
        "properties": {
          "d": {
            "description": "Order of the differencing part.",
            "format": "int64",
            "type": "string"
          },
          "p": {
            "description": "Order of the autoregressive part.",
            "format": "int64",
            "type": "string"
          },
          "q": {
            "description": "Order of the moving-average part.",
            "format": "int64",
            "type": "string"
          }
        },
        "type": "object"
      },
      "BinaryClassificationMetrics": {
        "description": "Evaluation metrics for binary classification/classifier models.",
        "properties": {
          "aggregateClassificationMetrics": {
            "$ref": "#/$defs/AggregateClassificationMetrics"
          },
          "binaryConfusionMatrixList": {
            "description": "Binary confusion matrix at multiple thresholds.",
            "items": {
              "$ref": "#/$defs/BinaryConfusionMatrix"
            },
            "type": "array"
          },
          "negativeLabel": {
            "description": "Label representing the negative class.",
            "type": "string"
          },
          "positiveLabel": {
            "description": "Label representing the positive class.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "AggregateClassificationMetrics": {
        "description": "Aggregate metrics for classification/classifier models. For multi-class models, the metrics are either macro-averaged or micro-averaged. When macro-averaged, the metrics are calculated for each label and then an unweighted average is taken of those values. When micro-averaged, the metric is calculated globally by counting the total number of correctly predicted rows.",
        "properties": {
          "accuracy": {
            "description": "Accuracy is the fraction of predictions given the correct label. For multiclass this is a micro-averaged metric.",
            "format": "double",
            "type": "number"
          },
          "f1Score": {
            "description": "The F1 score is an average of recall and precision. For multiclass this is a macro-averaged metric.",
            "format": "double",
            "type": "number"
          },
          "logLoss": {
            "description": "Logarithmic Loss. For multiclass this is a macro-averaged metric.",
            "format": "double",
            "type": "number"
          },
          "precision": {
            "description": "Precision is the fraction of actual positive predictions that had positive actual labels. For multiclass this is a macro-averaged metric treating each class as a binary classifier.",
            "format": "double",
            "type": "number"
          },
          "recall": {
            "description": "Recall is the fraction of actual positive labels that were given a positive prediction. For multiclass this is a macro-averaged metric.",
            "format": "double",
            "type": "number"
          },
          "rocAuc": {
            "description": "Area Under a ROC Curve. For multiclass this is a macro-averaged metric.",
            "format": "double",
            "type": "number"
          },
          "threshold": {
            "description": "Threshold at which the metrics are computed. For binary classification models this is the positive class threshold. For multi-class classfication models this is the confidence threshold.",
            "format": "double",
            "type": "number"
          }
        },
        "type": "object"
      },
      "BinaryConfusionMatrix": {
        "description": "Confusion matrix for binary classification models.",
        "properties": {
          "accuracy": {
            "description": "The fraction of predictions given the correct label.",
            "format": "double",
            "type": "number"
          },
          "f1Score": {
            "description": "The equally weighted average of recall and precision.",
            "format": "double",
            "type": "number"
          },
          "falseNegatives": {
            "description": "Number of false samples predicted as false.",
            "format": "int64",
            "type": "string"
          },
          "falsePositives": {
            "description": "Number of false samples predicted as true.",
            "format": "int64",
            "type": "string"
          },
          "positiveClassThreshold": {
            "description": "Threshold value used when computing each of the following metric.",
            "format": "double",
            "type": "number"
          },
          "precision": {
            "description": "The fraction of actual positive predictions that had positive actual labels.",
            "format": "double",
            "type": "number"
          },
          "recall": {
            "description": "The fraction of actual positive labels that were given a positive prediction.",
            "format": "double",
            "type": "number"
          },
          "trueNegatives": {
            "description": "Number of true samples predicted as false.",
            "format": "int64",
            "type": "string"
          },
          "truePositives": {
            "description": "Number of true samples predicted as true.",
            "format": "int64",
            "type": "string"
          }
        },
        "type": "object"
      },
      "ClusteringMetrics": {
        "description": "Evaluation metrics for clustering models.",
        "properties": {
          "clusters": {
            "description": "Information for all clusters.",
            "items": {
              "$ref": "#/$defs/Cluster"
            },
            "type": "array"
          },
          "daviesBouldinIndex": {
            "description": "Davies-Bouldin index.",
            "format": "double",
            "type": "number"
          },
          "meanSquaredDistance": {
            "description": "Mean of squared distances between each sample to its cluster centroid.",
            "format": "double",
            "type": "number"
          }
        },
        "type": "object"
      },
      "Cluster": {
        "description": "Message containing the information about one cluster.",
        "properties": {
          "centroidId": {
            "description": "Centroid id.",
            "format": "int64",
            "type": "string"
          },
          "count": {
            "description": "Count of training data rows that were assigned to this cluster.",
            "format": "int64",
            "type": "string"
          },
          "featureValues": {
            "description": "Values of highly variant features for this cluster.",
            "items": {
              "$ref": "#/$defs/FeatureValue"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "FeatureValue": {
        "description": "Representative value of a single feature within the cluster.",
        "properties": {
          "categoricalValue": {
            "$ref": "#/$defs/CategoricalValue"
          },
          "featureColumn": {
            "description": "The feature column name.",
            "type": "string"
          },
          "numericalValue": {
            "description": "The numerical feature value. This is the centroid value for this feature.",
            "format": "double",
            "type": "number"
          }
        },
        "type": "object"
      },
      "CategoricalValue": {
        "description": "Representative value of a categorical feature.",
        "properties": {
          "categoryCounts": {
            "description": "Counts of all categories for the categorical feature. If there are more than ten categories, we return top ten (by count) and return one more CategoryCount with category \"_OTHER_\" and count as aggregate counts of remaining categories.",
            "items": {
              "$ref": "#/$defs/CategoryCount"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "CategoryCount": {
        "description": "Represents the count of a single category within the cluster.",
        "properties": {
          "category": {
            "description": "The name of category.",
            "type": "string"
          },
          "count": {
            "description": "The count of training samples matching the category within the cluster.",
            "format": "int64",
            "type": "string"
          }
        },
        "type": "object"
      },
      "DimensionalityReductionMetrics": {
        "description": "Model evaluation metrics for dimensionality reduction models.",
        "properties": {
          "totalExplainedVarianceRatio": {
            "description": "Total percentage of variance explained by the selected principal components.",
            "format": "double",
            "type": "number"
          }
        },
        "type": "object"
      },
      "MultiClassClassificationMetrics": {
        "description": "Evaluation metrics for multi-class classification/classifier models.",
        "properties": {
          "aggregateClassificationMetrics": {
            "$ref": "#/$defs/AggregateClassificationMetrics"
          },
          "confusionMatrixList": {
            "description": "Confusion matrix at different thresholds.",
            "items": {
              "$ref": "#/$defs/ConfusionMatrix"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "ConfusionMatrix": {
        "description": "Confusion matrix for multi-class classification models.",
        "properties": {
          "confidenceThreshold": {
            "description": "Confidence threshold used when computing the entries of the confusion matrix.",
            "format": "double",
            "type": "number"
          },
          "rows": {
            "description": "One row per actual label.",
            "items": {
              "$ref": "#/$defs/Row"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "Row": {
        "description": "A single row in the confusion matrix.",
        "properties": {
          "actualLabel": {
            "description": "The original label of this row.",
            "type": "string"
          },
          "entries": {
            "description": "Info describing predicted label distribution.",
            "items": {
              "$ref": "#/$defs/Entry"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "Entry": {
        "description": "A single entry in the confusion matrix.",
        "properties": {
          "itemCount": {
            "description": "Number of items being predicted as this label.",
            "format": "int64",
            "type": "string"
          },
          "predictedLabel": {
            "description": "The predicted label. For confidence_threshold > 0, we will also add an entry indicating the number of items under the confidence threshold.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "RankingMetrics": {
        "description": "Evaluation metrics used by weighted-ALS models specified by feedback_type=implicit.",
        "properties": {
          "averageRank": {
            "description": "Determines the goodness of a ranking by computing the percentile rank from the predicted confidence and dividing it by the original rank.",
            "format": "double",
            "type": "number"
          },
          "meanAveragePrecision": {
            "description": "Calculates a precision per user for all the items by ranking them and then averages all the precisions across all the users.",
            "format": "double",
            "type": "number"
          },
          "meanSquaredError": {
            "description": "Similar to the mean squared error computed in regression and explicit recommendation models except instead of computing the rating directly, the output from evaluate is computed against a preference which is 1 or 0 depending on if the rating exists or not.",
            "format": "double",
            "type": "number"
          },
          "normalizedDiscountedCumulativeGain": {
            "description": "A metric to determine the goodness of a ranking calculated from the predicted confidence by comparing it to an ideal rank measured by the original ratings.",
            "format": "double",
            "type": "number"
          }
        },
        "type": "object"
      },
      "RegressionMetrics": {
        "description": "Evaluation metrics for regression and explicit feedback type matrix factorization models.",
        "properties": {
          "meanAbsoluteError": {
            "description": "Mean absolute error.",
            "format": "double",
            "type": "number"
          },
          "meanSquaredError": {
            "description": "Mean squared error.",
            "format": "double",
            "type": "number"
          },
          "meanSquaredLogError": {
            "description": "Mean squared log error.",
            "format": "double",
            "type": "number"
          },
          "medianAbsoluteError": {
            "description": "Median absolute error.",
            "format": "double",
            "type": "number"
          },
          "rSquared": {
            "description": "R^2 score. This corresponds to r2_score in ML.EVALUATE.",
            "format": "double",
            "type": "number"
          }
        },
        "type": "object"
      },
      "TrainingOptions": {
        "description": "Options used in model training.",
        "properties": {
          "activationFn": {
            "description": "Activation function of the neural nets.",
            "type": "string"
          },
          "adjustStepChanges": {
            "description": "If true, detect step changes and make data adjustment in the input time series.",
            "type": "boolean"
          },
          "approxGlobalFeatureContrib": {
            "description": "Whether to use approximate feature contribution method in XGBoost model explanation for global explain.",
            "type": "boolean"
          },
          "autoArima": {
            "description": "Whether to enable auto ARIMA or not.",
            "type": "boolean"
          },
          "autoArimaMaxOrder": {
            "description": "The max value of the sum of non-seasonal p and q.",
            "format": "int64",
            "type": "string"
          },
          "autoArimaMinOrder": {
            "description": "The min value of the sum of non-seasonal p and q.",
            "format": "int64",
            "type": "string"
          },
          "autoClassWeights": {
            "description": "Whether to calculate class weights automatically based on the popularity of each label.",
            "type": "boolean"
          },
          "batchSize": {
            "description": "Batch size for dnn models.",
            "format": "int64",
            "type": "string"
          },
          "boosterType": {
            "description": "Booster type for boosted tree models.",
            "enum": [
              "BOOSTER_TYPE_UNSPECIFIED",
              "GBTREE",
              "DART"
            ],
            "type": "string"
          },
          "budgetHours": {
            "description": "Budget in hours for AutoML training.",
            "format": "double",
            "type": "number"
          },
          "calculatePValues": {
            "description": "Whether or not p-value test should be computed for this model. Only available for linear and logistic regression models.",
            "type": "boolean"
          },
          "categoryEncodingMethod": {
            "description": "Categorical feature encoding method.",
            "enum": [
              "ENCODING_METHOD_UNSPECIFIED",
              "ONE_HOT_ENCODING",
              "LABEL_ENCODING",
              "DUMMY_ENCODING"
            ],
            "type": "string"
          },
          "cleanSpikesAndDips": {
            "description": "If true, clean spikes and dips in the input time series.",
            "type": "boolean"
          },
          "colorSpace": {
            "description": "Enums for color space, used for processing images in Object Table. See more details at https://www.tensorflow.org/io/tutorials/colorspace.",
            "enum": [
              "COLOR_SPACE_UNSPECIFIED",
              "RGB",
              "HSV",
              "YIQ",
              "YUV",
              "GRAYSCALE"
            ],
            "type": "string"
          },
          "colsampleBylevel": {
            "description": "Subsample ratio of columns for each level for boosted tree models.",
            "format": "double",
            "type": "number"
          },
          "colsampleBynode": {
            "description": "Subsample ratio of columns for each node(split) for boosted tree models.",
            "format": "double",
            "type": "number"
          },
          "colsampleBytree": {
            "description": "Subsample ratio of columns when constructing each tree for boosted tree models.",
            "format": "double",
            "type": "number"
          },
          "dartNormalizeType": {
            "description": "Type of normalization algorithm for boosted tree models using dart booster.",
            "enum": [
              "DART_NORMALIZE_TYPE_UNSPECIFIED",
              "TREE",
              "FOREST"
            ],
            "type": "string"
          },
          "dataFrequency": {
            "description": "The data frequency of a time series.",
            "enum": [
              "DATA_FREQUENCY_UNSPECIFIED",
              "AUTO_FREQUENCY",
              "YEARLY",
              "QUARTERLY",
              "MONTHLY",
              "WEEKLY",
              "DAILY",
              "HOURLY",
              "PER_MINUTE"
            ],
            "type": "string"
          },
          "dataSplitColumn": {
            "description": "The column to split data with. This column won't be used as a feature. 1. When data_split_method is CUSTOM, the corresponding column should be boolean. The rows with true value tag are eval data, and the false are training data. 2. When data_split_method is SEQ, the first DATA_SPLIT_EVAL_FRACTION rows (from smallest to largest) in the corresponding column are used as training data, and the rest are eval data. It respects the order in Orderable data types: https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#data-type-properties",
            "type": "string"
          },
          "dataSplitEvalFraction": {
            "description": "The fraction of evaluation data over the whole input data. The rest of data will be used as training data. The format should be double. Accurate to two decimal places. Default value is 0.2.",
            "format": "double",
            "type": "number"
          },
          "dataSplitMethod": {
            "description": "The data split type for training and evaluation, e.g. RANDOM.",
            "enum": [
              "DATA_SPLIT_METHOD_UNSPECIFIED",
              "RANDOM",
              "CUSTOM",
              "SEQUENTIAL",
              "NO_SPLIT",
              "AUTO_SPLIT"
            ],
            "type": "string"
          },
          "decomposeTimeSeries": {
            "description": "If true, perform decompose time series and save the results.",
            "type": "boolean"
          },
          "distanceType": {
            "description": "Distance type for clustering models.",
            "enum": [
              "DISTANCE_TYPE_UNSPECIFIED",
              "EUCLIDEAN",
              "COSINE"
            ],
            "type": "string"
          },
          "dropout": {
            "description": "Dropout probability for dnn models.",
            "format": "double",
            "type": "number"
          },
          "earlyStop": {
            "description": "Whether to stop early when the loss doesn't improve significantly any more (compared to min_relative_progress). Used only for iterative training algorithms.",
            "type": "boolean"
          },
          "enableGlobalExplain": {
            "description": "If true, enable global explanation during training.",
            "type": "boolean"
          },
          "feedbackType": {
            "description": "Feedback type that specifies which algorithm to run for matrix factorization.",
            "enum": [
              "FEEDBACK_TYPE_UNSPECIFIED",
              "IMPLICIT",
              "EXPLICIT"
            ],
            "type": "string"
          },
          "fitIntercept": {
            "description": "Whether the model should include intercept during model training.",
            "type": "boolean"
          },
          "hiddenUnits": {
            "description": "Hidden units for dnn models.",
            "items": {
              "format": "int64",
              "type": "string"
            },
            "type": "array"
          },
          "holidayRegion": {
            "description": "The geographical region based on which the holidays are considered in time series modeling. If a valid value is specified, then holiday effects modeling is enabled.",
            "enum": [
              "HOLIDAY_REGION_UNSPECIFIED",
              "GLOBAL",
              "NA",
              "JAPAC",
              "EMEA",
              "LAC",
              "AE",
              "AR",
              "AT",
              "AU",
              "BE",
              "BR",
              "CA",
              "CH",
              "CL",
              "CN",
              "CO",
              "CS",
              "CZ",
              "DE",
              "DK",
              "DZ",
              "EC",
              "EE",
              "EG",
              "ES",
              "FI",
              "FR",
              "GB",
              "GR",
              "HK",
              "HU",
              "ID",
              "IE",
              "IL",
              "IN",
              "IR",
              "IT",
              "JP",
              "KR",
              "LV",
              "MA",
              "MX",
              "MY",
              "NG",
              "NL",
              "NO",
              "NZ",
              "PE",
              "PH",
              "PK",
              "PL",
              "PT",
              "RO",
              "RS",
              "RU",
              "SA",
              "SE",
              "SG",
              "SI",
              "SK",
              "TH",
              "TR",
              "TW",
              "UA",
              "US",
              "VE",
              "VN",
              "ZA"
            ],
            "type": "string"
          },
          "holidayRegions": {
            "description": "A list of geographical regions that are used for time series modeling.",
            "items": {
              "enum": [
                "HOLIDAY_REGION_UNSPECIFIED",
                "GLOBAL",
                "NA",
                "JAPAC",
                "EMEA",
                "LAC",
                "AE",
                "AR",
                "AT",
                "AU",
                "BE",
                "BR",
                "CA",
                "CH",
                "CL",
                "CN",
                "CO",
                "CS",
                "CZ",
                "DE",
                "DK",
                "DZ",
                "EC",
                "EE",
                "EG",
                "ES",
                "FI",
                "FR",
                "GB",
                "GR",
                "HK",
                "HU",
                "ID",
                "IE",
                "IL",
                "IN",
                "IR",
                "IT",
                "JP",
                "KR",
                "LV",
                "MA",
                "MX",
                "MY",
                "NG",
                "NL",
                "NO",
                "NZ",
                "PE",
                "PH",
                "PK",
                "PL",
                "PT",
                "RO",
                "RS",
                "RU",
                "SA",
                "SE",
                "SG",
                "SI",
                "SK",
                "TH",
                "TR",
                "TW",
                "UA",
                "US",
                "VE",
                "VN",
                "ZA"
              ],
              "type": "string"
            },
            "type": "array"
          },
          "horizon": {
            "description": "The number of periods ahead that need to be forecasted.",
            "format": "int64",
            "type": "string"
          },
          "hparamTuningObjectives": {
            "description": "The target evaluation metrics to optimize the hyperparameters for.",
            "items": {
              "enum": [
                "HPARAM_TUNING_OBJECTIVE_UNSPECIFIED",
                "MEAN_ABSOLUTE_ERROR",
                "MEAN_SQUARED_ERROR",
                "MEAN_SQUARED_LOG_ERROR",
                "MEDIAN_ABSOLUTE_ERROR",
                "R_SQUARED",
                "EXPLAINED_VARIANCE",
                "PRECISION",
                "RECALL",
                "ACCURACY",
                "F1_SCORE",
                "LOG_LOSS",
                "ROC_AUC",
                "DAVIES_BOULDIN_INDEX",
                "MEAN_AVERAGE_PRECISION",
                "NORMALIZED_DISCOUNTED_CUMULATIVE_GAIN",
                "AVERAGE_RANK"
              ],
              "type": "string"
            },
            "type": "array"
          },
          "includeDrift": {
            "description": "Include drift when fitting an ARIMA model.",
            "type": "boolean"
          },
          "initialLearnRate": {
            "description": "Specifies the initial learning rate for the line search learn rate strategy.",
            "format": "double",
            "type": "number"
          },
          "inputLabelColumns": {
            "description": "Name of input label columns in training data.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "instanceWeightColumn": {
            "description": "Name of the instance weight column for training data. This column isn't be used as a feature.",
            "type": "string"
          },
          "integratedGradientsNumSteps": {
            "description": "Number of integral steps for the integrated gradients explain method.",
            "format": "int64",
            "type": "string"
          },
          "itemColumn": {
            "description": "Item column specified for matrix factorization models.",
            "type": "string"
          },
          "kmeansInitializationColumn": {
            "description": "The column used to provide the initial centroids for kmeans algorithm when kmeans_initialization_method is CUSTOM.",
            "type": "string"
          },
          "kmeansInitializationMethod": {
            "description": "The method used to initialize the centroids for kmeans algorithm.",
            "enum": [
              "KMEANS_INITIALIZATION_METHOD_UNSPECIFIED",
              "RANDOM",
              "CUSTOM",
              "KMEANS_PLUS_PLUS"
            ],
            "type": "string"
          },
          "l1RegActivation": {
            "description": "L1 regularization coefficient to activations.",
            "format": "double",
            "type": "number"
          },
          "l1Regularization": {
            "description": "L1 regularization coefficient.",
            "format": "double",
            "type": "number"
          },
          "l2Regularization": {
            "description": "L2 regularization coefficient.",
            "format": "double",
            "type": "number"
          },
          "labelClassWeights": {
            "additionalProperties": {
              "format": "double",
              "type": "number"
            },
            "description": "Weights associated with each label class, for rebalancing the training data. Only applicable for classification models.",
            "type": "object"
          },
          "learnRate": {
            "description": "Learning rate in training. Used only for iterative training algorithms.",
            "format": "double",
            "type": "number"
          },
          "learnRateStrategy": {
            "description": "The strategy to determine learn rate for the current iteration.",
            "enum": [
              "LEARN_RATE_STRATEGY_UNSPECIFIED",
              "LINE_SEARCH",
              "CONSTANT"
            ],
            "type": "string"
          },
          "lossType": {
            "description": "Type of loss function used during training run.",
            "enum": [
              "LOSS_TYPE_UNSPECIFIED",
              "MEAN_SQUARED_LOSS",
              "MEAN_LOG_LOSS"
            ],
            "type": "string"
          },
          "maxIterations": {
            "description": "The maximum number of iterations in training. Used only for iterative training algorithms.",
            "format": "int64",
            "type": "string"
          },
          "maxParallelTrials": {
            "description": "Maximum number of trials to run in parallel.",
            "format": "int64",
            "type": "string"
          },
          "maxTimeSeriesLength": {
            "description": "The maximum number of time points in a time series that can be used in modeling the trend component of the time series. Don't use this option with the `timeSeriesLengthFraction` or `minTimeSeriesLength` options.",
            "format": "int64",
            "type": "string"
          },
          "maxTreeDepth": {
            "description": "Maximum depth of a tree for boosted tree models.",
            "format": "int64",
            "type": "string"
          },
          "minRelativeProgress": {
            "description": "When early_stop is true, stops training when accuracy improvement is less than 'min_relative_progress'. Used only for iterative training algorithms.",
            "format": "double",
            "type": "number"
          },
          "minSplitLoss": {
            "description": "Minimum split loss for boosted tree models.",
            "format": "double",
            "type": "number"
          },
          "minTimeSeriesLength": {
            "description": "The minimum number of time points in a time series that are used in modeling the trend component of the time series. If you use this option you must also set the `timeSeriesLengthFraction` option. This training option ensures that enough time points are available when you use `timeSeriesLengthFraction` in trend modeling. This is particularly important when forecasting multiple time series in a single query using `timeSeriesIdColumn`. If the total number of time points is less than the `minTimeSeriesLength` value, then the query uses all available time points.",
            "format": "int64",
            "type": "string"
          },
          "minTreeChildWeight": {
            "description": "Minimum sum of instance weight needed in a child for boosted tree models.",
            "format": "int64",
            "type": "string"
          },
          "modelRegistry": {
            "description": "The model registry.",
            "enum": [
              "MODEL_REGISTRY_UNSPECIFIED",
              "VERTEX_AI"
            ],
            "type": "string"
          },
          "modelUri": {
            "description": "Google Cloud Storage URI from which the model was imported. Only applicable for imported models.",
            "type": "string"
          },
          "nonSeasonalOrder": {
            "$ref": "#/$defs/ArimaOrder"
          },
          "numClusters": {
            "description": "Number of clusters for clustering models.",
            "format": "int64",
            "type": "string"
          },
          "numFactors": {
            "description": "Num factors specified for matrix factorization models.",
            "format": "int64",
            "type": "string"
          },
          "numParallelTree": {
            "description": "Number of parallel trees constructed during each iteration for boosted tree models.",
            "format": "int64",
            "type": "string"
          },
          "numPrincipalComponents": {
            "description": "Number of principal components to keep in the PCA model. Must be <= the number of features.",
            "format": "int64",
            "type": "string"
          },
          "numTrials": {
            "description": "Number of trials to run this hyperparameter tuning job.",
            "format": "int64",
            "type": "string"
          },
          "optimizationStrategy": {
            "description": "Optimization strategy for training linear regression models.",
            "enum": [
              "OPTIMIZATION_STRATEGY_UNSPECIFIED",
              "BATCH_GRADIENT_DESCENT",
              "NORMAL_EQUATION"
            ],
            "type": "string"
          },
          "optimizer": {
            "description": "Optimizer used for training the neural nets.",
            "type": "string"
          },
          "pcaExplainedVarianceRatio": {
            "description": "The minimum ratio of cumulative explained variance that needs to be given by the PCA model.",
            "format": "double",
            "type": "number"
          },
          "pcaSolver": {
            "description": "The solver for PCA.",
            "enum": [
              "UNSPECIFIED",
              "FULL",
              "RANDOMIZED",
              "AUTO"
            ],
            "type": "string"
          },
          "sampledShapleyNumPaths": {
            "description": "Number of paths for the sampled Shapley explain method.",
            "format": "int64",
            "type": "string"
          },
          "scaleFeatures": {
            "description": "If true, scale the feature values by dividing the feature standard deviation. Currently only apply to PCA.",
            "type": "boolean"
          },
          "standardizeFeatures": {
            "description": "Whether to standardize numerical features. Default to true.",
            "type": "boolean"
          },
          "subsample": {
            "description": "Subsample fraction of the training data to grow tree to prevent overfitting for boosted tree models.",
            "format": "double",
            "type": "number"
          },
          "tfVersion": {
            "description": "Based on the selected TF version, the corresponding docker image is used to train external models.",
            "type": "string"
          },
          "timeSeriesDataColumn": {
            "description": "Column to be designated as time series data for ARIMA model.",
            "type": "string"
          },
          "timeSeriesIdColumn": {
            "description": "The time series id column that was used during ARIMA model training.",
            "type": "string"
          },
          "timeSeriesIdColumns": {
            "description": "The time series id columns that were used during ARIMA model training.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "timeSeriesLengthFraction": {
            "description": "The fraction of the interpolated length of the time series that's used to model the time series trend component. All of the time points of the time series are used to model the non-trend component. This training option accelerates modeling training without sacrificing much forecasting accuracy. You can use this option with `minTimeSeriesLength` but not with `maxTimeSeriesLength`.",
            "format": "double",
            "type": "number"
          },
          "timeSeriesTimestampColumn": {
            "description": "Column to be designated as time series timestamp for ARIMA model.",
            "type": "string"
          },
          "treeMethod": {
            "description": "Tree construction algorithm for boosted tree models.",
            "enum": [
              "TREE_METHOD_UNSPECIFIED",
              "AUTO",
              "EXACT",
              "APPROX",
              "HIST"
            ],
            "type": "string"
          },
          "trendSmoothingWindowSize": {
            "description": "Smoothing window size for the trend component. When a positive value is specified, a center moving average smoothing is applied on the history trend. When the smoothing window is out of the boundary at the beginning or the end of the trend, the first element or the last element is padded to fill the smoothing window before the average is applied.",
            "format": "int64",
            "type": "string"
          },
          "userColumn": {
            "description": "User column specified for matrix factorization models.",
            "type": "string"
          },
          "vertexAiModelVersionAliases": {
            "description": "The version aliases to apply in Vertex AI model registry. Always overwrite if the version aliases exists in a existing model.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "walsAlpha": {
            "description": "Hyperparameter for matrix factoration when implicit feedback type is specified.",
            "format": "double",
            "type": "number"
          },
          "warmStart": {
            "description": "Whether to train a model from the last checkpoint.",
            "type": "boolean"
          },
          "xgboostVersion": {
            "description": "User-selected XGBoost versions for training of XGBoost models.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "ModelReference": {
        "description": "Id path of a model.",
        "properties": {
          "datasetId": {
            "description": "Required. The ID of the dataset containing this model.",
            "type": "string"
          },
          "modelId": {
            "description": "Required. The ID of the model. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 1,024 characters.",
            "type": "string"
          },
          "projectId": {
            "description": "Required. The ID of the project containing this model.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "RemoteModelInfo": {
        "description": "Remote Model Info",
        "properties": {
          "connection": {
            "description": "Output only. Fully qualified name of the user-provided connection object of the remote model. Format: ```\"projects/{project_id}/locations/{location_id}/connections/{connection_id}\"```",
            "readOnly": true,
            "type": "string"
          },
          "endpoint": {
            "description": "Output only. The endpoint for remote model.",
            "readOnly": true,
            "type": "string"
          },
          "maxBatchingRows": {
            "description": "Output only. Max number of rows in each batch sent to the remote service. If unset, the number of rows in each batch is set dynamically.",
            "format": "int64",
            "readOnly": true,
            "type": "string"
          },
          "remoteModelVersion": {
            "description": "Output only. The model version for LLM.",
            "readOnly": true,
            "type": "string"
          },
          "remoteServiceType": {
            "description": "Output only. The remote service type for remote model.",
            "enum": [
              "REMOTE_SERVICE_TYPE_UNSPECIFIED",
              "CLOUD_AI_TRANSLATE_V3",
              "CLOUD_AI_VISION_V1",
              "CLOUD_AI_NATURAL_LANGUAGE_V1",
              "CLOUD_AI_SPEECH_TO_TEXT_V2"
            ],
            "readOnly": true,
            "type": "string"
          },
          "speechRecognizer": {
            "description": "Output only. The name of the speech recognizer to use for speech recognition. The expected format is `projects/{project}/locations/{location}/recognizers/{recognizer}`. Customers can specify this field at model creation. If not specified, a default recognizer `projects/{model project}/locations/global/recognizers/_` will be used. See more details at [recognizers](https://cloud.google.com/speech-to-text/v2/docs/reference/rest/v2/projects.locations.recognizers)",
            "readOnly": true,
            "type": "string"
          }
        },
        "type": "object"
      },
      "TrainingRun": {
        "description": "Information about a single training query run for the model.",
        "properties": {
          "classLevelGlobalExplanations": {
            "description": "Output only. Global explanation contains the explanation of top features on the class level. Applies to classification models only.",
            "items": {
              "$ref": "#/$defs/GlobalExplanation"
            },
            "readOnly": true,
            "type": "array"
          },
          "dataSplitResult": {
            "$ref": "#/$defs/DataSplitResult"
          },
          "evaluationMetrics": {
            "$ref": "#/$defs/EvaluationMetrics"
          },
          "modelLevelGlobalExplanation": {
            "$ref": "#/$defs/GlobalExplanation"
          },
          "results": {
            "description": "Output only. Output of each iteration run, results.size() <= max_iterations.",
            "items": {
              "$ref": "#/$defs/IterationResult"
            },
            "readOnly": true,
            "type": "array"
          },
          "startTime": {
            "description": "Output only. The start time of this training run.",
            "format": "google-datetime",
            "readOnly": true,
            "type": "string"
          },
          "trainingOptions": {
            "$ref": "#/$defs/TrainingOptions"
          },
          "trainingStartTime": {
            "deprecated": true,
            "description": "Output only. The start time of this training run, in milliseconds since epoch.",
            "format": "int64",
            "readOnly": true,
            "type": "string"
          },
          "vertexAiModelId": {
            "description": "The model id in the [Vertex AI Model Registry](https://cloud.google.com/vertex-ai/docs/model-registry/introduction) for this training run.",
            "type": "string"
          },
          "vertexAiModelVersion": {
            "description": "Output only. The model version in the [Vertex AI Model Registry](https://cloud.google.com/vertex-ai/docs/model-registry/introduction) for this training run.",
            "readOnly": true,
            "type": "string"
          }
        },
        "type": "object"
      },
      "GlobalExplanation": {
        "description": "Global explanations containing the top most important features after training.",
        "properties": {
          "classLabel": {
            "description": "Class label for this set of global explanations. Will be empty/null for binary logistic and linear regression models. Sorted alphabetically in descending order.",
            "type": "string"
          },
          "explanations": {
            "description": "A list of the top global explanations. Sorted by absolute value of attribution in descending order.",
            "items": {
              "$ref": "#/$defs/Explanation"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "Explanation": {
        "description": "Explanation for a single feature.",
        "properties": {
          "attribution": {
            "description": "Attribution of feature.",
            "format": "double",
            "type": "number"
          },
          "featureName": {
            "description": "The full feature name. For non-numerical features, will be formatted like `.`. Overall size of feature name will always be truncated to first 120 characters.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "DataSplitResult": {
        "description": "Data split result. This contains references to the training and evaluation data tables that were used to train the model.",
        "properties": {
          "evaluationTable": {
            "$ref": "#/$defs/TableReference"
          },
          "testTable": {
            "$ref": "#/$defs/TableReference"
          },
          "trainingTable": {
            "$ref": "#/$defs/TableReference"
          }
        },
        "type": "object"
      },
      "TableReference": {
        "properties": {
          "datasetId": {
            "description": "Required. The ID of the dataset containing this table.",
            "type": "string"
          },
          "projectId": {
            "description": "Required. The ID of the project containing this table.",
            "type": "string"
          },
          "tableId": {
            "description": "Required. The ID of the table. The ID can contain Unicode characters in category L (letter), M (mark), N (number), Pc (connector, including underscore), Pd (dash), and Zs (space). For more information, see [General Category](https://wikipedia.org/wiki/Unicode_character_property#General_Category). The maximum length is 1,024 characters. Certain operations allow suffixing of the table ID with a partition decorator, such as `sample_table$20190123`.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "IterationResult": {
        "description": "Information about a single iteration of the training run.",
        "properties": {
          "arimaResult": {
            "$ref": "#/$defs/ArimaResult"
          },
          "clusterInfos": {
            "description": "Information about top clusters for clustering models.",
            "items": {
              "$ref": "#/$defs/ClusterInfo"
            },
            "type": "array"
          },
          "durationMs": {
            "description": "Time taken to run the iteration in milliseconds.",
            "format": "int64",
            "type": "string"
          },
          "evalLoss": {
            "description": "Loss computed on the eval data at the end of iteration.",
            "format": "double",
            "type": "number"
          },
          "index": {
            "description": "Index of the iteration, 0 based.",
            "format": "int32",
            "type": "integer"
          },
          "learnRate": {
            "description": "Learn rate used for this iteration.",
            "format": "double",
            "type": "number"
          },
          "principalComponentInfos": {
            "description": "The information of the principal components.",
            "items": {
              "$ref": "#/$defs/PrincipalComponentInfo"
            },
            "type": "array"
          },
          "trainingLoss": {
            "description": "Loss computed on the training data at the end of iteration.",
            "format": "double",
            "type": "number"
          }
        },
        "type": "object"
      },
      "ArimaResult": {
        "description": "(Auto-)arima fitting result. Wrap everything in ArimaResult for easier refactoring if we want to use model-specific iteration results.",
        "properties": {
          "arimaModelInfo": {
            "description": "This message is repeated because there are multiple arima models fitted in auto-arima. For non-auto-arima model, its size is one.",
            "items": {
              "$ref": "#/$defs/ArimaModelInfo"
            },
            "type": "array"
          },
          "seasonalPeriods": {
            "description": "Seasonal periods. Repeated because multiple periods are supported for one time series.",
            "items": {
              "enum": [
                "SEASONAL_PERIOD_TYPE_UNSPECIFIED",
                "NO_SEASONALITY",
                "DAILY",
                "WEEKLY",
                "MONTHLY",
                "QUARTERLY",
                "YEARLY"
              ],
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "ArimaModelInfo": {
        "description": "Arima model information.",
        "properties": {
          "arimaCoefficients": {
            "$ref": "#/$defs/ArimaCoefficients"
          },
          "arimaFittingMetrics": {
            "$ref": "#/$defs/ArimaFittingMetrics"
          },
          "hasDrift": {
            "description": "Whether Arima model fitted with drift or not. It is always false when d is not 1.",
            "type": "boolean"
          },
          "hasHolidayEffect": {
            "description": "If true, holiday_effect is a part of time series decomposition result.",
            "type": "boolean"
          },
          "hasSpikesAndDips": {
            "description": "If true, spikes_and_dips is a part of time series decomposition result.",
            "type": "boolean"
          },
          "hasStepChanges": {
            "description": "If true, step_changes is a part of time series decomposition result.",
            "type": "boolean"
          },
          "nonSeasonalOrder": {
            "$ref": "#/$defs/ArimaOrder"
          },
          "seasonalPeriods": {
            "description": "Seasonal periods. Repeated because multiple periods are supported for one time series.",
            "items": {
              "enum": [
                "SEASONAL_PERIOD_TYPE_UNSPECIFIED",
                "NO_SEASONALITY",
                "DAILY",
                "WEEKLY",
                "MONTHLY",
                "QUARTERLY",
                "YEARLY"
              ],
              "type": "string"
            },
            "type": "array"
          },
          "timeSeriesId": {
            "description": "The time_series_id value for this time series. It will be one of the unique values from the time_series_id_column specified during ARIMA model training. Only present when time_series_id_column training option was used.",
            "type": "string"
          },
          "timeSeriesIds": {
            "description": "The tuple of time_series_ids identifying this time series. It will be one of the unique tuples of values present in the time_series_id_columns specified during ARIMA model training. Only present when time_series_id_columns training option was used and the order of values here are same as the order of time_series_id_columns.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "ArimaCoefficients": {
        "description": "Arima coefficients.",
        "properties": {
          "autoRegressiveCoefficients": {
            "description": "Auto-regressive coefficients, an array of double.",
            "items": {
              "format": "double",
              "type": "number"
            },
            "type": "array"
          },
          "interceptCoefficient": {
            "description": "Intercept coefficient, just a double not an array.",
            "format": "double",
            "type": "number"
          },
          "movingAverageCoefficients": {
            "description": "Moving-average coefficients, an array of double.",
            "items": {
              "format": "double",
              "type": "number"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "ClusterInfo": {
        "description": "Information about a single cluster for clustering model.",
        "properties": {
          "centroidId": {
            "description": "Centroid id.",
            "format": "int64",
            "type": "string"
          },
          "clusterRadius": {
            "description": "Cluster radius, the average distance from centroid to each point assigned to the cluster.",
            "format": "double",
            "type": "number"
          },
          "clusterSize": {
            "description": "Cluster size, the total number of points assigned to the cluster.",
            "format": "int64",
            "type": "string"
          }
        },
        "type": "object"
      },
      "PrincipalComponentInfo": {
        "description": "Principal component infos, used only for eigen decomposition based models, e.g., PCA. Ordered by explained_variance in the descending order.",
        "properties": {
          "cumulativeExplainedVarianceRatio": {
            "description": "The explained_variance is pre-ordered in the descending order to compute the cumulative explained variance ratio.",
            "format": "double",
            "type": "number"
          },
          "explainedVariance": {
            "description": "Explained variance by this principal component, which is simply the eigenvalue.",
            "format": "double",
            "type": "number"
          },
          "explainedVarianceRatio": {
            "description": "Explained_variance over the total explained variance.",
            "format": "double",
            "type": "number"
          },
          "principalComponentId": {
            "description": "Id of the principal component.",
            "format": "int64",
            "type": "string"
          }
        },
        "type": "object"
      },
      "TransformColumn": {
        "description": "Information about a single transform column.",
        "properties": {
          "name": {
            "description": "Output only. Name of the column.",
            "readOnly": true,
            "type": "string"
          },
          "transformSql": {
            "description": "Output only. The SQL expression used in the column transform.",
            "readOnly": true,
            "type": "string"
          },
          "type": {
            "$ref": "#/$defs/StandardSqlDataType"
          }
        },
        "type": "object"
      }
    }
  },
  "handler": "http",
  "request": {
    "method": "PATCH",
    "url": {
      "$uri": "https://bigquery.googleapis.com/bigquery/v2/projects/{projectId}/datasets/{datasetId}/models/{modelId}{?$.xgafv,access_token,alt,callback,fields,key,oauth_token,prettyPrint,quotaUser,upload_protocol,uploadType}"
    },
    "body": {
      "$": "body",
      "encode": "json"
    }
  },
  "responses": {
    "200": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "**Key properties:**",
        {
          "$ul": [
            "**bestTrialId**: The best trial_id across all training runs.",
            "**creationTime**: Output only. The time when this model was created, in millisecs since the epoch.",
            "**defaultTrialId**: Output only. The default trial_id to use in TVFs when the trial_id is not passed in. For single-objective [hyperparameter tuning](/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-hp-tuning-overview) models, this is the best trial ID. For multi-objective [hyperparameter tuning](/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-hp-tuning-overview) models, this is the smallest trial ID among all Pareto optimal trials.",
            "**description**: Optional. A user-friendly description of this model.",
            [
              "**encryptionConfiguration**",
              {
                "$ul": [
                  "**kmsKeyName**: Optional. Describes the Cloud KMS encryption key that will be used to protect destination BigQuery table. The BigQuery Service Account associated with your project requires access to this encryption key."
                ]
              }
            ],
            "**etag**: Output only. A hash of this resource.",
            "**expirationTime**: Optional. The time when this model expires, in milliseconds since the epoch. If not present, the model will persist indefinitely. Expired models will be deleted and their storage reclaimed. The defaultTableExpirationMs property of the encapsulating dataset can be used to set a default expirationTime on newly created models.",
            "**featureColumns**: Output only. Input feature columns for the model inference. If the model is trained with TRANSFORM clause, these are the input of the TRANSFORM clause.",
            "**friendlyName**: Optional. A descriptive name for this model.",
            [
              "**hparamSearchSpaces**: Hyperparameter search spaces. These should be a subset of training_options.",
              {
                "$ul": [
                  [
                    "**activationFn**: Search space for string and enum.",
                    {
                      "$ul": [
                        "**candidates**: Canididates for the string or enum parameter in lower case."
                      ]
                    }
                  ],
                  [
                    "**batchSize**: Search space for an int hyperparameter.",
                    {
                      "$ul": [
                        [
                          "**candidates**: Discrete candidates of an int hyperparameter.",
                          {
                            "$ul": [
                              "**candidates**: Candidates for the int parameter in increasing order."
                            ]
                          }
                        ],
                        [
                          "**range**: Range of an int hyperparameter.",
                          {
                            "$ul": [
                              "**max**: Max value of the int parameter.",
                              "**min**: Min value of the int parameter."
                            ]
                          }
                        ]
                      ]
                    }
                  ],
                  [
                    "**boosterType**: Search space for string and enum.",
                    {
                      "$ul": [
                        "**candidates**: Canididates for the string or enum parameter in lower case."
                      ]
                    }
                  ],
                  [
                    "**colsampleBylevel**: Search space for a double hyperparameter.",
                    {
                      "$ul": [
                        [
                          "**candidates**: Discrete candidates of a double hyperparameter.",
                          {
                            "$ul": [
                              "**candidates**: Candidates for the double parameter in increasing order."
                            ]
                          }
                        ],
                        [
                          "**range**: Range of a double hyperparameter.",
                          {
                            "$ul": [
                              "**max**: Max value of the double parameter.",
                              "**min**: Min value of the double parameter."
                            ]
                          }
                        ]
                      ]
                    }
                  ],
                  [
                    "**colsampleBynode**: Search space for a double hyperparameter.",
                    {
                      "$ul": [
                        [
                          "**candidates**: Discrete candidates of a double hyperparameter.",
                          {
                            "$ul": [
                              "**candidates**: Candidates for the double parameter in increasing order."
                            ]
                          }
                        ],
                        [
                          "**range**: Range of a double hyperparameter.",
                          {
                            "$ul": [
                              "**max**: Max value of the double parameter.",
                              "**min**: Min value of the double parameter."
                            ]
                          }
                        ]
                      ]
                    }
                  ],
                  [
                    "**colsampleBytree**: Search space for a double hyperparameter.",
                    {
                      "$ul": [
                        [
                          "**candidates**: Discrete candidates of a double hyperparameter.",
                          {
                            "$ul": [
                              "**candidates**: Candidates for the double parameter in increasing order."
                            ]
                          }
                        ],
                        [
                          "**range**: Range of a double hyperparameter.",
                          {
                            "$ul": [
                              "**max**: Max value of the double parameter.",
                              "**min**: Min value of the double parameter."
                            ]
                          }
                        ]
                      ]
                    }
                  ],
                  [
                    "**dartNormalizeType**: Search space for string and enum.",
                    {
                      "$ul": [
                        "**candidates**: Canididates for the string or enum parameter in lower case."
                      ]
                    }
                  ],
                  [
                    "**dropout**: Search space for a double hyperparameter.",
                    {
                      "$ul": [
                        [
                          "**candidates**: Discrete candidates of a double hyperparameter.",
                          {
                            "$ul": [
                              "**candidates**: Candidates for the double parameter in increasing order."
                            ]
                          }
                        ],
                        [
                          "**range**: Range of a double hyperparameter.",
                          {
                            "$ul": [
                              "**max**: Max value of the double parameter.",
                              "**min**: Min value of the double parameter."
                            ]
                          }
                        ]
                      ]
                    }
                  ],
                  [
                    "**hiddenUnits**: Search space for int array.",
                    {
                      "$ul": [
                        "**candidates**: Candidates for the int array parameter."
                      ]
                    }
                  ],
                  [
                    "**l1Reg**: Search space for a double hyperparameter.",
                    {
                      "$ul": [
                        [
                          "**candidates**: Discrete candidates of a double hyperparameter.",
                          {
                            "$ul": [
                              "**candidates**: Candidates for the double parameter in increasing order."
                            ]
                          }
                        ],
                        [
                          "**range**: Range of a double hyperparameter.",
                          {
                            "$ul": [
                              "**max**: Max value of the double parameter.",
                              "**min**: Min value of the double parameter."
                            ]
                          }
                        ]
                      ]
                    }
                  ],
                  [
                    "**l2Reg**: Search space for a double hyperparameter.",
                    {
                      "$ul": [
                        [
                          "**candidates**: Discrete candidates of a double hyperparameter.",
                          {
                            "$ul": [
                              "**candidates**: Candidates for the double parameter in increasing order."
                            ]
                          }
                        ],
                        [
                          "**range**: Range of a double hyperparameter.",
                          {
                            "$ul": [
                              "**max**: Max value of the double parameter.",
                              "**min**: Min value of the double parameter."
                            ]
                          }
                        ]
                      ]
                    }
                  ],
                  [
                    "**learnRate**: Search space for a double hyperparameter.",
                    {
                      "$ul": [
                        [
                          "**candidates**: Discrete candidates of a double hyperparameter.",
                          {
                            "$ul": [
                              "**candidates**: Candidates for the double parameter in increasing order."
                            ]
                          }
                        ],
                        [
                          "**range**: Range of a double hyperparameter.",
                          {
                            "$ul": [
                              "**max**: Max value of the double parameter.",
                              "**min**: Min value of the double parameter."
                            ]
                          }
                        ]
                      ]
                    }
                  ],
                  [
                    "**maxTreeDepth**: Search space for an int hyperparameter.",
                    {
                      "$ul": [
                        [
                          "**candidates**: Discrete candidates of an int hyperparameter.",
                          {
                            "$ul": [
                              "**candidates**: Candidates for the int parameter in increasing order."
                            ]
                          }
                        ],
                        [
                          "**range**: Range of an int hyperparameter.",
                          {
                            "$ul": [
                              "**max**: Max value of the int parameter.",
                              "**min**: Min value of the int parameter."
                            ]
                          }
                        ]
                      ]
                    }
                  ],
                  [
                    "**minSplitLoss**: Search space for a double hyperparameter.",
                    {
                      "$ul": [
                        [
                          "**candidates**: Discrete candidates of a double hyperparameter.",
                          {
                            "$ul": [
                              "**candidates**: Candidates for the double parameter in increasing order."
                            ]
                          }
                        ],
                        [
                          "**range**: Range of a double hyperparameter.",
                          {
                            "$ul": [
                              "**max**: Max value of the double parameter.",
                              "**min**: Min value of the double parameter."
                            ]
                          }
                        ]
                      ]
                    }
                  ],
                  [
                    "**minTreeChildWeight**: Search space for an int hyperparameter.",
                    {
                      "$ul": [
                        [
                          "**candidates**: Discrete candidates of an int hyperparameter.",
                          {
                            "$ul": [
                              "**candidates**: Candidates for the int parameter in increasing order."
                            ]
                          }
                        ],
                        [
                          "**range**: Range of an int hyperparameter.",
                          {
                            "$ul": [
                              "**max**: Max value of the int parameter.",
                              "**min**: Min value of the int parameter."
                            ]
                          }
                        ]
                      ]
                    }
                  ],
                  [
                    "**numClusters**: Search space for an int hyperparameter.",
                    {
                      "$ul": [
                        [
                          "**candidates**: Discrete candidates of an int hyperparameter.",
                          {
                            "$ul": [
                              "**candidates**: Candidates for the int parameter in increasing order."
                            ]
                          }
                        ],
                        [
                          "**range**: Range of an int hyperparameter.",
                          {
                            "$ul": [
                              "**max**: Max value of the int parameter.",
                              "**min**: Min value of the int parameter."
                            ]
                          }
                        ]
                      ]
                    }
                  ],
                  [
                    "**numFactors**: Search space for an int hyperparameter.",
                    {
                      "$ul": [
                        [
                          "**candidates**: Discrete candidates of an int hyperparameter.",
                          {
                            "$ul": [
                              "**candidates**: Candidates for the int parameter in increasing order."
                            ]
                          }
                        ],
                        [
                          "**range**: Range of an int hyperparameter.",
                          {
                            "$ul": [
                              "**max**: Max value of the int parameter.",
                              "**min**: Min value of the int parameter."
                            ]
                          }
                        ]
                      ]
                    }
                  ],
                  [
                    "**numParallelTree**: Search space for an int hyperparameter.",
                    {
                      "$ul": [
                        [
                          "**candidates**: Discrete candidates of an int hyperparameter.",
                          {
                            "$ul": [
                              "**candidates**: Candidates for the int parameter in increasing order."
                            ]
                          }
                        ],
                        [
                          "**range**: Range of an int hyperparameter.",
                          {
                            "$ul": [
                              "**max**: Max value of the int parameter.",
                              "**min**: Min value of the int parameter."
                            ]
                          }
                        ]
                      ]
                    }
                  ],
                  [
                    "**optimizer**: Search space for string and enum.",
                    {
                      "$ul": [
                        "**candidates**: Canididates for the string or enum parameter in lower case."
                      ]
                    }
                  ],
                  [
                    "**subsample**: Search space for a double hyperparameter.",
                    {
                      "$ul": [
                        [
                          "**candidates**: Discrete candidates of a double hyperparameter.",
                          {
                            "$ul": [
                              "**candidates**: Candidates for the double parameter in increasing order."
                            ]
                          }
                        ],
                        [
                          "**range**: Range of a double hyperparameter.",
                          {
                            "$ul": [
                              "**max**: Max value of the double parameter.",
                              "**min**: Min value of the double parameter."
                            ]
                          }
                        ]
                      ]
                    }
                  ],
                  [
                    "**treeMethod**: Search space for string and enum.",
                    {
                      "$ul": [
                        "**candidates**: Canididates for the string or enum parameter in lower case."
                      ]
                    }
                  ],
                  [
                    "**walsAlpha**: Search space for a double hyperparameter.",
                    {
                      "$ul": [
                        [
                          "**candidates**: Discrete candidates of a double hyperparameter.",
                          {
                            "$ul": [
                              "**candidates**: Candidates for the double parameter in increasing order."
                            ]
                          }
                        ],
                        [
                          "**range**: Range of a double hyperparameter.",
                          {
                            "$ul": [
                              "**max**: Max value of the double parameter.",
                              "**min**: Min value of the double parameter."
                            ]
                          }
                        ]
                      ]
                    }
                  ]
                ]
              }
            ],
            "**hparamTrials**: Output only. Trials of a [hyperparameter tuning](/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-hp-tuning-overview) model sorted by trial_id.",
            "**labelColumns**: Output only. Label columns that were used to train this model. The output of the model will have a \"predicted_\" prefix to these columns.",
            "**labels**: The labels associated with this model. You can use these to organize and group your models. Label keys and values can be no longer than 63 characters, can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. Label values are optional. Label keys must start with a letter and each label in the list must have a different key.",
            "**lastModifiedTime**: Output only. The time when this model was last modified, in millisecs since the epoch.",
            "**location**: Output only. The geographic location where the model resides. This value is inherited from the dataset.",
            [
              "**modelReference**: Id path of a model.",
              {
                "$ul": [
                  "**datasetId**: Required. The ID of the dataset containing this model.",
                  "**modelId**: Required. The ID of the model. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 1,024 characters.",
                  "**projectId**: Required. The ID of the project containing this model."
                ]
              }
            ],
            "**modelType**: Output only. Type of the model resource.",
            "**optimalTrialIds**: Output only. For single-objective [hyperparameter tuning](/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-hp-tuning-overview) models, it only contains the best trial. For multi-objective [hyperparameter tuning](/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-hp-tuning-overview) models, it contains all Pareto optimal trials sorted by trial_id.",
            [
              "**remoteModelInfo**: Remote Model Info",
              {
                "$ul": [
                  "**connection**: Output only. Fully qualified name of the user-provided connection object of the remote model. Format: ```\"projects/{project_id}/locations/{location_id}/connections/{connection_id}\"```",
                  "**endpoint**: Output only. The endpoint for remote model.",
                  "**maxBatchingRows**: Output only. Max number of rows in each batch sent to the remote service. If unset, the number of rows in each batch is set dynamically.",
                  "**remoteModelVersion**: Output only. The model version for LLM.",
                  "**remoteServiceType**: Output only. The remote service type for remote model.",
                  "**speechRecognizer**: Output only. The name of the speech recognizer to use for speech recognition. The expected format is `projects/{project}/locations/{location}/recognizers/{recognizer}`. Customers can specify this field at model creation. If not specified, a default recognizer `projects/{model project}/locations/global/recognizers/_` will be used. See more details at [recognizers](https://cloud.google.com/speech-to-text/v2/docs/reference/rest/v2/projects.locations.recognizers)"
                ]
              }
            ],
            "**trainingRuns**: Information for all training runs in increasing order of start_time.",
            "**transformColumns**: Output only. This field will be populated if a TRANSFORM clause was used to train a model. TRANSFORM clause (if used) takes feature_columns as input and outputs transform_columns. transform_columns then are used to train the model."
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    }
  }
}
