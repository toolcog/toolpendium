{
  "name": "datamigration_projects_locations_conversionWorkspaces_mappingRules_create",
  "description": "Creates a new mapping rule for a given conversion workspace.",
  "parameters": {
    "type": "object",
    "properties": {
      "parent": {
        "type": "string",
        "description": "Required. The parent which owns this collection of mapping rules."
      },
      "mappingRuleId": {
        "type": "string",
        "description": "Required. The ID of the rule to create."
      },
      "requestId": {
        "type": "string",
        "description": "A unique ID used to identify the request. If the server receives two requests with the same ID, then the second request is ignored. It is recommended to always set this value to a UUID. The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores (_), and hyphens (-). The maximum length is 40 characters."
      },
      "$.xgafv": {
        "enum": [
          "1",
          "2"
        ],
        "type": "string",
        "description": "V1 error format."
      },
      "access_token": {
        "type": "string",
        "description": "OAuth access token."
      },
      "alt": {
        "enum": [
          "json",
          "media",
          "proto"
        ],
        "type": "string",
        "description": "Data format for response."
      },
      "callback": {
        "type": "string",
        "description": "JSONP"
      },
      "fields": {
        "type": "string",
        "description": "Selector specifying which fields to include in a partial response."
      },
      "key": {
        "type": "string",
        "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
      },
      "oauth_token": {
        "type": "string",
        "description": "OAuth 2.0 token for the current user."
      },
      "prettyPrint": {
        "type": "boolean",
        "description": "Returns response with indentations and line breaks."
      },
      "quotaUser": {
        "type": "string",
        "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
      },
      "upload_protocol": {
        "type": "string",
        "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
      },
      "uploadType": {
        "type": "string",
        "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
      },
      "body": {
        "$ref": "#/$defs/MappingRule"
      }
    },
    "required": [
      "parent"
    ],
    "$defs": {
      "MappingRule": {
        "description": "Definition of a transformation that is to be applied to a group of entities in the source schema. Several such transformations can be applied to an entity sequentially to define the corresponding entity in the target schema.",
        "properties": {
          "conditionalColumnSetValue": {
            "$ref": "#/$defs/ConditionalColumnSetValue"
          },
          "convertRowidColumn": {
            "$ref": "#/$defs/ConvertRowIdToColumn"
          },
          "displayName": {
            "description": "Optional. A human readable name",
            "type": "string"
          },
          "entityMove": {
            "$ref": "#/$defs/EntityMove"
          },
          "filter": {
            "$ref": "#/$defs/MappingRuleFilter"
          },
          "filterTableColumns": {
            "$ref": "#/$defs/FilterTableColumns"
          },
          "multiColumnDataTypeChange": {
            "$ref": "#/$defs/MultiColumnDatatypeChange"
          },
          "multiEntityRename": {
            "$ref": "#/$defs/MultiEntityRename"
          },
          "name": {
            "description": "Full name of the mapping rule resource, in the form of: projects/{project}/locations/{location}/conversionWorkspaces/{set}/mappingRule/{rule}.",
            "type": "string"
          },
          "revisionCreateTime": {
            "description": "Output only. The timestamp that the revision was created.",
            "format": "google-datetime",
            "readOnly": true,
            "type": "string"
          },
          "revisionId": {
            "description": "Output only. The revision ID of the mapping rule. A new revision is committed whenever the mapping rule is changed in any way. The format is an 8-character hexadecimal string.",
            "readOnly": true,
            "type": "string"
          },
          "ruleOrder": {
            "description": "Required. The order in which the rule is applied. Lower order rules are applied before higher value rules so they may end up being overridden.",
            "format": "int64",
            "type": "string"
          },
          "ruleScope": {
            "description": "Required. The rule scope",
            "enum": [
              "DATABASE_ENTITY_TYPE_UNSPECIFIED",
              "DATABASE_ENTITY_TYPE_SCHEMA",
              "DATABASE_ENTITY_TYPE_TABLE",
              "DATABASE_ENTITY_TYPE_COLUMN",
              "DATABASE_ENTITY_TYPE_CONSTRAINT",
              "DATABASE_ENTITY_TYPE_INDEX",
              "DATABASE_ENTITY_TYPE_TRIGGER",
              "DATABASE_ENTITY_TYPE_VIEW",
              "DATABASE_ENTITY_TYPE_SEQUENCE",
              "DATABASE_ENTITY_TYPE_STORED_PROCEDURE",
              "DATABASE_ENTITY_TYPE_FUNCTION",
              "DATABASE_ENTITY_TYPE_SYNONYM",
              "DATABASE_ENTITY_TYPE_DATABASE_PACKAGE",
              "DATABASE_ENTITY_TYPE_UDT",
              "DATABASE_ENTITY_TYPE_MATERIALIZED_VIEW",
              "DATABASE_ENTITY_TYPE_DATABASE"
            ],
            "type": "string"
          },
          "setTablePrimaryKey": {
            "$ref": "#/$defs/SetTablePrimaryKey"
          },
          "singleColumnChange": {
            "$ref": "#/$defs/SingleColumnChange"
          },
          "singleEntityRename": {
            "$ref": "#/$defs/SingleEntityRename"
          },
          "singlePackageChange": {
            "$ref": "#/$defs/SinglePackageChange"
          },
          "sourceSqlChange": {
            "$ref": "#/$defs/SourceSqlChange"
          },
          "state": {
            "description": "Optional. The mapping rule state",
            "enum": [
              "STATE_UNSPECIFIED",
              "ENABLED",
              "DISABLED",
              "DELETED"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "ConditionalColumnSetValue": {
        "description": "Options to configure rule type ConditionalColumnSetValue. The rule is used to transform the data which is being replicated/migrated. The rule filter field can refer to one or more entities. The rule scope can be one of: Column.",
        "properties": {
          "customFeatures": {
            "additionalProperties": {
              "description": "Properties of the object."
            },
            "description": "Optional. Custom engine specific features.",
            "type": "object"
          },
          "sourceNumericFilter": {
            "$ref": "#/$defs/SourceNumericFilter"
          },
          "sourceTextFilter": {
            "$ref": "#/$defs/SourceTextFilter"
          },
          "valueTransformation": {
            "$ref": "#/$defs/ValueTransformation"
          }
        },
        "type": "object"
      },
      "SourceNumericFilter": {
        "description": "Filter for fixed point number data types such as NUMERIC/NUMBER",
        "properties": {
          "numericFilterOption": {
            "description": "Required. Enum to set the option defining the datatypes numeric filter has to be applied to",
            "enum": [
              "NUMERIC_FILTER_OPTION_UNSPECIFIED",
              "NUMERIC_FILTER_OPTION_ALL",
              "NUMERIC_FILTER_OPTION_LIMIT",
              "NUMERIC_FILTER_OPTION_LIMITLESS"
            ],
            "type": "string"
          },
          "sourceMaxPrecisionFilter": {
            "description": "Optional. The filter will match columns with precision smaller than or equal to this number.",
            "format": "int32",
            "type": "integer"
          },
          "sourceMaxScaleFilter": {
            "description": "Optional. The filter will match columns with scale smaller than or equal to this number.",
            "format": "int32",
            "type": "integer"
          },
          "sourceMinPrecisionFilter": {
            "description": "Optional. The filter will match columns with precision greater than or equal to this number.",
            "format": "int32",
            "type": "integer"
          },
          "sourceMinScaleFilter": {
            "description": "Optional. The filter will match columns with scale greater than or equal to this number.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "SourceTextFilter": {
        "description": "Filter for text-based data types like varchar.",
        "properties": {
          "sourceMaxLengthFilter": {
            "description": "Optional. The filter will match columns with length smaller than or equal to this number.",
            "format": "int64",
            "type": "string"
          },
          "sourceMinLengthFilter": {
            "description": "Optional. The filter will match columns with length greater than or equal to this number.",
            "format": "int64",
            "type": "string"
          }
        },
        "type": "object"
      },
      "ValueTransformation": {
        "description": "Description of data transformation during migration as part of the ConditionalColumnSetValue.",
        "properties": {
          "applyHash": {
            "$ref": "#/$defs/ApplyHash"
          },
          "assignMaxValue": {
            "$ref": "#/$defs/Empty"
          },
          "assignMinValue": {
            "$ref": "#/$defs/Empty"
          },
          "assignNull": {
            "$ref": "#/$defs/Empty"
          },
          "assignSpecificValue": {
            "$ref": "#/$defs/AssignSpecificValue"
          },
          "doubleComparison": {
            "$ref": "#/$defs/DoubleComparisonFilter"
          },
          "intComparison": {
            "$ref": "#/$defs/IntComparisonFilter"
          },
          "isNull": {
            "$ref": "#/$defs/Empty"
          },
          "roundScale": {
            "$ref": "#/$defs/RoundToScale"
          },
          "valueList": {
            "$ref": "#/$defs/ValueListFilter"
          }
        },
        "type": "object"
      },
      "ApplyHash": {
        "description": "Apply a hash function on the value.",
        "properties": {
          "uuidFromBytes": {
            "$ref": "#/$defs/Empty"
          }
        },
        "type": "object"
      },
      "Empty": {
        "description": "A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }",
        "properties": {},
        "type": "object"
      },
      "AssignSpecificValue": {
        "description": "Set to a specific value (value is converted to fit the target data type)",
        "properties": {
          "value": {
            "description": "Required. Specific value to be assigned",
            "type": "string"
          }
        },
        "type": "object"
      },
      "DoubleComparisonFilter": {
        "description": "Filter based on relation between source value and compare value of type double in ConditionalColumnSetValue",
        "properties": {
          "value": {
            "description": "Required. Double compare value to be used",
            "format": "double",
            "type": "number"
          },
          "valueComparison": {
            "description": "Required. Relation between source value and compare value",
            "enum": [
              "VALUE_COMPARISON_UNSPECIFIED",
              "VALUE_COMPARISON_IF_VALUE_SMALLER_THAN",
              "VALUE_COMPARISON_IF_VALUE_SMALLER_EQUAL_THAN",
              "VALUE_COMPARISON_IF_VALUE_LARGER_THAN",
              "VALUE_COMPARISON_IF_VALUE_LARGER_EQUAL_THAN"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "IntComparisonFilter": {
        "description": "Filter based on relation between source value and compare value of type integer in ConditionalColumnSetValue",
        "properties": {
          "value": {
            "description": "Required. Integer compare value to be used",
            "format": "int64",
            "type": "string"
          },
          "valueComparison": {
            "description": "Required. Relation between source value and compare value",
            "enum": [
              "VALUE_COMPARISON_UNSPECIFIED",
              "VALUE_COMPARISON_IF_VALUE_SMALLER_THAN",
              "VALUE_COMPARISON_IF_VALUE_SMALLER_EQUAL_THAN",
              "VALUE_COMPARISON_IF_VALUE_LARGER_THAN",
              "VALUE_COMPARISON_IF_VALUE_LARGER_EQUAL_THAN"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "RoundToScale": {
        "description": "This allows the data to change scale, for example if the source is 2 digits after the decimal point, specify round to scale value = 2. If for example the value needs to be converted to an integer, use round to scale value = 0.",
        "properties": {
          "scale": {
            "description": "Required. Scale value to be used",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "ValueListFilter": {
        "description": "A list of values to filter by in ConditionalColumnSetValue",
        "properties": {
          "ignoreCase": {
            "description": "Required. Whether to ignore case when filtering by values. Defaults to false",
            "type": "boolean"
          },
          "valuePresentList": {
            "description": "Required. Indicates whether the filter matches rows with values that are present in the list or those with values not present in it.",
            "enum": [
              "VALUE_PRESENT_IN_LIST_UNSPECIFIED",
              "VALUE_PRESENT_IN_LIST_IF_VALUE_LIST",
              "VALUE_PRESENT_IN_LIST_IF_VALUE_NOT_LIST"
            ],
            "type": "string"
          },
          "values": {
            "description": "Required. The list to be used to filter by",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "ConvertRowIdToColumn": {
        "description": "Options to configure rule type ConvertROWIDToColumn. The rule is used to add column rowid to destination tables based on an Oracle rowid function/property. The rule filter field can refer to one or more entities. The rule scope can be one of: Table. This rule requires additional filter to be specified beyond the basic rule filter field, which is whether or not to work on tables which already have a primary key defined.",
        "properties": {
          "onlyIfNoPrimaryKey": {
            "description": "Required. Only work on tables without primary key defined",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "EntityMove": {
        "description": "Options to configure rule type EntityMove. The rule is used to move an entity to a new schema. The rule filter field can refer to one or more entities. The rule scope can be one of: Table, Column, Constraint, Index, View, Function, Stored Procedure, Materialized View, Sequence, UDT",
        "properties": {
          "newSchema": {
            "description": "Required. The new schema",
            "type": "string"
          }
        },
        "type": "object"
      },
      "MappingRuleFilter": {
        "description": "A filter defining the entities that a mapping rule should be applied to. When more than one field is specified, the rule is applied only to entities which match all the fields.",
        "properties": {
          "entities": {
            "description": "Optional. The rule should be applied to specific entities defined by their fully qualified names.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "entityNameContains": {
            "description": "Optional. The rule should be applied to entities whose non-qualified name contains the given string.",
            "type": "string"
          },
          "entityNamePrefix": {
            "description": "Optional. The rule should be applied to entities whose non-qualified name starts with the given prefix.",
            "type": "string"
          },
          "entityNameSuffix": {
            "description": "Optional. The rule should be applied to entities whose non-qualified name ends with the given suffix.",
            "type": "string"
          },
          "parentEntity": {
            "description": "Optional. The rule should be applied to entities whose parent entity (fully qualified name) matches the given value. For example, if the rule applies to a table entity, the expected value should be a schema (schema). If the rule applies to a column or index entity, the expected value can be either a schema (schema) or a table (schema.table)",
            "type": "string"
          }
        },
        "type": "object"
      },
      "FilterTableColumns": {
        "description": "Options to configure rule type FilterTableColumns. The rule is used to filter the list of columns to include or exclude from a table. The rule filter field can refer to one entity. The rule scope can be: Table Only one of the two lists can be specified for the rule.",
        "properties": {
          "excludeColumns": {
            "description": "Optional. List of columns to be excluded for a particular table.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "includeColumns": {
            "description": "Optional. List of columns to be included for a particular table.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "MultiColumnDatatypeChange": {
        "description": "Options to configure rule type MultiColumnDatatypeChange. The rule is used to change the data type and associated properties of multiple columns at once. The rule filter field can refer to one or more entities. The rule scope can be one of:Column. This rule requires additional filters to be specified beyond the basic rule filter field, which is the source data type, but the rule supports additional filtering capabilities such as the minimum and maximum field length. All additional filters which are specified are required to be met in order for the rule to be applied (logical AND between the fields).",
        "properties": {
          "customFeatures": {
            "additionalProperties": {
              "description": "Properties of the object."
            },
            "description": "Optional. Custom engine specific features.",
            "type": "object"
          },
          "newDataType": {
            "description": "Required. New data type.",
            "type": "string"
          },
          "overrideFractionalSecondsPrecision": {
            "description": "Optional. Column fractional seconds precision - used only for timestamp based datatypes - if not specified and relevant uses the source column fractional seconds precision.",
            "format": "int32",
            "type": "integer"
          },
          "overrideLength": {
            "description": "Optional. Column length - e.g. varchar (50) - if not specified and relevant uses the source column length.",
            "format": "int64",
            "type": "string"
          },
          "overridePrecision": {
            "description": "Optional. Column precision - when relevant - if not specified and relevant uses the source column precision.",
            "format": "int32",
            "type": "integer"
          },
          "overrideScale": {
            "description": "Optional. Column scale - when relevant - if not specified and relevant uses the source column scale.",
            "format": "int32",
            "type": "integer"
          },
          "sourceDataTypeFilter": {
            "description": "Required. Filter on source data type.",
            "type": "string"
          },
          "sourceNumericFilter": {
            "$ref": "#/$defs/SourceNumericFilter"
          },
          "sourceTextFilter": {
            "$ref": "#/$defs/SourceTextFilter"
          }
        },
        "type": "object"
      },
      "MultiEntityRename": {
        "description": "Options to configure rule type MultiEntityRename. The rule is used to rename multiple entities. The rule filter field can refer to one or more entities. The rule scope can be one of: Database, Schema, Table, Column, Constraint, Index, View, Function, Stored Procedure, Materialized View, Sequence, UDT",
        "properties": {
          "newNamePattern": {
            "description": "Optional. The pattern used to generate the new entity's name. This pattern must include the characters '{name}', which will be replaced with the name of the original entity. For example, the pattern 't_{name}' for an entity name jobs would be converted to 't_jobs'. If unspecified, the default value for this field is '{name}'",
            "type": "string"
          },
          "sourceNameTransformation": {
            "description": "Optional. Additional transformation that can be done on the source entity name before it is being used by the new_name_pattern, for example lower case. If no transformation is desired, use NO_TRANSFORMATION",
            "enum": [
              "ENTITY_NAME_TRANSFORMATION_UNSPECIFIED",
              "ENTITY_NAME_TRANSFORMATION_NO_TRANSFORMATION",
              "ENTITY_NAME_TRANSFORMATION_LOWER_CASE",
              "ENTITY_NAME_TRANSFORMATION_UPPER_CASE",
              "ENTITY_NAME_TRANSFORMATION_CAPITALIZED_CASE"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "SetTablePrimaryKey": {
        "description": "Options to configure rule type SetTablePrimaryKey. The rule is used to specify the columns and name to configure/alter the primary key of a table. The rule filter field can refer to one entity. The rule scope can be one of: Table.",
        "properties": {
          "primaryKey": {
            "description": "Optional. Name for the primary key",
            "type": "string"
          },
          "primaryKeyColumns": {
            "description": "Required. List of column names for the primary key",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "SingleColumnChange": {
        "description": "Options to configure rule type SingleColumnChange. The rule is used to change the properties of a column. The rule filter field can refer to one entity. The rule scope can be one of: Column. When using this rule, if a field is not specified than the destination column's configuration will be the same as the one in the source column..",
        "properties": {
          "array": {
            "description": "Optional. Is the column of array type.",
            "type": "boolean"
          },
          "arrayLength": {
            "description": "Optional. The length of the array, only relevant if the column type is an array.",
            "format": "int32",
            "type": "integer"
          },
          "autoGenerated": {
            "description": "Optional. Is the column auto-generated/identity.",
            "type": "boolean"
          },
          "charset": {
            "description": "Optional. Charset override - instead of table level charset.",
            "type": "string"
          },
          "collation": {
            "description": "Optional. Collation override - instead of table level collation.",
            "type": "string"
          },
          "comment": {
            "description": "Optional. Comment associated with the column.",
            "type": "string"
          },
          "customFeatures": {
            "additionalProperties": {
              "description": "Properties of the object."
            },
            "description": "Optional. Custom engine specific features.",
            "type": "object"
          },
          "dataType": {
            "description": "Optional. Column data type name.",
            "type": "string"
          },
          "fractionalSecondsPrecision": {
            "description": "Optional. Column fractional seconds precision - e.g. 2 as in timestamp (2) - when relevant.",
            "format": "int32",
            "type": "integer"
          },
          "length": {
            "description": "Optional. Column length - e.g. 50 as in varchar (50) - when relevant.",
            "format": "int64",
            "type": "string"
          },
          "nullable": {
            "description": "Optional. Is the column nullable.",
            "type": "boolean"
          },
          "precision": {
            "description": "Optional. Column precision - e.g. 8 as in double (8,2) - when relevant.",
            "format": "int32",
            "type": "integer"
          },
          "scale": {
            "description": "Optional. Column scale - e.g. 2 as in double (8,2) - when relevant.",
            "format": "int32",
            "type": "integer"
          },
          "setValues": {
            "description": "Optional. Specifies the list of values allowed in the column.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "udt": {
            "description": "Optional. Is the column a UDT (User-defined Type).",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "SingleEntityRename": {
        "description": "Options to configure rule type SingleEntityRename. The rule is used to rename an entity. The rule filter field can refer to only one entity. The rule scope can be one of: Database, Schema, Table, Column, Constraint, Index, View, Function, Stored Procedure, Materialized View, Sequence, UDT, Synonym",
        "properties": {
          "newName": {
            "description": "Required. The new name of the destination entity",
            "type": "string"
          }
        },
        "type": "object"
      },
      "SinglePackageChange": {
        "description": "Options to configure rule type SinglePackageChange. The rule is used to alter the sql code for a package entities. The rule filter field can refer to one entity. The rule scope can be: Package",
        "properties": {
          "packageBody": {
            "description": "Optional. Sql code for package body",
            "type": "string"
          },
          "packageDescription": {
            "description": "Optional. Sql code for package description",
            "type": "string"
          }
        },
        "type": "object"
      },
      "SourceSqlChange": {
        "description": "Options to configure rule type SourceSqlChange. The rule is used to alter the sql code for database entities. The rule filter field can refer to one entity. The rule scope can be: StoredProcedure, Function, Trigger, View",
        "properties": {
          "sqlCode": {
            "description": "Required. Sql code for source (stored procedure, function, trigger or view)",
            "type": "string"
          }
        },
        "type": "object"
      }
    }
  },
  "handler": "http",
  "request": {
    "method": "POST",
    "url": {
      "$uri": "https://datamigration.googleapis.com//v1/{parent}/mappingRules{?mappingRuleId,requestId,$.xgafv,access_token,alt,callback,fields,key,oauth_token,prettyPrint,quotaUser,upload_protocol,uploadType}"
    },
    "body": {
      "$": "body",
      "encode": "json"
    }
  },
  "responses": {
    "200": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "Definition of a transformation that is to be applied to a group of entities in the source schema. Several such transformations can be applied to an entity sequentially to define the corresponding entity in the target schema.",
        "**Key properties:**",
        {
          "$ul": [
            [
              "**conditionalColumnSetValue**: Options to configure rule type ConditionalColumnSetValue. The rule is used to transform the data which is being replicated/migrated. The rule filter field can refer to one or more entities. The rule scope can be one of: Column.",
              {
                "$ul": [
                  "**customFeatures**: Optional. Custom engine specific features.",
                  [
                    "**sourceNumericFilter**: Filter for fixed point number data types such as NUMERIC/NUMBER",
                    {
                      "$ul": [
                        "**numericFilterOption**: Required. Enum to set the option defining the datatypes numeric filter has to be applied to",
                        "**sourceMaxPrecisionFilter**: Optional. The filter will match columns with precision smaller than or equal to this number.",
                        "**sourceMaxScaleFilter**: Optional. The filter will match columns with scale smaller than or equal to this number.",
                        "**sourceMinPrecisionFilter**: Optional. The filter will match columns with precision greater than or equal to this number.",
                        "**sourceMinScaleFilter**: Optional. The filter will match columns with scale greater than or equal to this number."
                      ]
                    }
                  ],
                  [
                    "**sourceTextFilter**: Filter for text-based data types like varchar.",
                    {
                      "$ul": [
                        "**sourceMaxLengthFilter**: Optional. The filter will match columns with length smaller than or equal to this number.",
                        "**sourceMinLengthFilter**: Optional. The filter will match columns with length greater than or equal to this number."
                      ]
                    }
                  ],
                  [
                    "**valueTransformation**: Description of data transformation during migration as part of the ConditionalColumnSetValue.",
                    {
                      "$ul": [
                        [
                          "**applyHash**: Apply a hash function on the value.",
                          {
                            "$ul": [
                              "**uuidFromBytes**: A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }"
                            ]
                          }
                        ],
                        "**assignMaxValue**: A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }",
                        "**assignMinValue**: A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }",
                        "**assignNull**: A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }",
                        [
                          "**assignSpecificValue**: Set to a specific value (value is converted to fit the target data type)",
                          {
                            "$ul": [
                              "**value**: Required. Specific value to be assigned"
                            ]
                          }
                        ],
                        [
                          "**doubleComparison**: Filter based on relation between source value and compare value of type double in ConditionalColumnSetValue",
                          {
                            "$ul": [
                              "**value**: Required. Double compare value to be used",
                              "**valueComparison**: Required. Relation between source value and compare value"
                            ]
                          }
                        ],
                        [
                          "**intComparison**: Filter based on relation between source value and compare value of type integer in ConditionalColumnSetValue",
                          {
                            "$ul": [
                              "**value**: Required. Integer compare value to be used",
                              "**valueComparison**: Required. Relation between source value and compare value"
                            ]
                          }
                        ],
                        "**isNull**: A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }",
                        [
                          "**roundScale**: This allows the data to change scale, for example if the source is 2 digits after the decimal point, specify round to scale value = 2. If for example the value needs to be converted to an integer, use round to scale value = 0.",
                          {
                            "$ul": [
                              "**scale**: Required. Scale value to be used"
                            ]
                          }
                        ],
                        [
                          "**valueList**: A list of values to filter by in ConditionalColumnSetValue",
                          {
                            "$ul": [
                              "**ignoreCase**: Required. Whether to ignore case when filtering by values. Defaults to false",
                              "**valuePresentList**: Required. Indicates whether the filter matches rows with values that are present in the list or those with values not present in it.",
                              "**values**: Required. The list to be used to filter by"
                            ]
                          }
                        ]
                      ]
                    }
                  ]
                ]
              }
            ],
            [
              "**convertRowidColumn**: Options to configure rule type ConvertROWIDToColumn. The rule is used to add column rowid to destination tables based on an Oracle rowid function/property. The rule filter field can refer to one or more entities. The rule scope can be one of: Table. This rule requires additional filter to be specified beyond the basic rule filter field, which is whether or not to work on tables which already have a primary key defined.",
              {
                "$ul": [
                  "**onlyIfNoPrimaryKey**: Required. Only work on tables without primary key defined"
                ]
              }
            ],
            "**displayName**: Optional. A human readable name",
            [
              "**entityMove**: Options to configure rule type EntityMove. The rule is used to move an entity to a new schema. The rule filter field can refer to one or more entities. The rule scope can be one of: Table, Column, Constraint, Index, View, Function, Stored Procedure, Materialized View, Sequence, UDT",
              {
                "$ul": [
                  "**newSchema**: Required. The new schema"
                ]
              }
            ],
            [
              "**filter**: A filter defining the entities that a mapping rule should be applied to. When more than one field is specified, the rule is applied only to entities which match all the fields.",
              {
                "$ul": [
                  "**entities**: Optional. The rule should be applied to specific entities defined by their fully qualified names.",
                  "**entityNameContains**: Optional. The rule should be applied to entities whose non-qualified name contains the given string.",
                  "**entityNamePrefix**: Optional. The rule should be applied to entities whose non-qualified name starts with the given prefix.",
                  "**entityNameSuffix**: Optional. The rule should be applied to entities whose non-qualified name ends with the given suffix.",
                  "**parentEntity**: Optional. The rule should be applied to entities whose parent entity (fully qualified name) matches the given value. For example, if the rule applies to a table entity, the expected value should be a schema (schema). If the rule applies to a column or index entity, the expected value can be either a schema (schema) or a table (schema.table)"
                ]
              }
            ],
            [
              "**filterTableColumns**: Options to configure rule type FilterTableColumns. The rule is used to filter the list of columns to include or exclude from a table. The rule filter field can refer to one entity. The rule scope can be: Table Only one of the two lists can be specified for the rule.",
              {
                "$ul": [
                  "**excludeColumns**: Optional. List of columns to be excluded for a particular table.",
                  "**includeColumns**: Optional. List of columns to be included for a particular table."
                ]
              }
            ],
            [
              "**multiColumnDataTypeChange**: Options to configure rule type MultiColumnDatatypeChange. The rule is used to change the data type and associated properties of multiple columns at once. The rule filter field can refer to one or more entities. The rule scope can be one of:Column. This rule requires additional filters to be specified beyond the basic rule filter field, which is the source data type, but the rule supports additional filtering capabilities such as the minimum and maximum field length. All additional filters which are specified are required to be met in order for the rule to be applied (logical AND between the fields).",
              {
                "$ul": [
                  "**customFeatures**: Optional. Custom engine specific features.",
                  "**newDataType**: Required. New data type.",
                  "**overrideFractionalSecondsPrecision**: Optional. Column fractional seconds precision - used only for timestamp based datatypes - if not specified and relevant uses the source column fractional seconds precision.",
                  "**overrideLength**: Optional. Column length - e.g. varchar (50) - if not specified and relevant uses the source column length.",
                  "**overridePrecision**: Optional. Column precision - when relevant - if not specified and relevant uses the source column precision.",
                  "**overrideScale**: Optional. Column scale - when relevant - if not specified and relevant uses the source column scale.",
                  "**sourceDataTypeFilter**: Required. Filter on source data type.",
                  [
                    "**sourceNumericFilter**: Filter for fixed point number data types such as NUMERIC/NUMBER",
                    {
                      "$ul": [
                        "**numericFilterOption**: Required. Enum to set the option defining the datatypes numeric filter has to be applied to",
                        "**sourceMaxPrecisionFilter**: Optional. The filter will match columns with precision smaller than or equal to this number.",
                        "**sourceMaxScaleFilter**: Optional. The filter will match columns with scale smaller than or equal to this number.",
                        "**sourceMinPrecisionFilter**: Optional. The filter will match columns with precision greater than or equal to this number.",
                        "**sourceMinScaleFilter**: Optional. The filter will match columns with scale greater than or equal to this number."
                      ]
                    }
                  ],
                  [
                    "**sourceTextFilter**: Filter for text-based data types like varchar.",
                    {
                      "$ul": [
                        "**sourceMaxLengthFilter**: Optional. The filter will match columns with length smaller than or equal to this number.",
                        "**sourceMinLengthFilter**: Optional. The filter will match columns with length greater than or equal to this number."
                      ]
                    }
                  ]
                ]
              }
            ],
            [
              "**multiEntityRename**: Options to configure rule type MultiEntityRename. The rule is used to rename multiple entities. The rule filter field can refer to one or more entities. The rule scope can be one of: Database, Schema, Table, Column, Constraint, Index, View, Function, Stored Procedure, Materialized View, Sequence, UDT",
              {
                "$ul": [
                  "**newNamePattern**: Optional. The pattern used to generate the new entity's name. This pattern must include the characters '{name}', which will be replaced with the name of the original entity. For example, the pattern 't_{name}' for an entity name jobs would be converted to 't_jobs'. If unspecified, the default value for this field is '{name}'",
                  "**sourceNameTransformation**: Optional. Additional transformation that can be done on the source entity name before it is being used by the new_name_pattern, for example lower case. If no transformation is desired, use NO_TRANSFORMATION"
                ]
              }
            ],
            "**name**: Full name of the mapping rule resource, in the form of: projects/{project}/locations/{location}/conversionWorkspaces/{set}/mappingRule/{rule}.",
            "**revisionCreateTime**: Output only. The timestamp that the revision was created.",
            "**revisionId**: Output only. The revision ID of the mapping rule. A new revision is committed whenever the mapping rule is changed in any way. The format is an 8-character hexadecimal string.",
            "**ruleOrder**: Required. The order in which the rule is applied. Lower order rules are applied before higher value rules so they may end up being overridden.",
            "**ruleScope**: Required. The rule scope",
            [
              "**setTablePrimaryKey**: Options to configure rule type SetTablePrimaryKey. The rule is used to specify the columns and name to configure/alter the primary key of a table. The rule filter field can refer to one entity. The rule scope can be one of: Table.",
              {
                "$ul": [
                  "**primaryKey**: Optional. Name for the primary key",
                  "**primaryKeyColumns**: Required. List of column names for the primary key"
                ]
              }
            ],
            [
              "**singleColumnChange**: Options to configure rule type SingleColumnChange. The rule is used to change the properties of a column. The rule filter field can refer to one entity. The rule scope can be one of: Column. When using this rule, if a field is not specified than the destination column's configuration will be the same as the one in the source column..",
              {
                "$ul": [
                  "**array**: Optional. Is the column of array type.",
                  "**arrayLength**: Optional. The length of the array, only relevant if the column type is an array.",
                  "**autoGenerated**: Optional. Is the column auto-generated/identity.",
                  "**charset**: Optional. Charset override - instead of table level charset.",
                  "**collation**: Optional. Collation override - instead of table level collation.",
                  "**comment**: Optional. Comment associated with the column.",
                  "**customFeatures**: Optional. Custom engine specific features.",
                  "**dataType**: Optional. Column data type name.",
                  "**fractionalSecondsPrecision**: Optional. Column fractional seconds precision - e.g. 2 as in timestamp (2) - when relevant.",
                  "**length**: Optional. Column length - e.g. 50 as in varchar (50) - when relevant.",
                  "**nullable**: Optional. Is the column nullable.",
                  "**precision**: Optional. Column precision - e.g. 8 as in double (8,2) - when relevant.",
                  "**scale**: Optional. Column scale - e.g. 2 as in double (8,2) - when relevant.",
                  "**setValues**: Optional. Specifies the list of values allowed in the column.",
                  "**udt**: Optional. Is the column a UDT (User-defined Type)."
                ]
              }
            ],
            [
              "**singleEntityRename**: Options to configure rule type SingleEntityRename. The rule is used to rename an entity. The rule filter field can refer to only one entity. The rule scope can be one of: Database, Schema, Table, Column, Constraint, Index, View, Function, Stored Procedure, Materialized View, Sequence, UDT, Synonym",
              {
                "$ul": [
                  "**newName**: Required. The new name of the destination entity"
                ]
              }
            ],
            [
              "**singlePackageChange**: Options to configure rule type SinglePackageChange. The rule is used to alter the sql code for a package entities. The rule filter field can refer to one entity. The rule scope can be: Package",
              {
                "$ul": [
                  "**packageBody**: Optional. Sql code for package body",
                  "**packageDescription**: Optional. Sql code for package description"
                ]
              }
            ],
            [
              "**sourceSqlChange**: Options to configure rule type SourceSqlChange. The rule is used to alter the sql code for database entities. The rule filter field can refer to one entity. The rule scope can be: StoredProcedure, Function, Trigger, View",
              {
                "$ul": [
                  "**sqlCode**: Required. Sql code for source (stored procedure, function, trigger or view)"
                ]
              }
            ],
            "**state**: Optional. The mapping rule state"
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    }
  }
}
