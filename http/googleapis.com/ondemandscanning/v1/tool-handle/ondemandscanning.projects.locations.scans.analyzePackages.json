{
  "name": "ondemandscanning_projects_locations_scans_analyzePackages",
  "description": "Initiates an analysis of the provided packages.",
  "parameters": {
    "type": "object",
    "properties": {
      "parent": {
        "type": "string",
        "description": "Required. The parent of the resource for which analysis is requested. Format: projects/[project_name]/locations/[location]"
      },
      "$.xgafv": {
        "enum": [
          "1",
          "2"
        ],
        "type": "string",
        "description": "V1 error format."
      },
      "access_token": {
        "type": "string",
        "description": "OAuth access token."
      },
      "alt": {
        "enum": [
          "json",
          "media",
          "proto"
        ],
        "type": "string",
        "description": "Data format for response."
      },
      "callback": {
        "type": "string",
        "description": "JSONP"
      },
      "fields": {
        "type": "string",
        "description": "Selector specifying which fields to include in a partial response."
      },
      "key": {
        "type": "string",
        "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
      },
      "oauth_token": {
        "type": "string",
        "description": "OAuth 2.0 token for the current user."
      },
      "prettyPrint": {
        "type": "boolean",
        "description": "Returns response with indentations and line breaks."
      },
      "quotaUser": {
        "type": "string",
        "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
      },
      "upload_protocol": {
        "type": "string",
        "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
      },
      "uploadType": {
        "type": "string",
        "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
      },
      "body": {
        "$ref": "#/$defs/AnalyzePackagesRequestV1"
      }
    },
    "required": [
      "parent"
    ],
    "$defs": {
      "AnalyzePackagesRequestV1": {
        "description": "AnalyzePackagesRequest is the request to analyze a list of packages and create Vulnerability Occurrences for it.",
        "properties": {
          "includeOsvData": {
            "deprecated": true,
            "description": "[DEPRECATED] Whether to include OSV data in the scan. For backwards compatibility reasons, this field can be neither removed nor renamed.",
            "type": "boolean"
          },
          "packages": {
            "description": "The packages to analyze.",
            "items": {
              "$ref": "#/$defs/PackageData"
            },
            "type": "array"
          },
          "resourceUri": {
            "description": "Required. The resource URI of the container image being scanned.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "PackageData": {
        "properties": {
          "architecture": {
            "description": "The architecture of the package.",
            "type": "string"
          },
          "binarySourceInfo": {
            "description": "A bundle containing the binary and source information.",
            "items": {
              "$ref": "#/$defs/BinarySourceInfo"
            },
            "type": "array"
          },
          "binaryVersion": {
            "$ref": "#/$defs/PackageVersion"
          },
          "cpeUri": {
            "description": "The cpe_uri in [cpe format] (https://cpe.mitre.org/specification/) in which the vulnerability may manifest. Examples include distro or storage location for vulnerable jar.",
            "type": "string"
          },
          "dependencyChain": {
            "description": "The dependency chain between this package and the user's artifact. List in order from the customer's package under review first, to the current package last. Inclusive of the original package and the current package.",
            "items": {
              "$ref": "#/$defs/LanguagePackageDependency"
            },
            "type": "array"
          },
          "fileLocation": {
            "description": "The path to the jar file / go binary file.",
            "items": {
              "$ref": "#/$defs/FileLocation"
            },
            "type": "array"
          },
          "hashDigest": {
            "description": "HashDigest stores the SHA512 hash digest of the jar file if the package is of type Maven. This field will be unset for non Maven packages.",
            "type": "string"
          },
          "licenses": {
            "description": "The list of licenses found that are related to a given package. Note that licenses may also be stored on the BinarySourceInfo. If there is no BinarySourceInfo (because there's no concept of source vs binary), then it will be stored here, while if there are BinarySourceInfos, it will be stored there, as one source can have multiple binaries with different licenses.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "maintainer": {
            "$ref": "#/$defs/Maintainer"
          },
          "os": {
            "description": "The OS affected by a vulnerability Used to generate the cpe_uri for OS packages",
            "type": "string"
          },
          "osVersion": {
            "description": "The version of the OS Used to generate the cpe_uri for OS packages",
            "type": "string"
          },
          "package": {
            "description": "The package being analysed for vulnerabilities",
            "type": "string"
          },
          "packageType": {
            "description": "The type of package: os, maven, go, etc.",
            "enum": [
              "PACKAGE_TYPE_UNSPECIFIED",
              "OS",
              "MAVEN",
              "GO",
              "GO_STDLIB",
              "PYPI",
              "NPM",
              "NUGET",
              "RUBYGEMS",
              "RUST",
              "COMPOSER"
            ],
            "type": "string"
          },
          "patchedCve": {
            "description": "CVEs that this package is no longer vulnerable to go/drydock-dd-custom-binary-scanning",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "sourceVersion": {
            "$ref": "#/$defs/PackageVersion"
          },
          "unused": {
            "type": "string"
          },
          "version": {
            "description": "The version of the package being analysed",
            "type": "string"
          }
        },
        "type": "object"
      },
      "BinarySourceInfo": {
        "properties": {
          "binaryVersion": {
            "$ref": "#/$defs/PackageVersion"
          },
          "sourceVersion": {
            "$ref": "#/$defs/PackageVersion"
          }
        },
        "type": "object"
      },
      "PackageVersion": {
        "properties": {
          "licenses": {
            "description": "The licenses associated with this package. Note that this has to go on the PackageVersion level, because we can have cases with images with the same source having different licences. E.g. in Alpine, musl and musl-utils both have the same origin musl, but have different sets of licenses.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "name": {
            "type": "string"
          },
          "version": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "LanguagePackageDependency": {
        "description": "Indicates a language package available between this package and the customer's resource artifact.",
        "properties": {
          "package": {
            "type": "string"
          },
          "version": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "FileLocation": {
        "description": "Indicates the location at which a package was found.",
        "properties": {
          "filePath": {
            "description": "For jars that are contained inside .war files, this filepath can indicate the path to war file combined with the path to jar file.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "Maintainer": {
        "properties": {
          "email": {
            "type": "string"
          },
          "kind": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "url": {
            "type": "string"
          }
        },
        "type": "object"
      }
    }
  },
  "handler": "http",
  "request": {
    "method": "POST",
    "url": {
      "$uri": "https://ondemandscanning.googleapis.com//v1/{parent}/scans:analyzePackages{?$.xgafv,access_token,alt,callback,fields,key,oauth_token,prettyPrint,quotaUser,upload_protocol,uploadType}"
    },
    "body": {
      "$": "body",
      "encode": "json"
    }
  },
  "responses": {
    "200": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "This resource represents a long-running operation that is the result of a network API call.",
        "**Key properties:**",
        {
          "$ul": [
            "**done**: If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.",
            [
              "**error**: The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).",
              {
                "$ul": [
                  "**code**: The status code, which should be an enum value of google.rpc.Code.",
                  "**details**: A list of messages that carry the error details. There is a common set of message types for APIs to use.",
                  "**message**: A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client."
                ]
              }
            ],
            "**metadata**: Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.",
            "**name**: The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.",
            "**response**: The normal, successful response of the operation. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`."
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    }
  }
}
