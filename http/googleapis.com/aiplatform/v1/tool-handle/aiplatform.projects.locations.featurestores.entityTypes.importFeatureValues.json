{
  "name": "aiplatform_projects_locations_featurestores_entityTypes_importFeatureValues",
  "description": "Imports Feature values into the Featurestore from a source storage. The progress of the import is tracked by the returned operation. The imported features are guaranteed to be visible to subsequent read operations after the operation is marked as successfully done. If an import operation fails, the Feature values returned from reads and exports may be inconsistent. If consistency is required, the caller must retry the same import request again and wait till the new operation returned is marked as successfully done. There are also scenarios where the caller can cause inconsistency. - Source data for import contains multiple distinct Feature values for the same entity ID and timestamp. - Source is modified during an import. This includes adding, updating, or removing source data and/or metadata. Examples of updating metadata include but are not limited to changing storage location, storage class, or retention policy. - Online serving cluster is under-provisioned.",
  "parameters": {
    "type": "object",
    "properties": {
      "entityType": {
        "type": "string",
        "description": "Required. The resource name of the EntityType grouping the Features for which values are being imported. Format: `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`"
      },
      "$.xgafv": {
        "enum": [
          "1",
          "2"
        ],
        "type": "string",
        "description": "V1 error format."
      },
      "access_token": {
        "type": "string",
        "description": "OAuth access token."
      },
      "alt": {
        "enum": [
          "json",
          "media",
          "proto"
        ],
        "type": "string",
        "description": "Data format for response."
      },
      "callback": {
        "type": "string",
        "description": "JSONP"
      },
      "fields": {
        "type": "string",
        "description": "Selector specifying which fields to include in a partial response."
      },
      "key": {
        "type": "string",
        "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
      },
      "oauth_token": {
        "type": "string",
        "description": "OAuth 2.0 token for the current user."
      },
      "prettyPrint": {
        "type": "boolean",
        "description": "Returns response with indentations and line breaks."
      },
      "quotaUser": {
        "type": "string",
        "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters."
      },
      "upload_protocol": {
        "type": "string",
        "description": "Upload protocol for media (e.g. \"raw\", \"multipart\")."
      },
      "uploadType": {
        "type": "string",
        "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
      },
      "body": {
        "$ref": "#/$defs/GoogleCloudAiplatformV1ImportFeatureValuesRequest"
      }
    },
    "required": [
      "entityType"
    ],
    "$defs": {
      "GoogleCloudAiplatformV1ImportFeatureValuesRequest": {
        "description": "Request message for FeaturestoreService.ImportFeatureValues.",
        "properties": {
          "avroSource": {
            "$ref": "#/$defs/GoogleCloudAiplatformV1AvroSource"
          },
          "bigquerySource": {
            "$ref": "#/$defs/GoogleCloudAiplatformV1BigQuerySource"
          },
          "csvSource": {
            "$ref": "#/$defs/GoogleCloudAiplatformV1CsvSource"
          },
          "disableIngestionAnalysis": {
            "description": "If true, API doesn't start ingestion analysis pipeline.",
            "type": "boolean"
          },
          "disableOnlineServing": {
            "description": "If set, data will not be imported for online serving. This is typically used for backfilling, where Feature generation timestamps are not in the timestamp range needed for online serving.",
            "type": "boolean"
          },
          "entityIdField": {
            "description": "Source column that holds entity IDs. If not provided, entity IDs are extracted from the column named entity_id.",
            "type": "string"
          },
          "featureSpecs": {
            "description": "Required. Specifications defining which Feature values to import from the entity. The request fails if no feature_specs are provided, and having multiple feature_specs for one Feature is not allowed.",
            "items": {
              "$ref": "#/$defs/GoogleCloudAiplatformV1ImportFeatureValuesRequestFeatureSpec"
            },
            "type": "array"
          },
          "featureTime": {
            "description": "Single Feature timestamp for all entities being imported. The timestamp must not have higher than millisecond precision.",
            "format": "google-datetime",
            "type": "string"
          },
          "featureTimeField": {
            "description": "Source column that holds the Feature timestamp for all Feature values in each entity.",
            "type": "string"
          },
          "workerCount": {
            "description": "Specifies the number of workers that are used to write data to the Featurestore. Consider the online serving capacity that you require to achieve the desired import throughput without interfering with online serving. The value must be positive, and less than or equal to 100. If not set, defaults to using 1 worker. The low count ensures minimal impact on online serving performance.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "GoogleCloudAiplatformV1AvroSource": {
        "description": "The storage details for Avro input content.",
        "properties": {
          "gcsSource": {
            "$ref": "#/$defs/GoogleCloudAiplatformV1GcsSource"
          }
        },
        "type": "object"
      },
      "GoogleCloudAiplatformV1GcsSource": {
        "description": "The Google Cloud Storage location for the input content.",
        "properties": {
          "uris": {
            "description": "Required. Google Cloud Storage URI(-s) to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "GoogleCloudAiplatformV1BigQuerySource": {
        "description": "The BigQuery location for the input content.",
        "properties": {
          "inputUri": {
            "description": "Required. BigQuery URI to a table, up to 2000 characters long. Accepted forms: * BigQuery path. For example: `bq://projectId.bqDatasetId.bqTableId`.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "GoogleCloudAiplatformV1CsvSource": {
        "description": "The storage details for CSV input content.",
        "properties": {
          "gcsSource": {
            "$ref": "#/$defs/GoogleCloudAiplatformV1GcsSource"
          }
        },
        "type": "object"
      },
      "GoogleCloudAiplatformV1ImportFeatureValuesRequestFeatureSpec": {
        "description": "Defines the Feature value(s) to import.",
        "properties": {
          "id": {
            "description": "Required. ID of the Feature to import values of. This Feature must exist in the target EntityType, or the request will fail.",
            "type": "string"
          },
          "sourceField": {
            "description": "Source column to get the Feature values from. If not set, uses the column with the same name as the Feature ID.",
            "type": "string"
          }
        },
        "type": "object"
      }
    }
  },
  "handler": "http",
  "request": {
    "method": "POST",
    "url": {
      "$uri": "https://aiplatform.googleapis.com//v1/{entityType}:importFeatureValues{?$.xgafv,access_token,alt,callback,fields,key,oauth_token,prettyPrint,quotaUser,upload_protocol,uploadType}"
    },
    "body": {
      "$": "body",
      "encode": "json"
    }
  },
  "responses": {
    "200": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "This resource represents a long-running operation that is the result of a network API call.",
        "**Key properties:**",
        {
          "$ul": [
            "**done**: If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.",
            [
              "**error**: The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).",
              {
                "$ul": [
                  "**code**: The status code, which should be an enum value of google.rpc.Code.",
                  "**details**: A list of messages that carry the error details. There is a common set of message types for APIs to use.",
                  "**message**: A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client."
                ]
              }
            ],
            "**metadata**: Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.",
            "**name**: The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.",
            "**response**: The normal, successful response of the operation. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`."
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    }
  }
}
