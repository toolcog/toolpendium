{
  "name": "createService",
  "description": "Create a new service descriptor",
  "parameters": {
    "type": "object",
    "properties": {
      "body": {
        "$ref": "#/$defs/Service"
      }
    },
    "$defs": {
      "Service": {
        "description": "An otoroshi service descriptor. Represent a forward HTTP call on a domain to another location with some optional api management mecanism",
        "properties": {
          "Canary": {
            "$ref": "#/$defs/Canary"
          },
          "additionalHeaders": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Specify headers that will be added to each client request. Useful to add authentication",
            "example": {
              "key": "value"
            },
            "type": "object"
          },
          "api": {
            "$ref": "#/$defs/ExposedApi"
          },
          "authConfigRef": {
            "description": "A reference to a global auth module config",
            "example": "a string value",
            "type": "string"
          },
          "buildMode": {
            "description": "Display a construction page when a user try to use the service",
            "example": true,
            "type": "boolean"
          },
          "chaosConfig": {
            "$ref": "#/$defs/ChaosConfig"
          },
          "clientConfig": {
            "$ref": "#/$defs/ClientConfig"
          },
          "clientValidatorRef": {
            "description": "A reference to validation authority",
            "example": "a string value",
            "type": "string"
          },
          "cors": {
            "$ref": "#/$defs/CorsSettings"
          },
          "domain": {
            "description": "The domain on which the service is available.",
            "example": "a string value",
            "type": "string"
          },
          "enabled": {
            "description": "Activate or deactivate your service. Once disabled, users will get an error page saying the service does not exist",
            "example": true,
            "type": "boolean"
          },
          "enforceSecureCommunication": {
            "description": "When enabled, Otoroshi will try to exchange headers with downstream service to ensure no one else can use the service from outside",
            "example": true,
            "type": "boolean"
          },
          "env": {
            "description": "The line on which the service is available. Based on that value, the name of the line will be appended to the subdomain. For line prod, nothing will be appended. For example, if the subdomain is 'foo' and line is 'preprod', then the exposed service will be available at 'foo.preprod.mydomain'",
            "example": "a string value",
            "type": "string"
          },
          "forceHttps": {
            "description": "Will force redirection to https:// if not present",
            "example": true,
            "type": "boolean"
          },
          "groups": {
            "description": "Each service descriptor is attached to groups. A group can have one or more services. Each API key is linked to a group and allow access to every service in the group",
            "example": [
              "a string value"
            ],
            "items": {
              "example": "a string value",
              "type": "string"
            },
            "type": "array"
          },
          "gzip": {
            "$ref": "#/$defs/Gzip"
          },
          "headersVerification": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Specify headers that will be verified after routing.",
            "example": {
              "key": "value"
            },
            "type": "object"
          },
          "healthCheck": {
            "$ref": "#/$defs/HealthCheck"
          },
          "id": {
            "description": "A unique random string to identify your service",
            "example": "110e8400-e29b-11d4-a716-446655440000",
            "format": "uuid",
            "type": "string"
          },
          "ipFiltering": {
            "$ref": "#/$defs/IpFiltering"
          },
          "jwtVerifier": {
            "oneOf": [
              {
                "$ref": "#/$defs/LocalJwtVerifier"
              },
              {
                "$ref": "#/$defs/RefJwtVerifier"
              }
            ]
          },
          "localHost": {
            "description": "The host used localy, mainly localhost:xxxx",
            "example": "a string value",
            "type": "string"
          },
          "localScheme": {
            "description": "The scheme used localy, mainly http",
            "example": "a string value",
            "type": "string"
          },
          "maintenanceMode": {
            "description": "Display a maintainance page when a user try to use the service",
            "example": true,
            "type": "boolean"
          },
          "matchingHeaders": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Specify headers that MUST be present on client request to route it. Useful to implement versioning",
            "example": {
              "key": "value"
            },
            "type": "object"
          },
          "matchingRoot": {
            "description": "The root path on which the service is available",
            "example": "a string value",
            "type": "string"
          },
          "metadata": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Just a bunch of random properties",
            "example": {
              "key": "value"
            },
            "type": "object"
          },
          "name": {
            "description": "The name of your service. Only for debug and human readability purposes",
            "example": "a string value",
            "type": "string"
          },
          "overrideHost": {
            "description": "Host header will be overriden with Host of the target",
            "example": true,
            "type": "boolean"
          },
          "privateApp": {
            "description": "When enabled, user will be allowed to use the service (UI) only if they are registered users of the private apps domain",
            "example": true,
            "type": "boolean"
          },
          "privatePatterns": {
            "description": "If you define a public pattern that is a little bit too much, you can make some of public URL private again",
            "items": {
              "example": "a string value",
              "type": "string"
            },
            "type": "array"
          },
          "publicPatterns": {
            "description": "By default, every services are private only and you'll need an API key to access it. However, if you want to expose a public UI, you can define one or more public patterns (regex) to allow access to anybody. For example if you want to allow anybody on any URL, just use '/.*'",
            "items": {
              "example": "a string value",
              "type": "string"
            },
            "type": "array"
          },
          "redirectToLocal": {
            "description": "If you work locally with Otoroshi, you may want to use that feature to redirect one particuliar service to a local host. For example, you can relocate https://foo.preprod.bar.com to http://localhost:8080 to make some tests",
            "example": true,
            "type": "boolean"
          },
          "redirection": {
            "$ref": "#/$defs/RedirectionSettings"
          },
          "root": {
            "description": "Otoroshi will append this root to any target choosen. If the specified root is '/api/foo', then a request to https://yyyyyyy/bar will actually hit https://xxxxxxxxx/api/foo/bar",
            "example": "a string value",
            "type": "string"
          },
          "secComExcludedPatterns": {
            "description": "URI patterns excluded from secured communications",
            "items": {
              "example": "a string value",
              "type": "string"
            },
            "type": "array"
          },
          "secComSettings": {
            "oneOf": [
              {
                "$ref": "#/$defs/HSAlgoSettings"
              },
              {
                "$ref": "#/$defs/RSAlgoSettings"
              },
              {
                "$ref": "#/$defs/ESAlgoSettings"
              },
              {
                "$ref": "#/$defs/JWKSAlgoSettings"
              }
            ]
          },
          "sendOtoroshiHeadersBack": {
            "description": "When enabled, Otoroshi will send headers to consumer like request id, client latency, overhead, etc ...",
            "example": true,
            "type": "boolean"
          },
          "statsdConfig": {
            "$ref": "#/$defs/StatsdConfig"
          },
          "subdomain": {
            "description": "The subdomain on which the service is available",
            "example": "a string value",
            "type": "string"
          },
          "targets": {
            "description": "The list of target that Otoroshi will proxy and expose through the subdomain defined before. Otoroshi will do round-robin load balancing between all those targets with circuit breaker mecanism to avoid cascading failures",
            "items": {
              "$ref": "#/$defs/Target"
            },
            "type": "array"
          },
          "transformerRef": {
            "description": "A reference to a request transformer",
            "example": "a string value",
            "type": "string"
          },
          "userFacing": {
            "description": "The fact that this service will be seen by users and cannot be impacted by the Snow Monkey",
            "example": true,
            "type": "boolean"
          },
          "xForwardedHeaders": {
            "description": "Send X-Forwarded-* headers",
            "example": true,
            "type": "boolean"
          }
        },
        "required": [
          "id",
          "groups",
          "name",
          "env",
          "domain",
          "subdomain",
          "targets",
          "root",
          "enabled",
          "privateApp",
          "forceHttps",
          "maintenanceMode",
          "buildMode",
          "enforceSecureCommunication"
        ],
        "type": "object"
      },
      "Canary": {
        "description": "The configuration of the canary mode for a service descriptor",
        "properties": {
          "enabled": {
            "description": "Use canary mode for this service",
            "example": true,
            "type": "boolean"
          },
          "root": {
            "description": "Otoroshi will append this root to any target choosen. If the specified root is '/api/foo', then a request to https://yyyyyyy/bar will actually hit https://xxxxxxxxx/api/foo/bar",
            "example": "a string value",
            "type": "string"
          },
          "targets": {
            "description": "The list of target that Otoroshi will proxy and expose through the subdomain defined before. Otoroshi will do round-robin load balancing between all those targets with circuit breaker mecanism to avoid cascading failures",
            "items": {
              "$ref": "#/$defs/Target"
            },
            "type": "array"
          },
          "traffic": {
            "description": "Ratio of traffic that will be sent to canary targets.",
            "example": 123123,
            "format": "int32",
            "type": "integer"
          }
        },
        "required": [
          "enabled",
          "traffic",
          "targets",
          "root"
        ],
        "type": "object"
      },
      "Target": {
        "description": "A Target is where an HTTP call will be forwarded in the end from a service domain",
        "properties": {
          "host": {
            "description": "The host on which the HTTP call will be forwarded. Can be a domain name, or an IP address. Can also have a port",
            "example": "www.google.com",
            "format": "hostname",
            "type": "string"
          },
          "scheme": {
            "description": "The protocol used for communication. Can be http or https",
            "example": "a string value",
            "type": "string"
          }
        },
        "required": [
          "host",
          "scheme"
        ],
        "type": "object"
      },
      "ExposedApi": {
        "description": "The Open API configuration for your service (if one)",
        "properties": {
          "exposeApi": {
            "description": "Whether or not the current service expose an API with an Open API descriptor",
            "example": true,
            "type": "boolean"
          },
          "openApiDescriptorUrl": {
            "description": "The URL of the Open API descriptor",
            "example": "http://www.google.com",
            "format": "uri",
            "type": "string"
          }
        },
        "required": [
          "exposeApi"
        ],
        "type": "object"
      },
      "ChaosConfig": {
        "description": "Configuration for the faults that can be injected in requests",
        "properties": {
          "badResponsesFaultConfig": {
            "$ref": "#/$defs/BadResponsesFaultConfig"
          },
          "enabled": {
            "description": "Whether or not this config is enabled",
            "example": true,
            "type": "boolean"
          },
          "largeRequestFaultConfig": {
            "$ref": "#/$defs/LargeRequestFaultConfig"
          },
          "largeResponseFaultConfig": {
            "$ref": "#/$defs/LargeResponseFaultConfig"
          },
          "latencyInjectionFaultConfig": {
            "$ref": "#/$defs/LatencyInjectionFaultConfig"
          }
        },
        "required": [
          "enabled"
        ],
        "type": "object"
      },
      "BadResponsesFaultConfig": {
        "description": "Config for bad requests injection fault",
        "properties": {
          "ratio": {
            "description": "The percentage of requests affected by this fault. Value should be between 0.0 and 1.0",
            "example": 42.2,
            "format": "double",
            "type": "number"
          },
          "responses": {
            "description": "The possibles responses",
            "items": {
              "$ref": "#/$defs/BadResponse"
            },
            "type": "array"
          }
        },
        "required": [
          "ratio",
          "responses"
        ],
        "type": "object"
      },
      "BadResponse": {
        "description": "An HTTP response that is not supposed to be returned by a service",
        "properties": {
          "body": {
            "description": "The body of the HTTP response",
            "example": "a string value",
            "type": "string"
          },
          "headers": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "The HTTP headers of the response",
            "example": {
              "key": "value"
            },
            "type": "object"
          },
          "status": {
            "description": "The HTTP status for the response",
            "example": 123123,
            "format": "int32",
            "type": "integer"
          }
        },
        "required": [
          "status",
          "body",
          "headers"
        ],
        "type": "object"
      },
      "LargeRequestFaultConfig": {
        "description": "Config for large request injection fault",
        "properties": {
          "additionalRequestSize": {
            "description": "The size added to the request body in bytes. Added payload will be spaces only.",
            "example": 123123,
            "format": "int32",
            "type": "integer"
          },
          "ratio": {
            "description": "The percentage of requests affected by this fault. Value should be between 0.0 and 1.0",
            "example": 42.2,
            "format": "double",
            "type": "number"
          }
        },
        "required": [
          "ratio",
          "additionalRequestSize"
        ],
        "type": "object"
      },
      "LargeResponseFaultConfig": {
        "description": "Config for large response injection fault",
        "properties": {
          "additionalRequestSize": {
            "description": "The size added to the response body in bytes. Added payload will be spaces only.",
            "example": 123123,
            "format": "int32",
            "type": "integer"
          },
          "ratio": {
            "description": "The percentage of requests affected by this fault. Value should be between 0.0 and 1.0",
            "example": 42.2,
            "format": "double",
            "type": "number"
          }
        },
        "required": [
          "ratio",
          "additionalResponseSize"
        ],
        "type": "object"
      },
      "LatencyInjectionFaultConfig": {
        "description": "Config for large latency injection fault",
        "properties": {
          "from": {
            "description": "The start range of latency added to the request",
            "example": 123123,
            "format": "int32",
            "type": "integer"
          },
          "ratio": {
            "description": "The percentage of requests affected by this fault. Value should be between 0.0 and 1.0",
            "example": 42.2,
            "format": "double",
            "type": "number"
          },
          "to": {
            "description": "The end range of latency added to the request",
            "example": 123123,
            "format": "int32",
            "type": "integer"
          }
        },
        "required": [
          "ratio",
          "from",
          "to"
        ],
        "type": "object"
      },
      "ClientConfig": {
        "description": "The configuration of the circuit breaker for a service descriptor",
        "properties": {
          "backoffFactor": {
            "description": "Specify the factor to multiply the delay for each retry",
            "example": 123123,
            "format": "int32",
            "type": "integer"
          },
          "callTimeout": {
            "description": "Specify how long each call should last at most in milliseconds",
            "example": 123123,
            "format": "int32",
            "type": "integer"
          },
          "globalTimeout": {
            "description": "Specify how long the global call (with retries) should last at most in milliseconds",
            "example": 123123,
            "format": "int32",
            "type": "integer"
          },
          "maxErrors": {
            "description": "Specify how many errors can pass before opening the circuit breaker",
            "example": 123123,
            "format": "int32",
            "type": "integer"
          },
          "retries": {
            "description": "Specify how many times the client will try to fetch the result of the request after an error before giving up.",
            "example": 123123,
            "format": "int32",
            "type": "integer"
          },
          "retryInitialDelay": {
            "description": "Specify the delay between two retries. Each retry, the delay is multiplied by the backoff factor",
            "example": 123123,
            "format": "int32",
            "type": "integer"
          },
          "sampleInterval": {
            "description": "Specify the sliding window time for the circuit breaker in milliseconds, after this time, error count will be reseted",
            "example": 123123,
            "format": "int32",
            "type": "integer"
          },
          "useCircuitBreaker": {
            "description": "Use a circuit breaker to avoid cascading failure when calling chains of services. Highly recommended !",
            "example": true,
            "type": "boolean"
          }
        },
        "required": [
          "useCircuitBreaker",
          "retries",
          "maxErrors",
          "retryInitialDelay",
          "backoffFactor",
          "callTimeout",
          "globalTimeout",
          "sampleInterval"
        ],
        "type": "object"
      },
      "CorsSettings": {
        "description": "The configuration for cors support",
        "properties": {
          "allowCredentials": {
            "description": "Allow to pass credentials",
            "example": true,
            "type": "boolean"
          },
          "allowHeaders": {
            "description": "The cors allowed headers",
            "items": {
              "example": "a string value",
              "type": "string"
            },
            "type": "array"
          },
          "allowMethods": {
            "description": "The cors allowed methods",
            "items": {
              "example": "a string value",
              "type": "string"
            },
            "type": "array"
          },
          "allowOrigin": {
            "description": "The cors allowed origin",
            "example": "a string value",
            "type": "string"
          },
          "enabled": {
            "description": "Whether or not cors is enabled",
            "example": true,
            "type": "boolean"
          },
          "excludedPatterns": {
            "description": "The cors excluded patterns",
            "items": {
              "example": "a string value",
              "type": "string"
            },
            "type": "array"
          },
          "exposeHeaders": {
            "description": "The cors exposed header",
            "items": {
              "example": "a string value",
              "type": "string"
            },
            "type": "array"
          },
          "maxAge": {
            "description": "Cors max age",
            "example": 123123,
            "format": "int32",
            "type": "integer"
          }
        },
        "required": [
          "enabled",
          "allowOrigin",
          "exposeHeaders",
          "allowHeaders",
          "allowMethods",
          "excludedPatterns",
          "maxAge",
          "allowCredentials"
        ],
        "type": "object"
      },
      "Gzip": {
        "description": "Configuration for gzip of service responses",
        "properties": {
          "blackList": {
            "description": "Blacklisted mime types. Wildcard supported",
            "items": {
              "example": "a string value",
              "type": "string"
            },
            "type": "array"
          },
          "bufferSize": {
            "description": "Size of the GZip buffer",
            "example": 123,
            "format": "int64",
            "type": "integer"
          },
          "chunkedThreshold": {
            "description": "Threshold for chunking data",
            "example": 123,
            "format": "int64",
            "type": "integer"
          },
          "compressionLevel": {
            "description": "Compression level. From 0 to 9",
            "example": 123123,
            "format": "int32",
            "type": "integer"
          },
          "enabled": {
            "description": "Whether gzip compression is enabled or not",
            "example": true,
            "type": "boolean"
          },
          "excludedPatterns": {
            "description": "Patterns that are excluded from gzipping",
            "items": {
              "example": "a string value",
              "type": "string"
            },
            "type": "array"
          },
          "whiteList": {
            "description": "Whitelisted mime types. Wildcard supported",
            "items": {
              "example": "a string value",
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "enabled",
          "excludedPatterns",
          "whiteList",
          "blackList",
          "bufferSize",
          "chunkedThreshold",
          "compressionLevel"
        ],
        "type": "object"
      },
      "HealthCheck": {
        "description": "The configuration for checking health of a service. Otoroshi will perform GET call on the URL to check if the service is still alive",
        "properties": {
          "enabled": {
            "description": "Whether or not healthcheck is enabled on the current service descriptor",
            "example": true,
            "type": "boolean"
          },
          "url": {
            "description": "The URL to check",
            "example": "http://www.google.com",
            "format": "uri",
            "type": "string"
          }
        },
        "required": [
          "enabled"
        ],
        "type": "object"
      },
      "IpFiltering": {
        "description": "The filtering configuration block for a service of globally.",
        "properties": {
          "blacklist": {
            "description": "Blacklisted IP addresses",
            "items": {
              "example": "192.192.192.192",
              "format": "ipv4",
              "type": "string"
            },
            "type": "array"
          },
          "whitelist": {
            "description": "Whitelisted IP addresses",
            "items": {
              "example": "192.192.192.192",
              "format": "ipv4",
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "whitelist",
          "blacklist"
        ],
        "type": "object"
      },
      "LocalJwtVerifier": {
        "description": "A JWT verifier used only for the current service descriptor",
        "properties": {
          "algoSettings": {
            "oneOf": [
              {
                "$ref": "#/$defs/HSAlgoSettings"
              },
              {
                "$ref": "#/$defs/RSAlgoSettings"
              },
              {
                "$ref": "#/$defs/ESAlgoSettings"
              },
              {
                "$ref": "#/$defs/JWKSAlgoSettings"
              }
            ]
          },
          "enabled": {
            "description": "Is it enabled",
            "example": true,
            "type": "boolean"
          },
          "source": {
            "oneOf": [
              {
                "$ref": "#/$defs/InQueryParam"
              },
              {
                "$ref": "#/$defs/InHeader"
              },
              {
                "$ref": "#/$defs/InCookie"
              }
            ]
          },
          "strategy": {
            "oneOf": [
              {
                "$ref": "#/$defs/PassThrough"
              },
              {
                "$ref": "#/$defs/Sign"
              },
              {
                "$ref": "#/$defs/Transform"
              }
            ]
          },
          "strict": {
            "description": "Does it fail if JWT not found",
            "example": true,
            "type": "boolean"
          },
          "type": {
            "description": "A string with value 'local'",
            "example": "a string value",
            "type": "string"
          }
        },
        "required": [
          "type",
          "enabled",
          "strict",
          "source",
          "algoSettings",
          "strategy"
        ],
        "type": "object"
      },
      "HSAlgoSettings": {
        "description": "Settings for an HMAC + SHA signing algorithm",
        "properties": {
          "secret": {
            "description": "The secret value for the HMAC function",
            "example": "a string value",
            "type": "string"
          },
          "size": {
            "description": "Size for SHA function. can be 256, 384 or 512",
            "example": 123123,
            "format": "int32",
            "type": "integer"
          },
          "type": {
            "description": "String with value HSAlgoSettings",
            "example": "a string value",
            "type": "string"
          }
        },
        "required": [
          "type",
          "size",
          "secret"
        ],
        "type": "object"
      },
      "RSAlgoSettings": {
        "description": "Settings for an HMAC + SHA signing algorithm",
        "properties": {
          "privateKey": {
            "description": "The private key for the RSA function",
            "example": "a string value",
            "type": "string"
          },
          "publicKey": {
            "description": "The public key for the RSA function",
            "example": "a string value",
            "type": "string"
          },
          "size": {
            "description": "Size for SHA function. can be 256, 384 or 512",
            "example": 123123,
            "format": "int32",
            "type": "integer"
          },
          "type": {
            "description": "String with value RSAlgoSettings",
            "example": "a string value",
            "type": "string"
          }
        },
        "required": [
          "type",
          "size",
          "publicKey"
        ],
        "type": "object"
      },
      "ESAlgoSettings": {
        "description": "Settings for an EC + SHA signing algorithm",
        "properties": {
          "privateKey": {
            "description": "The private key for the RSA function",
            "example": "a string value",
            "type": "string"
          },
          "publicKey": {
            "description": "The public key for the RSA function",
            "example": "a string value",
            "type": "string"
          },
          "size": {
            "description": "Size for SHA function. can be 256, 384 or 512",
            "example": 123123,
            "format": "int32",
            "type": "integer"
          },
          "type": {
            "description": "String with value ESAlgoSettings",
            "example": "a string value",
            "type": "string"
          }
        },
        "required": [
          "type",
          "size",
          "publicKey"
        ],
        "type": "object"
      },
      "JWKSAlgoSettings": {
        "description": "Settings for a JWK set",
        "properties": {
          "headers": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "The headers for the http call",
            "example": {
              "key": "value"
            },
            "type": "object"
          },
          "kty": {
            "description": "The type of key: RSA or EC",
            "example": "a string value",
            "type": "string"
          },
          "timeout": {
            "description": "The timeout of the http call",
            "example": 123,
            "format": "int64",
            "type": "integer"
          },
          "ttl": {
            "description": "The ttl of the keyset",
            "example": 123,
            "format": "int64",
            "type": "integer"
          },
          "type": {
            "description": "String with value JWKSAlgoSettings",
            "example": "a string value",
            "type": "string"
          },
          "url": {
            "description": "The url for the http call",
            "example": "a string value",
            "type": "string"
          }
        },
        "required": [
          "type",
          "size",
          "publicKey"
        ],
        "type": "object"
      },
      "InQueryParam": {
        "description": "JWT location in a query param",
        "properties": {
          "name": {
            "description": "Name of the query param",
            "example": "a string value",
            "type": "string"
          },
          "type": {
            "description": "String with value InQueryParam",
            "example": "a string value",
            "type": "string"
          }
        },
        "required": [
          "type",
          "name"
        ],
        "type": "object"
      },
      "InHeader": {
        "description": "JWT location in a header",
        "properties": {
          "name": {
            "description": "Name of the header",
            "example": "a string value",
            "type": "string"
          },
          "remove": {
            "description": "Remove regex inside the value, like 'Bearer '",
            "example": "a string value",
            "type": "string"
          },
          "type": {
            "description": "String with value InHeader",
            "example": "a string value",
            "type": "string"
          }
        },
        "required": [
          "type",
          "name",
          "remove"
        ],
        "type": "object"
      },
      "InCookie": {
        "description": "JWT location in a cookie",
        "properties": {
          "name": {
            "description": "Name of the cookie",
            "example": "a string value",
            "type": "string"
          },
          "type": {
            "description": "String with value InCookie",
            "example": "a string value",
            "type": "string"
          }
        },
        "required": [
          "type",
          "name"
        ],
        "type": "object"
      },
      "PassThrough": {
        "description": "Strategy where only signature and field values are verified",
        "properties": {
          "type": {
            "description": "String with value PassThrough",
            "example": "a string value",
            "type": "string"
          },
          "verificationSettings": {
            "$ref": "#/$defs/VerificationSettings"
          }
        },
        "required": [
          "type",
          "verificationSettings"
        ],
        "type": "object"
      },
      "VerificationSettings": {
        "description": "Settings to verify the value of JWT token fields",
        "properties": {
          "fields": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Fields to verify with their values",
            "example": {
              "key": "value"
            },
            "type": "object"
          },
          "mappingSettings": {
            "$ref": "#/$defs/MappingSettings"
          }
        },
        "required": [
          "fields"
        ],
        "type": "object"
      },
      "MappingSettings": {
        "description": "Settings to change fields of a JWT token",
        "properties": {
          "map": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Fields to rename",
            "example": {
              "key": "value"
            },
            "type": "object"
          },
          "remove": {
            "description": "Fields to remove",
            "items": {
              "example": "a string value",
              "type": "string"
            },
            "type": "array"
          },
          "values": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Fields to set",
            "example": {
              "key": "value"
            },
            "type": "object"
          }
        },
        "required": [
          "map",
          "values",
          "remove"
        ],
        "type": "object"
      },
      "Sign": {
        "description": "Strategy where signature and field values are verified, and then token si re-signed",
        "properties": {
          "algoSettings": {
            "oneOf": [
              {
                "$ref": "#/$defs/HSAlgoSettings"
              },
              {
                "$ref": "#/$defs/RSAlgoSettings"
              },
              {
                "$ref": "#/$defs/ESAlgoSettings"
              },
              {
                "$ref": "#/$defs/JWKSAlgoSettings"
              }
            ]
          },
          "type": {
            "description": "String with value Sign",
            "example": "a string value",
            "type": "string"
          },
          "verificationSettings": {
            "$ref": "#/$defs/VerificationSettings"
          }
        },
        "required": [
          "type",
          "verificationSettings",
          "algoSettings"
        ],
        "type": "object"
      },
      "Transform": {
        "description": "Strategy where signature and field values are verified, trasnformed and then token si re-signed",
        "properties": {
          "algoSettings": {
            "oneOf": [
              {
                "$ref": "#/$defs/HSAlgoSettings"
              },
              {
                "$ref": "#/$defs/RSAlgoSettings"
              },
              {
                "$ref": "#/$defs/ESAlgoSettings"
              },
              {
                "$ref": "#/$defs/JWKSAlgoSettings"
              }
            ]
          },
          "transformSettings": {
            "$ref": "#/$defs/TransformSettings"
          },
          "type": {
            "description": "String with value Transform",
            "example": "a string value",
            "type": "string"
          },
          "verificationSettings": {
            "$ref": "#/$defs/VerificationSettings"
          }
        },
        "required": [
          "type",
          "verificationSettings",
          "algoSettings"
        ],
        "type": "object"
      },
      "TransformSettings": {
        "description": "Settings to transform a JWT token and its location",
        "properties": {
          "location": {
            "oneOf": [
              {
                "$ref": "#/$defs/InQueryParam"
              },
              {
                "$ref": "#/$defs/InHeader"
              },
              {
                "$ref": "#/$defs/InCookie"
              }
            ]
          },
          "mappingSettings": {
            "$ref": "#/$defs/MappingSettings"
          }
        },
        "required": [
          "location",
          "mappingSettings"
        ],
        "type": "object"
      },
      "RefJwtVerifier": {
        "description": "Reference to a global JWT verifier",
        "properties": {
          "enabled": {
            "description": "Is it enabled",
            "example": true,
            "type": "boolean"
          },
          "id": {
            "description": "The id of the GlobalJWTVerifier",
            "example": "a string value",
            "type": "string"
          },
          "type": {
            "description": "A string with value 'ref'",
            "example": "a string value",
            "type": "string"
          }
        },
        "required": [
          "type",
          "id",
          "enabled"
        ],
        "type": "object"
      },
      "RedirectionSettings": {
        "description": "The configuration for redirection per service",
        "properties": {
          "code": {
            "description": "The http redirect code",
            "example": 123123,
            "format": "int32",
            "type": "integer"
          },
          "enabled": {
            "description": "Whether or not redirection is enabled",
            "example": true,
            "type": "boolean"
          },
          "to": {
            "description": "The location for redirection",
            "example": "a string value",
            "type": "string"
          }
        },
        "required": [
          "enabled",
          "to",
          "code"
        ],
        "type": "object"
      },
      "StatsdConfig": {
        "description": "The configuration for statsd metrics push",
        "properties": {
          "datadog": {
            "description": "Datadog agent",
            "example": true,
            "type": "boolean"
          },
          "host": {
            "description": "The host of the StatsD agent",
            "example": "a string value",
            "type": "string"
          },
          "port": {
            "description": "The port of the StatsD agent",
            "example": 123123,
            "format": "int32",
            "type": "integer"
          }
        },
        "required": [
          "host",
          "port",
          "datadog"
        ],
        "type": "object"
      }
    }
  },
  "handler": "http",
  "request": {
    "method": "POST",
    "url": {
      "$uri": "http://otoroshi-api.oto.tools//api/services"
    },
    "body": {
      "$": "body",
      "encode": "json"
    }
  },
  "responses": {
    "200": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "An otoroshi service descriptor. Represent a forward HTTP call on a domain to another location with some optional api management mecanism",
        "**Key properties:**",
        {
          "$ul": [
            [
              "**Canary**: The configuration of the canary mode for a service descriptor",
              {
                "$ul": [
                  "**enabled**: Use canary mode for this service",
                  "**root**: Otoroshi will append this root to any target choosen. If the specified root is '/api/foo', then a request to https://yyyyyyy/bar will actually hit https://xxxxxxxxx/api/foo/bar",
                  "**targets**: The list of target that Otoroshi will proxy and expose through the subdomain defined before. Otoroshi will do round-robin load balancing between all those targets with circuit breaker mecanism to avoid cascading failures",
                  "**traffic**: Ratio of traffic that will be sent to canary targets."
                ]
              }
            ],
            "**additionalHeaders**: Specify headers that will be added to each client request. Useful to add authentication",
            [
              "**api**: The Open API configuration for your service (if one)",
              {
                "$ul": [
                  "**exposeApi**: Whether or not the current service expose an API with an Open API descriptor",
                  "**openApiDescriptorUrl**: The URL of the Open API descriptor"
                ]
              }
            ],
            "**authConfigRef**: A reference to a global auth module config",
            "**buildMode**: Display a construction page when a user try to use the service",
            [
              "**chaosConfig**: Configuration for the faults that can be injected in requests",
              {
                "$ul": [
                  [
                    "**badResponsesFaultConfig**: Config for bad requests injection fault",
                    {
                      "$ul": [
                        "**ratio**: The percentage of requests affected by this fault. Value should be between 0.0 and 1.0",
                        "**responses**: The possibles responses"
                      ]
                    }
                  ],
                  "**enabled**: Whether or not this config is enabled",
                  [
                    "**largeRequestFaultConfig**: Config for large request injection fault",
                    {
                      "$ul": [
                        "**additionalRequestSize**: The size added to the request body in bytes. Added payload will be spaces only.",
                        "**ratio**: The percentage of requests affected by this fault. Value should be between 0.0 and 1.0"
                      ]
                    }
                  ],
                  [
                    "**largeResponseFaultConfig**: Config for large response injection fault",
                    {
                      "$ul": [
                        "**additionalRequestSize**: The size added to the response body in bytes. Added payload will be spaces only.",
                        "**ratio**: The percentage of requests affected by this fault. Value should be between 0.0 and 1.0"
                      ]
                    }
                  ],
                  [
                    "**latencyInjectionFaultConfig**: Config for large latency injection fault",
                    {
                      "$ul": [
                        "**from**: The start range of latency added to the request",
                        "**ratio**: The percentage of requests affected by this fault. Value should be between 0.0 and 1.0",
                        "**to**: The end range of latency added to the request"
                      ]
                    }
                  ]
                ]
              }
            ],
            [
              "**clientConfig**: The configuration of the circuit breaker for a service descriptor",
              {
                "$ul": [
                  "**backoffFactor**: Specify the factor to multiply the delay for each retry",
                  "**callTimeout**: Specify how long each call should last at most in milliseconds",
                  "**globalTimeout**: Specify how long the global call (with retries) should last at most in milliseconds",
                  "**maxErrors**: Specify how many errors can pass before opening the circuit breaker",
                  "**retries**: Specify how many times the client will try to fetch the result of the request after an error before giving up.",
                  "**retryInitialDelay**: Specify the delay between two retries. Each retry, the delay is multiplied by the backoff factor",
                  "**sampleInterval**: Specify the sliding window time for the circuit breaker in milliseconds, after this time, error count will be reseted",
                  "**useCircuitBreaker**: Use a circuit breaker to avoid cascading failure when calling chains of services. Highly recommended !"
                ]
              }
            ],
            "**clientValidatorRef**: A reference to validation authority",
            [
              "**cors**: The configuration for cors support",
              {
                "$ul": [
                  "**allowCredentials**: Allow to pass credentials",
                  "**allowHeaders**: The cors allowed headers",
                  "**allowMethods**: The cors allowed methods",
                  "**allowOrigin**: The cors allowed origin",
                  "**enabled**: Whether or not cors is enabled",
                  "**excludedPatterns**: The cors excluded patterns",
                  "**exposeHeaders**: The cors exposed header",
                  "**maxAge**: Cors max age"
                ]
              }
            ],
            "**domain**: The domain on which the service is available.",
            "**enabled**: Activate or deactivate your service. Once disabled, users will get an error page saying the service does not exist",
            "**enforceSecureCommunication**: When enabled, Otoroshi will try to exchange headers with downstream service to ensure no one else can use the service from outside",
            "**env**: The line on which the service is available. Based on that value, the name of the line will be appended to the subdomain. For line prod, nothing will be appended. For example, if the subdomain is 'foo' and line is 'preprod', then the exposed service will be available at 'foo.preprod.mydomain'",
            "**forceHttps**: Will force redirection to https:// if not present",
            "**groups**: Each service descriptor is attached to groups. A group can have one or more services. Each API key is linked to a group and allow access to every service in the group",
            [
              "**gzip**: Configuration for gzip of service responses",
              {
                "$ul": [
                  "**blackList**: Blacklisted mime types. Wildcard supported",
                  "**bufferSize**: Size of the GZip buffer",
                  "**chunkedThreshold**: Threshold for chunking data",
                  "**compressionLevel**: Compression level. From 0 to 9",
                  "**enabled**: Whether gzip compression is enabled or not",
                  "**excludedPatterns**: Patterns that are excluded from gzipping",
                  "**whiteList**: Whitelisted mime types. Wildcard supported"
                ]
              }
            ],
            "**headersVerification**: Specify headers that will be verified after routing.",
            [
              "**healthCheck**: The configuration for checking health of a service. Otoroshi will perform GET call on the URL to check if the service is still alive",
              {
                "$ul": [
                  "**enabled**: Whether or not healthcheck is enabled on the current service descriptor",
                  "**url**: The URL to check"
                ]
              }
            ],
            "**id**: A unique random string to identify your service",
            [
              "**ipFiltering**: The filtering configuration block for a service of globally.",
              {
                "$ul": [
                  "**blacklist**: Blacklisted IP addresses",
                  "**whitelist**: Whitelisted IP addresses"
                ]
              }
            ],
            "**jwtVerifier**",
            "**localHost**: The host used localy, mainly localhost:xxxx",
            "**localScheme**: The scheme used localy, mainly http",
            "**maintenanceMode**: Display a maintainance page when a user try to use the service",
            "**matchingHeaders**: Specify headers that MUST be present on client request to route it. Useful to implement versioning",
            "**matchingRoot**: The root path on which the service is available",
            "**metadata**: Just a bunch of random properties",
            "**name**: The name of your service. Only for debug and human readability purposes",
            "**overrideHost**: Host header will be overriden with Host of the target",
            "**privateApp**: When enabled, user will be allowed to use the service (UI) only if they are registered users of the private apps domain",
            "**privatePatterns**: If you define a public pattern that is a little bit too much, you can make some of public URL private again",
            "**publicPatterns**: By default, every services are private only and you'll need an API key to access it. However, if you want to expose a public UI, you can define one or more public patterns (regex) to allow access to anybody. For example if you want to allow anybody on any URL, just use '/.*'",
            "**redirectToLocal**: If you work locally with Otoroshi, you may want to use that feature to redirect one particuliar service to a local host. For example, you can relocate https://foo.preprod.bar.com to http://localhost:8080 to make some tests",
            [
              "**redirection**: The configuration for redirection per service",
              {
                "$ul": [
                  "**code**: The http redirect code",
                  "**enabled**: Whether or not redirection is enabled",
                  "**to**: The location for redirection"
                ]
              }
            ],
            "**root**: Otoroshi will append this root to any target choosen. If the specified root is '/api/foo', then a request to https://yyyyyyy/bar will actually hit https://xxxxxxxxx/api/foo/bar",
            "**secComExcludedPatterns**: URI patterns excluded from secured communications",
            "**secComSettings**",
            "**sendOtoroshiHeadersBack**: When enabled, Otoroshi will send headers to consumer like request id, client latency, overhead, etc ...",
            [
              "**statsdConfig**: The configuration for statsd metrics push",
              {
                "$ul": [
                  "**datadog**: Datadog agent",
                  "**host**: The host of the StatsD agent",
                  "**port**: The port of the StatsD agent"
                ]
              }
            ],
            "**subdomain**: The subdomain on which the service is available",
            "**targets**: The list of target that Otoroshi will proxy and expose through the subdomain defined before. Otoroshi will do round-robin load balancing between all those targets with circuit breaker mecanism to avoid cascading failures",
            "**transformerRef**: A reference to a request transformer",
            "**userFacing**: The fact that this service will be seen by users and cannot be impacted by the Snow Monkey",
            "**xForwardedHeaders**: Send X-Forwarded-* headers"
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    }
  }
}
