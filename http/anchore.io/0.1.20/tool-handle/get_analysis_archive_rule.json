{
  "name": "get_analysis_archive_rule",
  "parameters": {
    "type": "object",
    "properties": {
      "ruleId": {
        "type": "string"
      }
    },
    "required": [
      "ruleId"
    ]
  },
  "handler": "http",
  "request": {
    "method": "GET",
    "url": {
      "$uri": "//archives/rules/{ruleId}"
    }
  },
  "responses": {
    "200": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "A rule for auto-archiving image analysis by time and/or tag-history",
        "**Key properties:**",
        {
          "$ul": [
            "**analysis_age_days**: Matches if the analysis is strictly older than this number of days",
            "**created_at**",
            [
              "**exclude**: Which Images to exclude from auto-archiving logic",
              {
                "$ul": [
                  "**expiration_days**: How long the image selected will be excluded from the archive transition (default: -1)",
                  [
                    "**selector**: A set of selection criteria to match an image by a tagged pullstring based on its components, with regex support in each field",
                    {
                      "$ul": [
                        "**registry**: The registry section of a pull string. e.g. with \"docker.io/anchore/anchore-engine:latest\", this is \"docker.io\"",
                        "**repository**: The repository section of a pull string. e.g. with \"docker.io/anchore/anchore-engine:latest\", this is \"anchore/anchore-engine\"",
                        "**tag**: The tag-only section of a pull string. e.g. with \"docker.io/anchore/anchore-engine:latest\", this is \"latest\""
                      ]
                    }
                  ]
                ]
              }
            ],
            "**last_updated**",
            "**max_images_per_account**: This is the maximum number of image analyses an account can have. Can only be set on system_global rules",
            "**rule_id**: Unique identifier for archive rule",
            [
              "**selector**: A set of selection criteria to match an image by a tagged pullstring based on its components, with regex support in each field",
              {
                "$ul": [
                  "**registry**: The registry section of a pull string. e.g. with \"docker.io/anchore/anchore-engine:latest\", this is \"docker.io\"",
                  "**repository**: The repository section of a pull string. e.g. with \"docker.io/anchore/anchore-engine:latest\", this is \"anchore/anchore-engine\"",
                  "**tag**: The tag-only section of a pull string. e.g. with \"docker.io/anchore/anchore-engine:latest\", this is \"latest\""
                ]
              }
            ],
            "**system_global**: True if the rule applies to all accounts in the system. This is only available to admin users to update/modify, but all users with permission to list rules can see them",
            "**tag_versions_newer**: Number of images mapped to the tag that are newer",
            "**transition**: The type of transition to make. If \"archive\", then archive an image from the working set and remove it from the working set. If \"delete\", then match against archived images and delete from the archive if match."
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    },
    "500": {
      "$encode": "markdown",
      "$block": [
        {
          "$h1": "Object"
        },
        "Generic HTTP API error response",
        "**Key properties:**",
        {
          "$ul": [
            "**code**",
            "**detail**: Details structure for additional information about the error if available. Content and structure will be error specific.",
            "**error_type**",
            "**message**"
          ]
        },
        {
          "$lang": "json",
          "$code": {
            "$encode": "json",
            "$indent": true,
            "$content": {
              "$": "$.body"
            }
          }
        }
      ]
    }
  }
}
